{"version":3,"file":"Factories.cjs","sources":["../../src/Factories.ts"],"sourcesContent":["import MockXhr from './MockXhr';\nimport MockXhrServer from './MockXhrServer';\n\nimport type { OnCreateCallback, OnSendCallback } from './MockXhr';\nimport type { UrlMatcher, RequestHandler } from './MockXhrServer';\n\n/**\n * Create a new \"local\" MockXhr subclass. Using a subclass of `MockXhr` in each test case makes it\n * easier to ensure they are self-contained. For example if you set the onSend static propertiy on\n * a subclass, this will only affect that subclass and not the others created in your other test\n * cases. You therefore don't need to add cleanup code to revert the changes made to the subclass.\n *\n * @returns New MockXhr subclass\n */\nexport function newMockXhr(): typeof MockXhr {\n  return class LocalMockXhr extends MockXhr {\n    // Reset to default value to override the parent class' flag\n    static timeoutEnabled = true;\n\n    static onCreate?: OnCreateCallback;\n\n    static onSend?: OnSendCallback;\n\n    constructor() {\n      super();\n\n      // Call the local MockXhr subclass' onCreate hook on the new mock instance\n      LocalMockXhr.onCreate?.(this);\n    }\n  };\n}\n\n/**\n * @param routes Routes\n * @returns new MockXhrServerserver with its own MockXhr subclass.\n */\nexport function newServer(routes?: Record<string, [UrlMatcher, RequestHandler]>) {\n  return new MockXhrServer(newMockXhr(), routes);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAMA;;;;;;;AAOG;SACa,UAAU,GAAA;;IACxB,OAAO,EAAA,GAAA,MAAM,YAAa,SAAQ,OAAO,CAAA;AAQvC,YAAA,WAAA,GAAA;AACE,gBAAA,KAAK,EAAE,CAAC;;AAGR,gBAAA,EAAY,CAAC,QAAQ,GAAG,IAAI,CAAC,CAAC;aAC/B;AACF,SAAA;;AAZQ,QAAA,EAAA,CAAA,cAAc,GAAG,IAAK;AAY7B,QAAA,EAAA,CAAA;AACJ,CAAC;AAED;;;AAGG;AACG,SAAU,SAAS,CAAC,MAAqD,EAAA;IAC7E,OAAO,IAAI,aAAa,CAAC,UAAU,EAAE,EAAE,MAAM,CAAC,CAAC;AACjD;;;;;"}
/**
 * mock-xmlhttprequest v8.3.0
 * (c) 2023 Bertrand Guay-Paquet
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

function getBodyByteSize(body) {
    if (!body) {
        return 0;
    }
    if (typeof body === 'string') {
        return getStringByteLength(body);
    }
    else if ((typeof FormData !== 'undefined' && body instanceof FormData)
        || (body.constructor && body.constructor.name === 'FormData')) {
        // A FormData has field-value pairs. This testing code only sums the individual sizes of the
        // values. The full multipart/form-data encoding also adds headers, encoding, etc. which we
        // don't reproduce here.
        return [...body.values()].reduce((sum, value) => {
            const valueSize = value.size ?? getStringByteLength(String(value.toString()));
            return sum + valueSize;
        }, 0);
    }
    // Handles Blob and BufferSource
    return body.size || body.byteLength || 0;
}
function getStringByteLength(string) {
    // Compute the byte length of the string (which is not the same as string.length)
    // Use Blob if available (i.e. in the browser) and Buffer otherwise.
    return typeof Blob !== 'undefined' ? new Blob([string]).size : Buffer.byteLength(string);
}
const isTokenRegEx = /^[A-Za-z0-9!#$%&'*+\-.^_`|~]+$/;
/**
 * See https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.6
 * @param token Token
 * @returns Whether token is a valid token
 */
function isToken(token) {
    return typeof token === 'string' && isTokenRegEx.test(token);
}
/**
 * https://datatracker.ietf.org/doc/html/rfc7230#section-3.2
 * @param headerName Header name
 * @returns Whether headerName is a valid header name
 */
function isHeaderName(headerName) {
    return isToken(headerName);
}
/**
 * https://fetch.spec.whatwg.org/#header-value
 * @param headerValue Header value
 * @returns Whether headerValue is a valid header value
 */
function isHeaderValue(headerValue) {
    return typeof headerValue === 'string'
        && headerValue.trim().length === headerValue.length
        && headerValue.indexOf('\0') === -1;
}
// Disallowed request headers for setRequestHeader()
const forbiddenHeaders = [
    'Accept-Charset',
    'Accept-Encoding',
    'Access-Control-Request-Headers',
    'Access-Control-Request-Method',
    'Connection',
    'Content-Length',
    'Cookie',
    'Cookie2',
    'Date',
    'DNT',
    'Expect',
    'Host',
    'Keep-Alive',
    'Origin',
    'Referer',
    'TE',
    'Trailer',
    'Transfer-Encoding',
    'Upgrade',
    'Via',
];
const forbiddenHeaderRegEx = new RegExp(`^(${forbiddenHeaders.join('|')}|Proxy-.*|Sec-.*)$`, 'i');
/**
 * See https://fetch.spec.whatwg.org/#forbidden-header-name
 *
 * @param name Header name
 * @returns Whether the request header name is forbidden for XMLHttpRequest
 */
function isRequestHeaderForbidden(name) {
    return forbiddenHeaderRegEx.test(name);
}
/**
 * See https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.1
 * @param method Method name
 * @returns Whether method is a valid request method
 */
function isRequestMethod(method) {
    return isToken(method);
}
const isRequestMethodForbiddenRegEx = /^(CONNECT|TRACE|TRACK)$/i;
/**
 * See https://fetch.spec.whatwg.org/#forbidden-method
 *
 * @param method Method name
 * @returns Whether the request method is forbidden for XMLHttpRequest
 */
function isRequestMethodForbidden(method) {
    return isRequestMethodForbiddenRegEx.test(method);
}
// Normalize method names as described in open()
// https://xhr.spec.whatwg.org/#the-open()-method
const upperCaseMethods = [
    'DELETE',
    'GET',
    'HEAD',
    'OPTIONS',
    'POST',
    'PUT',
];
const upperCaseMethodsRegEx = new RegExp(`^(${upperCaseMethods.join('|')})$`, 'i');
/**
 * See https://fetch.spec.whatwg.org/#concept-method-normalize
 *
 * @param method HTTP method name
 * @returns Normalized method name
 */
function normalizeHTTPMethodName(method) {
    if (upperCaseMethodsRegEx.test(method)) {
        method = method.toUpperCase();
    }
    return method;
}
// Status code reason phrases from RFC 7231 ยง6.1, RFC 4918, RFC 5842, RFC 6585 and RFC 7538
const statusTexts = {
    100: 'Continue',
    101: 'Switching Protocols',
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    207: 'Multi-Status',
    208: 'Already Reported',
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Found',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    308: 'Permanent Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Payload Too Large',
    414: 'URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Range Not Satisfiable',
    417: 'Expectation Failed',
    422: 'Unprocessable Entity',
    423: 'Locked',
    424: 'Failed Dependency',
    426: 'Upgrade Required',
    428: 'Precondition Required',
    429: 'Too Many Requests',
    431: 'Request Header Fields Too Large',
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Timeout',
    505: 'HTTP Version Not Supported',
    507: 'Insufficient Storage',
    511: 'Network Authentication Required', // RFC 6585
};
/**
 * @param status HTTP status code
 * @returns Status text
 */
function getStatusText(status) {
    return statusTexts[status] ?? 'Unknown Status';
}

exports.getBodyByteSize = getBodyByteSize;
exports.getStatusText = getStatusText;
exports.isHeaderName = isHeaderName;
exports.isHeaderValue = isHeaderValue;
exports.isRequestHeaderForbidden = isRequestHeaderForbidden;
exports.isRequestMethod = isRequestMethod;
exports.isRequestMethodForbidden = isRequestMethodForbidden;
exports.normalizeHTTPMethodName = normalizeHTTPMethodName;
exports.upperCaseMethods = upperCaseMethods;
//# sourceMappingURL=Utils.cjs.map

declare namespace udl
{


	export class Utility {
	    static getUUID(): string;
	    static getCurrentDateTime(): any;
	    static getItemFromStore(name: string): any;
	    static setItemInStore(name: string, value: any): void;
	}

	export class User extends Base {
	    private segment;
	    private profile;
	    private productHolding;
	    private billing;
	    private pega;
	    constructor();
	    setSegment: (segment: Segment) => void;
	    getSegment: () => Segment;
	    setProfile: (profile: Profile) => void;
	    getProfile: () => Profile;
	    setProductHolding: (productHolding: ProductHolding) => void;
	    getProductHolding: () => ProductHolding;
	    setBilling: (billing: Billing) => void;
	    getBilling: () => Billing;
	    setPega: (pega: Pega) => void;
	    getPega: () => Pega;
	}
	export class UserBuilder {
	    private user;
	    withSegment(segment: Segment): UserBuilder;
	    withProfile(profile: Profile): UserBuilder;
	    withProductHolding(productHolding: ProductHolding): UserBuilder;
	    withDirectCallLabel(directCallLabel: DirectCallLabelEnum): UserBuilder;
	    withBilling(billing: Billing): UserBuilder;
	    withPega(pega: Pega): UserBuilder;
	    build(): User;
	}

	export class AnalyticsService {
	    private analyticsBeacons?;
	    static TIMEOUT_IF_SATELLITE_NOT_LOADED: number;
	    private analyticsPromises;
	    private loggingService;
	    private satelliteCallbacks;
	    constructor(analyticsBeacons?: AnalyticsBeaconEnum);
	    private createSatelliteLoadListener;
	    pushDataToAnalyticsWithoutWait(base: Base, doNotFirePageBeacon?: boolean): Promise<boolean>;
	    private pushDataToAnalyticsWithoutWaitInternal;
	    private onSatelliteLoaded;
	    private isSatelliteLoaded;
	    pushDataToAnalyticsWithWait(analyticsDataObj: Base): Promise<boolean>;
	    private parkAnalyticsObject;
	    getAnalyticsPromises(): any;
	    private getOrCreateDeferred;
	    getPageBeaconPromise(): Promise<boolean>;
	    private fireAnalyticsBeacon;
	    private resolvePromiseWithDelay;
	    resolvePromiseNow(promiseIdentifier: string): void;
	}

	export class Transaction extends Base {
	    private transactionID;
	    private price;
	    private item;
	    private existingItem;
	    constructor(transactionJson?: any);
	    setTransactionID: (transactionID: string) => void;
	    getTransactionID: () => string;
	    setPrice: (price: Price) => void;
	    getPrice: () => Price;
	    addItem: (item: Item) => void;
	    getItems: () => Item[];
	    setItems: (items: Item[]) => void;
	    addExistingItem: (item: Item) => void;
	    getExistingItems: () => Item[];
	    setExistingItems: (existingItem: Item[]) => void;
	}
	export class TransactionBuilder {
	    private transaction;
	    withTransactionID(transactionID: string): TransactionBuilder;
	    withPrice(price: Price): TransactionBuilder;
	    withItem(item: Item): TransactionBuilder;
	    withItems(items: Item[]): TransactionBuilder;
	    withExistingItem(item: Item): TransactionBuilder;
	    withExistingItems(items: Item[]): TransactionBuilder;
	    withAttribute(name: string, value: string | number | boolean): TransactionBuilder;
	    withAttributes(items: Item[]): TransactionBuilder;
	    withDirectCallLabel(directCallLabel: DirectCallLabelEnum): TransactionBuilder;
	    withStrategy(strategy: AnalyticsCallFireStrategyEnum): TransactionBuilder;
	    build(): Transaction;
	}

	export class Profile {
	    private loginstate;
	    private loginscope;
	    private impersonation;
	    private technicalID;
	    private postalcode;
	    private installationPostalCode;
	    private billingPostalCode;
	    private customerCategory;
	    private logintype;
	    private customerType;
	    setLoginState: (loginstate: string) => void;
	    getLoginState: () => string;
	    setLoginScope: (loginscope: string) => void;
	    getLoginScope: () => string;
	    setImpersonation: (impersonation: boolean) => void;
	    getImpersonation: () => boolean;
	    setTechnicalID: (technicalID: string) => void;
	    getTechnicalID: () => string;
	    setPostalCode: (postalcode: string) => void;
	    getPostalCode: () => string;
	    setInstallationPostalCode: (installationPostalCode: string) => void;
	    getInstallationPostalCode: () => string;
	    setBillingPostalCode: (billingPostalCode: string) => void;
	    getBillingPostalCode: () => string;
	    setCustomerCategory: (customerCategory: string) => void;
	    getCustomerCategory: () => string;
	    setLoginType: (logintype: string) => void;
	    getLoginType: () => string;
	    setCustomerType: (customerType: string) => void;
	    getCustomerType: () => string;
	}
	export class ProfileBuilder {
	    private profile;
	    withLoginState(loginstate: string): ProfileBuilder;
	    withLoginScope(loginscope: string): ProfileBuilder;
	    withImpersonation(impersonation: boolean): ProfileBuilder;
	    withTechnicalID(technicalID: string): ProfileBuilder;
	    withPostalCode(postalcode: string): ProfileBuilder;
	    withInstallationPostalCode(installationPostalCode: string): ProfileBuilder;
	    withBillingPostalCode(billingPostalCode: string): ProfileBuilder;
	    withCustomerCategory(customerCategory: string): ProfileBuilder;
	    withLoginType(logintype: string): ProfileBuilder;
	    withCustomerType(customerType: string): ProfileBuilder;
	    build(): Profile;
	}

	export class ProductHolding {
	    private productID;
	    private tvBoxType;
	    private services;
	    private loggedInUserProductCategory;
	    setProductID: (productID: string) => void;
	    getProductID: () => string;
	    setTvBoxType: (tvBoxType: string) => void;
	    getTvBoxType: () => string;
	    setServices: (services: string) => void;
	    getServices: () => string;
	    setLoggedInUserProductCategory: (loggedInUserProductCategory: string) => void;
	    getLoggedInUserProductCategory: () => string;
	}
	export class ProductHoldingBuilder {
	    private productHolding;
	    constructor();
	    withProductId(productId: string): ProductHoldingBuilder;
	    withTvBoxType(tvBoxType: string): ProductHoldingBuilder;
	    withServices(services: string): ProductHoldingBuilder;
	    withLoggedInUserProductCategory(loggedInUserProductCategory: string): ProductHoldingBuilder;
	    build(): ProductHolding;
	}

	export class Product {
	    private productID;
	    private productName;
	    private productType;
	    private productStatus;
	    private productStock;
	    constructor(productJson?: any);
	    setProductID: (id: string) => void;
	    getProductID: () => string;
	    setProductName: (name: string) => void;
	    getProductName: () => string;
	    setProductType: (type: string) => void;
	    getProductType: () => string;
	    setProductStatus: (productStatus: string) => void;
	    getProductStatus: () => string;
	    setProductStock: (productStock: string) => void;
	    getProductStock: () => string;
	}
	export class ProductBuilder {
	    private product;
	    constructor();
	    withProductId(id: string): ProductBuilder;
	    withProductName(name: string): ProductBuilder;
	    withProductType(type: string): ProductBuilder;
	    withProductStatus(status: string): ProductBuilder;
	    withProductStock(stock: string): ProductBuilder;
	    build(): Product;
	}

	export class Segment {
	    private customerSegment;
	    setCustomerSegment: (customerSegment: string) => void;
	    getCustomerSegment: () => string;
	}
	export class SegmentBuilder {
	    private segment;
	    withCustomerSegment(customerSegment: string): SegmentBuilder;
	    build(): Segment;
	}

	export class Price {
	    private onetime;
	    private recurring;
	    private summaryPrice;
	    private basePrice;
	    private total;
	    private discounted;
	    private discountRecurring;
	    constructor(priceJson?: any);
	    setOnetimePrice: (onetime: number) => void;
	    getOnetimePrice: () => number;
	    setRecurringPrice: (recurring: number) => void;
	    getRecurringPrice: () => number;
	    setBasePrice: (basePrice: Price) => void;
	    getBasePrice: () => Price;
	    setTotalPrice: (totalPrice: Price) => void;
	    getTotalPrice: () => Price;
	    setDiscountedPrice: (discountedPrice: Price) => void;
	    getDiscountedPrice: () => Price;
	    setTotalDiscountRecurring: (discountRecurring: Price) => void;
	    getTotalDiscountRecurring: () => Price;
	    setSummaryPrice: (summary: number) => void;
	    getSummaryPrice: () => number;
	}
	export class PriceBuilder {
	    private price;
	    constructor();
	    withOneTimePrice(oneTimePrice: number): PriceBuilder;
	    withRecurringPrice(recurringPrice: number): PriceBuilder;
	    withBasePrice(basePrice: Price): PriceBuilder;
	    withTotalPrice(totalPrice: Price): PriceBuilder;
	    withDiscountedPrice(discountedPrice: Price): PriceBuilder;
	    withTotalDiscountRecurring(discountRecurring: Price): PriceBuilder;
	    withSummaryPrice(summaryPrice: number): PriceBuilder;
	    build(): Price;
	}

	export class Item {
	    private productInfo;
	    private price;
	    private quantity;
	    constructor(itemJson?: any);
	    setProductInfo: (productInfo: Product) => void;
	    getProductInfo: () => Product;
	    setPrice: (price: Price) => void;
	    getPrice: () => Price;
	    setQuantity: (quantity: number) => void;
	    getQuantity: () => number;
	}
	export class ItemBuilder {
	    private item;
	    constructor();
	    withProductInfo(productInfo: Product): ItemBuilder;
	    withPrice(price: Price): ItemBuilder;
	    withQuantity(quantity: number): ItemBuilder;
	    build(): Item;
	}

	export class PageInfo {
	    private pageID;
	    private pageName;
	    private pageTitle;
	    private pageType;
	    private referringURL;
	    private destinationURL;
	    private sysEnv;
	    private language;
	    private effectiveDate;
	    private expiryDate;
	    private issueDate;
	    private previousPageName;
	    private stepId;
	    constructor(pageInfo?: any);
	    getPageID: () => string;
	    setPageID: (pageId: string) => void;
	    setPageName: (pageName: string) => void;
	    getPageName: () => string;
	    setPageTitle: (pageTitle: string) => void;
	    getPageTitle: () => string;
	    setPageType: (pageType: string) => void;
	    getPageType: () => string;
	    setReferringURL: (referringURL: string) => void;
	    getReferringURL: () => string;
	    setDestinationURL: (destinationURL: string) => void;
	    getDestinationURL: () => string;
	    setSysEnv: (sysEnv: string) => void;
	    getSysEnv: () => string;
	    setLanguage: (language: string) => void;
	    getLanguage: () => string;
	    setEffectiveDate: (date: string) => void;
	    getEffectiveDate: () => string;
	    setExpiryDate: (date: string) => void;
	    getExpiryDate: () => string;
	    setIssueDate: (date: string) => void;
	    getIssueDate: () => string;
	    setPreviousPageName: (previousPageName: string) => void;
	    getPreviousPageName: () => string;
	    setStepId: (stepId: string) => void;
	    getStepId: () => string;
	}
	export class PageInfoBuilder {
	    private pageInfo;
	    constructor(pageInfo: PageInfo);
	    withPageId(pageId: string): PageInfoBuilder;
	    withPageName(pageName: string): PageInfoBuilder;
	    withPageTitle(pageTitle: string): PageInfoBuilder;
	    withPageType(pageType: string): PageInfoBuilder;
	    withReferringURL(referringURL: string): PageInfoBuilder;
	    withDestionationURL(destinationURL: string): PageInfoBuilder;
	    withSysEnv(sysEnv: string): PageInfoBuilder;
	    withLanguage(language: string): PageInfoBuilder;
	    withEffectiveDate(date: string): PageInfoBuilder;
	    withExpiryDate(date: string): PageInfoBuilder;
	    withIssueDate(date: string): PageInfoBuilder;
	    withPreviousPageName(previousPageName: string): PageInfoBuilder;
	    withStepId(stepId: string): PageInfoBuilder;
	    build(): PageInfo;
	}

	export class DataLayer {
	    static instance: DataLayer;
	    private version;
	    private dateTimeLocal;
	    private environment;
	    private user;
	    private component;
	    private brand;
	    private applicationID;
	    private page;
	    private cart;
	    private transaction;
	    private event;
	    private analyticsService;
	    private doNotFirePageBeacon;
	    private constructor();
	    static create(): DataLayer;
	    static destroy(): void;
	    setVersion: (version: string) => void;
	    getVersion: () => string;
	    setDateTimeLocal: (dateTime: string) => void;
	    getDateTimeLocal: () => string;
	    setEnvironment: (env: string) => void;
	    getEnvironment: () => string;
	    setDoNotFirePageBeacon: (doNotFirePageBeacon: boolean) => void;
	    getDoNotFirePageBeacon: () => boolean;
	    getPage: () => Page;
	    setPage: (page: Page) => Promise<boolean>;
	    getComponents: () => Component[];
	    setComponents: (component: Component[]) => void;
	    getEvents: () => Event[];
	    getEventById: (id: string) => Event;
	    addUser: (user: User) => Promise<boolean>;
	    getUsers: () => User[];
	    getUserById: (id: string) => User;
	    getCart: () => Cart;
	    setCart: (cart: Cart) => Promise<boolean>;
	    getTransaction: () => Transaction;
	    setTransaction: (transaction: Transaction) => Promise<boolean>;
	    setBrand: (brand: string) => void;
	    getBrand: () => string;
	    setApplicationID: (appId: string) => void;
	    getApplicationID: () => string;
	    getCategory: (componentInstanceID: string) => Category;
	    getComponentById: (componentInstanceId: string) => Component;
	    addEvent: (event: Event) => Promise<boolean>;
	    private appendEvent;
	    addStepViewEvent: (event: Event) => Promise<boolean>;
	    getAnalyticsPromises: () => Promise<boolean>[];
	    reportParkedObjects: () => void;
	    private reportParkedObject;
	}

	export class EventInfo {
	    private eventName;
	    private eventStatus;
	    private eventStatusMessage;
	    private type;
	    private timeStamp;
	    constructor(eventInfoJson?: any);
	    setEventName: (eventName: string) => void;
	    getEventName: () => string;
	    setEventStatus: (eventStatus: string) => void;
	    getEventStatus: () => string;
	    setEventStatusMessage: (eventStatusMessage: string) => void;
	    getEventStatusMessage: () => string;
	    setType: (eventType: string) => void;
	    getType: () => string;
	    setTimestamp: (eventTimestamp: string) => void;
	    getTimestamp: () => string;
	}
	export class EventInfoBuilder {
	    private eventInfo;
	    constructor();
	    withEventName(name: string): EventInfoBuilder;
	    withType(type: string): EventInfoBuilder;
	    withEventStatus(status: string): EventInfoBuilder;
	    withEventStatusMessage(statusMessage: string): EventInfoBuilder;
	    withTimestamp(timestamp: string): EventInfoBuilder;
	    build(): EventInfo;
	}

	export class Page extends Base {
	    static PAGE_IDENTIFIER: string;
	    private pageInfo;
	    constructor(page?: any);
	    getPageInfo: () => PageInfo;
	}
	export class PageBuilder {
	    private page;
	    constructor(page: Page);
	    withAttribute(key: string, value: string | number | boolean): PageBuilder;
	    withDirectCallLabel(directCallLabel: DirectCallLabelEnum): PageBuilder;
	    build(): Page;
	}

	export class Event extends Base {
	    private eventInfo;
	    private category;
	    constructor(eventJson?: any);
	    setEventInfo: (eventInfo: EventInfo) => void;
	    getEventInfo: () => EventInfo;
	    setCategory: (category: Category) => void;
	    getCategory: () => Category;
	}
	export class EventBuilder {
	    private event;
	    constructor();
	    withEventInfo(eventInfo: EventInfo): EventBuilder;
	    withCategory(category: Category): EventBuilder;
	    withAttributes(attributes: any): EventBuilder;
	    withStrategy(strategy: AnalyticsCallFireStrategyEnum): EventBuilder;
	    build(): Event;
	}

	export class ComponentInfo {
	    private componentID;
	    private componentName;
	    private componentInstanceID;
	    constructor(componentInfo?: any);
	    getComponentID: () => string;
	    getComponentName: () => string;
	    getComponentInstanceID: () => string;
	}

	export class Pega {
	    private interactionId;
	    setInteractionId: (interactionId: string) => void;
	    getInteractionId: () => string;
	}
	export class PegaBuilder {
	    private pega;
	    constructor();
	    withInteractionId(interactionId: string): PegaBuilder;
	    build(): Pega;
	}

	export class Cart extends Base {
	    private cartID;
	    private price;
	    private item;
	    constructor(cartJson?: any);
	    setCartID: (id: string) => void;
	    getCartID: () => string;
	    setPrice: (price: Price) => void;
	    getPrice: () => Price;
	    addItem: (item: Item) => void;
	    getItems: () => Item[];
	    setItems: (items: any) => void;
	    filter: (productID: string) => "" | Item[];
	}
	export class CartBuilder {
	    private cart;
	    constructor();
	    withCartId(cartid: string): CartBuilder;
	    withPrice(price: Price): CartBuilder;
	    withItem(item: Item): CartBuilder;
	    withIdentifier(identifier: string): CartBuilder;
	    withAttribute(key: string, value: string | number | boolean): CartBuilder;
	    withDirectCallLabel(directCallLabel: DirectCallLabelEnum): CartBuilder;
	    build(): Cart;
	}

	export class Component {
	    private attributes;
	    private componentInfo;
	    private category;
	    constructor(component?: any);
	    getComponentInfo(): ComponentInfo;
	    getAttribute: (name: string) => any;
	    addAttribute: (name: any, value: any) => void;
	    getCategory: () => Category;
	}
	export class ComponentBuilder {
	    private component;
	    constructor(component?: Component);
	    withAttribute(key: string, value: any): ComponentBuilder;
	    build(): Component;
	}

	export class Category {
	    private primaryCategory;
	    private subCategory1;
	    constructor(category?: any);
	    setPrimaryCategory: (primaryCategory: string) => void;
	    getPrimaryCategory: () => string;
	    setSubCategory1: (subCategory1: string) => void;
	    getSubCategory1: () => string;
	}
	export class CategoryBuilder {
	    private category;
	    withPrimaryCategory(category: string): CategoryBuilder;
	    withSubCategoryOne(category: string): CategoryBuilder;
	    build(): Category;
	}

	export class Billing {
	    private billID;
	    setBillID: (billID: string) => void;
	    getBillID: () => string;
	}
	export class BillingBuilder {
	    private billing;
	    constructor();
	    withBillId(billID: string): BillingBuilder;
	    build(): Billing;
	}

	export class AttributeBuilder {
	    private attributes;
	    withAttribute(key: string, value: string): AttributeBuilder;
	    build(): any;
	}

	export class AnalyticsConstants {
	    static STORE_KEY_PARKED_EVENTS: string;
	}

	export enum DirectCallLabelEnum {
	    CART_VIEWED = "cart_viewed",
	    TRANSACTION_UPDATED = "transaction_updated",
	    EVENT_OCCURRED = "event_occurred",
	    EVENT_OCCURRED_STEP_VIEW = "event_occurred-step_view",
	    USER_DATA_LOADED = "user_data_loaded",
	    PAGE_LOADED = "page_loaded",
	    STORE_DATA_LOADED = "store_data_loaded"
	}

	export enum AnalyticsCallFireStrategyEnum {
	    FIRE_ON_SAME_PAGE = "FIRE_ON_SAME_PAGE",
	    FIRE_ON_NEXT_PAGE = "FIRE_ON_NEXT_PAGE",
	    FIRE_ON_PAGE_RELOAD = "FIRE_ON_PAGE_RELOAD"
	}

	export class Base {
	    private directCallLabel;
	    private identifier;
	    private attributes;
	    private forceResolvePromiseAfterDelay;
	    private strategy;
	    constructor(directCallLabel: DirectCallLabelEnum);
	    setIdentifier: (identifier: string) => void;
	    getIdentifier: () => string;
	    addAttribute: (name: string, value: string | number | boolean | Base) => void;
	    getAttribute: (name: string) => string;
	    setAttributes: (attributes: any) => void;
	    getAttributes: () => any;
	    setDirectCallLabel: (directCallLabel: DirectCallLabelEnum) => void;
	    getDirectCallLabel: () => DirectCallLabelEnum;
	    setForceResolvePromiseAfterDelay: (timeoutInMS: number) => void;
	    getForceResolvePromiseAfterDelay: () => number;
	    setStrategy: (strategy: AnalyticsCallFireStrategyEnum) => void;
	    getStrategy: () => AnalyticsCallFireStrategyEnum;
	}

	export enum AnalyticsBeaconEnum {
	    DISABLED = "disabled",
	    ENABLED = "enabled"
	}

	export class Deferred {
	    private _promise;
	    private _resolve;
	    private _reject;
	    constructor();
	    readonly promise: Promise<boolean>;
	    readonly resolve: any;
	    readonly reject: any;
	}

	export class LoggingService {
	    private perfLogEvents;
	    private isLoggingEnabled;
	    constructor();
	    log: (logEvent: any) => void;
	    startPerflog: (identifier: string) => void;
	    stopPerflog: (identifier: string) => void;
	    private getLoggingTime;
	}

}
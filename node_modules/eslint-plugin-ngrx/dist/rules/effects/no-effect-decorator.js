"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.noEffectDecoratorSuggest = exports.noEffectDecorator = void 0;
const path_1 = __importDefault(require("path"));
const rule_creator_1 = require("../../rule-creator");
const utils_1 = require("../../utils");
exports.noEffectDecorator = 'noEffectDecorator';
exports.noEffectDecoratorSuggest = 'noEffectDecoratorSuggest';
const createEffectKeyword = 'createEffect';
exports.default = (0, rule_creator_1.createRule)({
    name: path_1.default.parse(__filename).name,
    meta: {
        type: 'suggestion',
        hasSuggestions: true,
        ngrxModule: 'effects',
        docs: {
            description: `The \`${createEffectKeyword}\` is preferred as the \`@Effect\` decorator is deprecated.`,
            recommended: 'warn',
            suggestion: true,
        },
        fixable: 'code',
        schema: [],
        messages: {
            [exports.noEffectDecorator]: `The \`@Effect\` decorator is deprecated. Use \`${createEffectKeyword}\` instead.`,
            [exports.noEffectDecoratorSuggest]: `Remove the \`@Effect\` decorator.`,
        },
    },
    defaultOptions: [],
    create: (context) => {
        const sourceCode = context.getSourceCode();
        return {
            [utils_1.propertyDefinitionWithEffectDecorator](node) {
                const isUsingEffectCreator = (0, utils_1.isIdentifier)(node.parent.value.callee) &&
                    node.parent.value.callee.name === createEffectKeyword;
                if (isUsingEffectCreator) {
                    context.report({
                        node,
                        messageId: exports.noEffectDecorator,
                        suggest: [
                            {
                                messageId: exports.noEffectDecoratorSuggest,
                                fix: (fixer) => fixer.remove(node),
                            },
                        ],
                    });
                }
                else {
                    context.report({
                        node,
                        messageId: exports.noEffectDecorator,
                        fix: (fixer) => getFixes(node, sourceCode, fixer),
                    });
                }
            },
        };
    },
});
function getCreateEffectFix(fixer, propertyValueExpression) {
    return fixer.insertTextBefore(propertyValueExpression, `${createEffectKeyword}(() => { return `);
}
function getCreateEffectConfigFix(fixer, propertyValueExpression, configText) {
    const append = configText ? `, ${configText}` : '';
    return fixer.insertTextAfter(propertyValueExpression, `}${append})`);
}
function getFixes(node, sourceCode, fixer) {
    const classDeclaration = node.parent.parent.parent;
    const { parent: { value: propertyValueExpression }, } = node;
    const [decoratorArgument] = (0, utils_1.getDecoratorArguments)(node);
    const configText = decoratorArgument
        ? sourceCode.getText(decoratorArgument)
        : undefined;
    return [
        fixer.remove(node),
        getCreateEffectFix(fixer, propertyValueExpression),
        getCreateEffectConfigFix(fixer, propertyValueExpression, configText),
    ].concat((0, utils_1.getImportAddFix)({
        fixer,
        importName: createEffectKeyword,
        moduleName: utils_1.NGRX_MODULE_PATHS.effects,
        node: classDeclaration,
    }));
}

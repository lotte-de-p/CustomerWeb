"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asPattern = exports.escapeText = exports.getNgRxStores = exports.getNgRxComponentStores = exports.getNgRxEffectActions = exports.capitalize = exports.getRawText = exports.getDecorator = exports.getDecoratorName = exports.getDecoratorArguments = exports.getLast = exports.getImplementsSchemaFixer = exports.getInterface = exports.getInterfaces = exports.getInterfaceName = exports.getNodeToCommaRemoveFix = exports.getImportRemoveFix = exports.getImportAddFix = exports.getImportDeclarations = exports.getImportDeclarationSpecifier = exports.getNearestUpperNodeFrom = void 0;
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const guards_1 = require("./guards");
const ngrx_modules_1 = require("./ngrx-modules");
function getNearestUpperNodeFrom({ parent }, predicate) {
    while (parent && !(0, guards_1.isProgram)(parent)) {
        if (predicate(parent)) {
            return parent;
        }
        parent = parent.parent;
    }
    return undefined;
}
exports.getNearestUpperNodeFrom = getNearestUpperNodeFrom;
function getImportDeclarationSpecifier(importDeclarations, importName) {
    for (const importDeclaration of importDeclarations) {
        const importSpecifier = importDeclaration.specifiers.find((importClause) => {
            return ((0, guards_1.isImportSpecifier)(importClause) &&
                importClause.imported.name === importName);
        });
        if (importSpecifier) {
            return { importDeclaration, importSpecifier };
        }
    }
    return undefined;
}
exports.getImportDeclarationSpecifier = getImportDeclarationSpecifier;
function getImportDeclarations(node, moduleName) {
    let parentNode = node;
    while (parentNode && !(0, guards_1.isProgram)(parentNode)) {
        parentNode = parentNode.parent;
    }
    return parentNode === null || parentNode === void 0 ? void 0 : parentNode.body.filter((node) => {
        return (0, guards_1.isImportDeclaration)(node) && node.source.value === moduleName;
    });
}
exports.getImportDeclarations = getImportDeclarations;
function getCorrespondentImportClause(importDeclarations, compatibleWithTypeOnlyImport = false) {
    let importClause;
    for (const { importKind, specifiers } of importDeclarations) {
        const lastImportSpecifier = getLast(specifiers);
        if ((!compatibleWithTypeOnlyImport && importKind === 'type') ||
            (0, guards_1.isImportNamespaceSpecifier)(lastImportSpecifier)) {
            continue;
        }
        importClause = lastImportSpecifier;
    }
    return importClause;
}
function getImportAddFix({ compatibleWithTypeOnlyImport = false, fixer, importName, moduleName, node, }) {
    const fullImport = `import { ${importName} } from '${moduleName}';\n`;
    const importDeclarations = getImportDeclarations(node, moduleName);
    if (!(importDeclarations === null || importDeclarations === void 0 ? void 0 : importDeclarations.length)) {
        return fixer.insertTextAfterRange([0, 0], fullImport);
    }
    const importDeclarationSpecifier = getImportDeclarationSpecifier(importDeclarations, importName);
    if (importDeclarationSpecifier) {
        return [];
    }
    const importClause = getCorrespondentImportClause(importDeclarations, compatibleWithTypeOnlyImport);
    if (!importClause) {
        return fixer.insertTextAfterRange([0, 0], fullImport);
    }
    const replacementText = (0, guards_1.isImportDefaultSpecifier)(importClause)
        ? `, { ${importName} }`
        : `, ${importName}`;
    return fixer.insertTextAfter(importClause, replacementText);
}
exports.getImportAddFix = getImportAddFix;
function getImportRemoveFix(sourceCode, importDeclarations, importedName, fixer) {
    var _a;
    const { importDeclaration, importSpecifier } = (_a = getImportDeclarationSpecifier(importDeclarations, importedName)) !== null && _a !== void 0 ? _a : {};
    if (!importDeclaration || !importSpecifier) {
        return [];
    }
    const isFirstImportSpecifier = importDeclaration.specifiers[0] === importSpecifier;
    const isLastImportSpecifier = getLast(importDeclaration.specifiers) === importSpecifier;
    const isSingleImportSpecifier = isFirstImportSpecifier && isLastImportSpecifier;
    if (isSingleImportSpecifier) {
        return fixer.remove(importDeclaration);
    }
    const tokenAfterImportSpecifier = sourceCode.getTokenAfter(importSpecifier);
    if (isFirstImportSpecifier && tokenAfterImportSpecifier) {
        return fixer.removeRange([
            importSpecifier.range[0],
            tokenAfterImportSpecifier.range[1],
        ]);
    }
    const tokenBeforeImportSpecifier = sourceCode.getTokenBefore(importSpecifier);
    if (!tokenBeforeImportSpecifier) {
        return [];
    }
    return fixer.removeRange([
        tokenBeforeImportSpecifier.range[0],
        importSpecifier.range[1],
    ]);
}
exports.getImportRemoveFix = getImportRemoveFix;
function getNodeToCommaRemoveFix(sourceCode, fixer, node) {
    const nextToken = sourceCode.getTokenAfter(node);
    const isNextTokenComma = nextToken && experimental_utils_1.ASTUtils.isCommaToken(nextToken);
    return [
        fixer.remove(node),
        ...(isNextTokenComma ? [fixer.remove(nextToken)] : []),
    ];
}
exports.getNodeToCommaRemoveFix = getNodeToCommaRemoveFix;
function getInterfaceName(interfaceMember) {
    if ((0, guards_1.isIdentifier)(interfaceMember)) {
        return interfaceMember.name;
    }
    return (0, guards_1.isIdentifier)(interfaceMember.property)
        ? interfaceMember.property.name
        : undefined;
}
exports.getInterfaceName = getInterfaceName;
function getInterfaces({ implements: classImplements, }) {
    return (classImplements !== null && classImplements !== void 0 ? classImplements : [])
        .map(({ expression }) => expression)
        .filter(guards_1.isIdentifierOrMemberExpression);
}
exports.getInterfaces = getInterfaces;
function getInterface(node, interfaceName) {
    return getInterfaces(node).find((interfaceMember) => getInterfaceName(interfaceMember) === interfaceName);
}
exports.getInterface = getInterface;
function getImplementsSchemaFixer({ id, implements: classImplements }, interfaceName) {
    const [implementsNodeReplace, implementsTextReplace] = classImplements
        ? [getLast(classImplements), `, ${interfaceName}`]
        : [id, ` implements ${interfaceName}`];
    return { implementsNodeReplace, implementsTextReplace };
}
exports.getImplementsSchemaFixer = getImplementsSchemaFixer;
function getLast(items) {
    return items.slice(-1)[0];
}
exports.getLast = getLast;
function getDecoratorArguments({ expression }) {
    return (0, guards_1.isCallExpression)(expression) ? expression.arguments : [];
}
exports.getDecoratorArguments = getDecoratorArguments;
function getDecoratorName({ expression, }) {
    if ((0, guards_1.isIdentifier)(expression)) {
        return expression.name;
    }
    return (0, guards_1.isCallExpression)(expression) && (0, guards_1.isIdentifier)(expression.callee)
        ? expression.callee.name
        : undefined;
}
exports.getDecoratorName = getDecoratorName;
function getDecorator({ decorators, }, decoratorName) {
    return decorators === null || decorators === void 0 ? void 0 : decorators.find((decorator) => getDecoratorName(decorator) === decoratorName);
}
exports.getDecorator = getDecorator;
function getRawText(node) {
    if ((0, guards_1.isIdentifier)(node)) {
        return node.name;
    }
    if ((0, guards_1.isPropertyDefinition)(node) ||
        (0, guards_1.isMethodDefinition)(node) ||
        (0, guards_1.isProperty)(node)) {
        return getRawText(node.key);
    }
    if ((0, guards_1.isLiteral)(node)) {
        return node.raw;
    }
    if ((0, guards_1.isTemplateElement)(node)) {
        return `\`${node.value.raw}\``;
    }
    if ((0, guards_1.isTemplateLiteral)(node)) {
        return `\`${node.quasis[0].value.raw}\``;
    }
    return null;
}
exports.getRawText = getRawText;
function capitalize(text) {
    return `${text[0].toUpperCase()}${text.slice(1)}`;
}
exports.capitalize = capitalize;
function getInjectedParametersWithSourceCode(context, moduleName, importName) {
    var _a, _b, _c;
    const sourceCode = context.getSourceCode();
    const importDeclarations = (_a = getImportDeclarations(sourceCode.ast, moduleName)) !== null && _a !== void 0 ? _a : [];
    const { importSpecifier } = (_b = getImportDeclarationSpecifier(importDeclarations, importName)) !== null && _b !== void 0 ? _b : {};
    if (!importSpecifier) {
        return { sourceCode };
    }
    const variables = context.getDeclaredVariables(importSpecifier);
    const typedVariable = variables.find(({ name }) => name === importName);
    const identifiers = (_c = typedVariable === null || typedVariable === void 0 ? void 0 : typedVariable.references) === null || _c === void 0 ? void 0 : _c.reduce((identifiers, { identifier: { parent } }) => {
        if (parent &&
            (0, guards_1.isTSTypeReference)(parent) &&
            parent.parent &&
            (0, guards_1.isTSTypeAnnotation)(parent.parent) &&
            parent.parent.parent &&
            (0, guards_1.isIdentifier)(parent.parent.parent)) {
            return identifiers.concat(parent.parent.parent);
        }
        return identifiers;
    }, []);
    return { identifiers, sourceCode };
}
function getNgRxEffectActions(context) {
    return getInjectedParametersWithSourceCode(context, ngrx_modules_1.NGRX_MODULE_PATHS.effects, 'Actions');
}
exports.getNgRxEffectActions = getNgRxEffectActions;
function getNgRxComponentStores(context) {
    return getInjectedParametersWithSourceCode(context, ngrx_modules_1.NGRX_MODULE_PATHS['component-store'], 'ComponentStore');
}
exports.getNgRxComponentStores = getNgRxComponentStores;
function getNgRxStores(context) {
    return getInjectedParametersWithSourceCode(context, ngrx_modules_1.NGRX_MODULE_PATHS.store, 'Store');
}
exports.getNgRxStores = getNgRxStores;
function escapeText(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
exports.escapeText = escapeText;
function asPattern(identifiers) {
    const escapedNames = identifiers.map(({ name }) => escapeText(name));
    return new RegExp(`^(${escapedNames.join('|')})$`);
}
exports.asPattern = asPattern;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapLikeOperatorsImplicitReturn = exports.mapLikeOperatorsExplicitReturn = exports.actionReducerMap = exports.storeActionReducerMap = exports.onFunctionWithoutType = exports.createReducer = exports.dispatchInEffects = exports.dispatchExpression = exports.selectExpression = exports.pipeableSelect = exports.pipeExpression = exports.namedCallableExpression = exports.namedExpression = exports.effectsInNgModuleProviders = exports.effectsInNgModuleImports = exports.ngModuleProviders = exports.ngModuleImports = exports.ngModuleDecorator = exports.metadataProperty = exports.constructorDefinition = exports.actionCreatorPropsComputed = exports.actionCreatorProps = exports.actionCreatorWithLiteral = exports.actionCreator = exports.propertyDefinitionWithEffectDecorator = exports.effectDecorator = exports.createEffectExpression = exports.effectCreator = void 0;
exports.effectCreator = `PropertyDefinition[value.callee.name='createEffect']`;
exports.createEffectExpression = `CallExpression[callee.name='createEffect']`;
exports.effectDecorator = `Decorator[expression.callee.name='Effect']`;
exports.propertyDefinitionWithEffectDecorator = `ClassDeclaration > ClassBody > PropertyDefinition > ${exports.effectDecorator}`;
exports.actionCreator = `CallExpression[callee.name='createAction']`;
exports.actionCreatorWithLiteral = `${exports.actionCreator}[arguments.0.type='Literal'][arguments.0.raw=/^'/]`;
exports.actionCreatorProps = `${exports.actionCreator} > CallExpression[callee.name='props']`;
exports.actionCreatorPropsComputed = `${exports.actionCreatorProps} > TSTypeParameterInstantiation > :matches(TSTypeReference[typeName.name!='Readonly'], [type=/^TS(.*)(Keyword|Type)$/])`;
exports.constructorDefinition = `MethodDefinition[kind='constructor']`;
function metadataProperty(key) {
    return `Property:matches([key.name=${key}][computed=false], [key.value=${key}], [key.quasis.0.value.raw=${key}])`;
}
exports.metadataProperty = metadataProperty;
exports.ngModuleDecorator = `ClassDeclaration > Decorator > CallExpression[callee.name='NgModule']`;
exports.ngModuleImports = `${exports.ngModuleDecorator} ObjectExpression ${metadataProperty('imports')} > ArrayExpression`;
exports.ngModuleProviders = `${exports.ngModuleDecorator} ObjectExpression ${metadataProperty('providers')} > ArrayExpression`;
exports.effectsInNgModuleImports = `${exports.ngModuleImports} CallExpression[callee.object.name='EffectsModule'][callee.property.name=/^for(Root|Feature)$/] ArrayExpression > Identifier`;
exports.effectsInNgModuleProviders = `${exports.ngModuleProviders} Identifier`;
const namedExpression = (name) => `:matches(${exports.constructorDefinition} CallExpression[callee.object.name=${name}], CallExpression[callee.object.object.type='ThisExpression'][callee.object.property.name=${name}])`;
exports.namedExpression = namedExpression;
const namedCallableExpression = (name) => `:matches(${(0, exports.namedExpression)(name)}, ${exports.constructorDefinition} CallExpression[callee.object.callee.object.name=${name}], CallExpression[callee.object.callee.object.object.type='ThisExpression'][callee.object.callee.object.property.name=${name}])`;
exports.namedCallableExpression = namedCallableExpression;
const pipeExpression = (name) => `${(0, exports.namedExpression)(name)}[callee.property.name='pipe']`;
exports.pipeExpression = pipeExpression;
const pipeableSelect = (name) => `${(0, exports.pipeExpression)(name)} CallExpression[callee.name='select']`;
exports.pipeableSelect = pipeableSelect;
const selectExpression = (name) => `${(0, exports.namedExpression)(name)}[callee.property.name='select']`;
exports.selectExpression = selectExpression;
const dispatchExpression = (name) => `${(0, exports.namedExpression)(name)}[callee.property.name='dispatch']`;
exports.dispatchExpression = dispatchExpression;
const dispatchInEffects = (name) => `${exports.createEffectExpression} ${(0, exports.dispatchExpression)(name)} > MemberExpression:has(Identifier[name=${name}])`;
exports.dispatchInEffects = dispatchInEffects;
exports.createReducer = `CallExpression[callee.name='createReducer']`;
exports.onFunctionWithoutType = `${exports.createReducer} CallExpression[callee.name='on'] > ArrowFunctionExpression:not([returnType.typeAnnotation], :has(CallExpression))`;
exports.storeActionReducerMap = `${exports.ngModuleImports} CallExpression[callee.object.name='StoreModule'][callee.property.name=/^for(Root|Feature)$/] > ObjectExpression:first-child`;
exports.actionReducerMap = `VariableDeclarator[id.typeAnnotation.typeAnnotation.typeName.name='ActionReducerMap'] > ObjectExpression`;
const mapLikeOperators = '/^(concat|exhaust|flat|merge|switch)Map$/';
const mapLikeToOperators = '/^(concat|merge|switch)MapTo$/';
exports.mapLikeOperatorsExplicitReturn = `CallExpression[callee.name=${mapLikeOperators}] ReturnStatement`;
exports.mapLikeOperatorsImplicitReturn = `:matches(CallExpression[callee.name=${mapLikeToOperators}], CallExpression[callee.name=${mapLikeOperators}] > ArrowFunctionExpression)`;

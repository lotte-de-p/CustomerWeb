"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRemoteCacheRetrieve = void 0;
const promises_1 = require("fs/promises");
const path_1 = require("path");
const stream_1 = require("stream");
const promises_2 = require("stream/promises");
const tar_1 = require("tar");
const create_filter_source_file_1 = require("./create-filter-source-file");
const get_file_name_from_hash_1 = require("./get-file-name-from-hash");
const COMMIT_FILE_EXTENSION = ".commit";
const COMMIT_FILE_CONTENT = "true";
const extractFolder = async (stream, destination, hash) => {
    await (0, promises_1.mkdir)(destination, { recursive: true });
    return await (0, promises_2.pipeline)(stream_1.Readable.from(stream), (0, tar_1.extract)({
        C: destination,
        strip: 1,
        filter: (0, create_filter_source_file_1.createFilterSourceFile)(hash),
    }));
};
const writeCommitFile = (destination) => {
    const commitFilePath = destination + COMMIT_FILE_EXTENSION;
    return (0, promises_1.writeFile)(commitFilePath, COMMIT_FILE_CONTENT);
};
const createRemoteCacheRetrieve = (safeImplementation) => async (hash, cacheDirectory) => {
    const implementation = await safeImplementation;
    if (!implementation) {
        return false;
    }
    const file = (0, get_file_name_from_hash_1.getFileNameFromHash)(hash);
    const { fileExists, retrieveFile } = implementation;
    const isFileCached = await fileExists(file);
    if (!isFileCached) {
        return false;
    }
    const stream = await retrieveFile(file);
    const destination = (0, path_1.join)(cacheDirectory, hash);
    if (!stream) {
        return false;
    }
    await extractFolder(stream, destination, hash);
    await writeCommitFile(destination);
    return true;
};
exports.createRemoteCacheRetrieve = createRemoteCacheRetrieve;

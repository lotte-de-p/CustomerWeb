"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renameAndMoveOldTsConfig = exports.findMetroConfig = exports.findNextConfig = exports.findViteConfig = exports.getE2EProjectName = exports.rootFileIsTs = exports.workspaceHasRootProject = exports.projectIsRootProjectInStandaloneWorkspace = exports.addBuildStorybookToCacheableOperations = exports.getTsConfigPath = exports.createProjectStorybookDir = exports.addStorybookToTargetDefaults = exports.addStorybookToNamedInputs = exports.normalizeSchema = exports.updateLintConfig = exports.configureTsSolutionConfig = exports.configureTsProjectConfig = exports.editTsconfigBaseJson = exports.createStorybookTsconfigFile = exports.addStaticTarget = exports.addAngularStorybookTarget = exports.addStorybookTarget = void 0;
const devkit_1 = require("@nx/devkit");
const executor_options_utils_1 = require("@nx/devkit/src/generators/executor-options-utils");
const eslint_1 = require("@nx/eslint");
const path_1 = require("path");
const utilities_1 = require("../../../utils/utilities");
const versions_1 = require("../../../utils/versions");
const eslint_file_1 = require("@nx/eslint/src/generators/utils/eslint-file");
const flat_config_1 = require("@nx/eslint/src/utils/flat-config");
const DEFAULT_PORT = 4400;
function addStorybookTarget(tree, projectName, uiFramework, interactionTests) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    projectConfig.targets['storybook'] = {
        executor: '@nx/storybook:storybook',
        options: {
            port: DEFAULT_PORT,
            configDir: `${projectConfig.root}/.storybook`,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@nx/storybook:build',
        outputs: ['{options.outputDir}'],
        options: {
            outputDir: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            configDir: `${projectConfig.root}/.storybook`,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (interactionTests === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addStorybookTarget = addStorybookTarget;
function addAngularStorybookTarget(tree, projectName, interactionTests) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const { ngBuildTarget } = (0, utilities_1.findStorybookAndBuildTargetsAndCompiler)(projectConfig.targets);
    projectConfig.targets['storybook'] = {
        executor: '@storybook/angular:start-storybook',
        options: {
            port: 4400,
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    projectConfig.targets['build-storybook'] = {
        executor: '@storybook/angular:build-storybook',
        outputs: ['{options.outputDir}'],
        options: {
            outputDir: (0, devkit_1.joinPathFragments)('dist/storybook', projectName),
            configDir: `${projectConfig.root}/.storybook`,
            browserTarget: `${projectName}:${ngBuildTarget ? 'build' : 'build-storybook'}`,
            compodoc: false,
        },
        configurations: {
            ci: {
                quiet: true,
            },
        },
    };
    if (interactionTests === true) {
        projectConfig.targets['test-storybook'] = {
            executor: 'nx:run-commands',
            options: {
                command: `test-storybook -c ${projectConfig.root}/.storybook --url=http://localhost:${DEFAULT_PORT}`,
            },
        };
    }
    (0, devkit_1.updateProjectConfiguration)(tree, projectName, projectConfig);
}
exports.addAngularStorybookTarget = addAngularStorybookTarget;
function addStaticTarget(tree, opts) {
    const nrwlWeb = (0, devkit_1.ensurePackage)('@nx/web', versions_1.nxVersion);
    nrwlWeb.webStaticServeGenerator(tree, {
        buildTarget: `${opts.project}:build-storybook`,
        outputPath: (0, devkit_1.joinPathFragments)('dist/storybook', opts.project),
        targetName: 'static-storybook',
    });
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, opts.project);
    projectConfig.targets['static-storybook'].configurations = {
        ci: {
            buildTarget: `${opts.project}:build-storybook:ci`,
        },
    };
    (0, devkit_1.updateProjectConfiguration)(tree, opts.project, projectConfig);
}
exports.addStaticTarget = addStaticTarget;
function createStorybookTsconfigFile(tree, projectRoot, uiFramework, isRootProject, mainDir) {
    // First let's check if old configuration file exists
    // If it exists, let's rename it and move it to the new location
    const oldStorybookTsConfigPath = (0, devkit_1.joinPathFragments)(projectRoot, '.storybook/tsconfig.json');
    if (tree.exists(oldStorybookTsConfigPath)) {
        devkit_1.logger.warn(`.storybook/tsconfig.json already exists for this project`);
        devkit_1.logger.warn(`It will be renamed and moved to tsconfig.storybook.json.
      Please make sure all settings look correct after this change.
      Also, please make sure to use "nx migrate" to move from one version of Nx to another.
      `);
        renameAndMoveOldTsConfig(projectRoot, oldStorybookTsConfigPath, tree);
        return;
    }
    const storybookTsConfigPath = (0, devkit_1.joinPathFragments)(projectRoot, 'tsconfig.storybook.json');
    if (tree.exists(storybookTsConfigPath)) {
        devkit_1.logger.info(`tsconfig.storybook.json already exists for this project`);
        return;
    }
    const exclude = [`${mainDir}/**/*.spec.ts`, `${mainDir}/**/*.test.ts`];
    if (uiFramework === '@storybook/react-webpack5' ||
        uiFramework === '@storybook/react-vite') {
        exclude.push(`${mainDir}/**/*.spec.js`, `${mainDir}/**/*.test.js`, `${mainDir}/**/*.spec.tsx`, `${mainDir}/**/*.test.tsx`, `${mainDir}/**/*.spec.jsx`, `${mainDir}/**/*.test.js`);
    }
    let files;
    if (uiFramework === '@storybook/react-webpack5' ||
        uiFramework === '@storybook/react-vite') {
        const offset = (0, devkit_1.offsetFromRoot)(projectRoot);
        files = [
            `${!isRootProject ? offset : ''}node_modules/@nx/react/typings/styled-jsx.d.ts`,
            `${!isRootProject ? offset : ''}node_modules/@nx/react/typings/cssmodule.d.ts`,
            `${!isRootProject ? offset : ''}node_modules/@nx/react/typings/image.d.ts`,
        ];
    }
    const include = [
        `${mainDir}/**/*.stories.ts`,
        `${mainDir}/**/*.stories.js`,
        `${mainDir}/**/*.stories.jsx`,
        `${mainDir}/**/*.stories.tsx`,
        `${mainDir}/**/*.stories.mdx`,
        '.storybook/*.js',
        '.storybook/*.ts',
    ];
    const storybookTsConfig = {
        extends: './tsconfig.json',
        compilerOptions: {
            emitDecoratorMetadata: true,
            outDir: uiFramework === '@storybook/react-webpack5' ||
                uiFramework === '@storybook/react-vite'
                ? ''
                : undefined,
        },
        files,
        exclude,
        include,
    };
    (0, devkit_1.writeJson)(tree, storybookTsConfigPath, storybookTsConfig);
}
exports.createStorybookTsconfigFile = createStorybookTsconfigFile;
function editTsconfigBaseJson(tree) {
    let tsconfigBasePath = 'tsconfig.base.json';
    // standalone workspace maybe
    if (!tree.exists(tsconfigBasePath))
        tsconfigBasePath = 'tsconfig.json';
    if (!tree.exists(tsconfigBasePath))
        return;
    const tsconfigBaseContent = (0, devkit_1.readJson)(tree, tsconfigBasePath);
    if (!tsconfigBaseContent.compilerOptions)
        tsconfigBaseContent.compilerOptions = {};
    tsconfigBaseContent.compilerOptions.skipLibCheck = true;
    (0, devkit_1.writeJson)(tree, tsconfigBasePath, tsconfigBaseContent);
}
exports.editTsconfigBaseJson = editTsconfigBaseJson;
function configureTsProjectConfig(tree, schema) {
    const { project: projectName } = schema;
    let tsConfigPath;
    let tsConfigContent;
    try {
        tsConfigPath = getTsConfigPath(tree, projectName);
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    catch {
        /**
         * Custom app configurations
         * may contain a tsconfig.json
         * instead of a tsconfig.app.json.
         */
        tsConfigPath = getTsConfigPath(tree, projectName, 'tsconfig.json');
        tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    }
    if (!tsConfigContent?.exclude?.includes('**/*.stories.ts') &&
        !tsConfigContent?.exclude?.includes('**/*.stories.js')) {
        tsConfigContent.exclude = [
            ...(tsConfigContent.exclude || []),
            '**/*.stories.ts',
            '**/*.stories.js',
            ...(schema.uiFramework?.startsWith('@storybook/react')
                ? ['**/*.stories.jsx', '**/*.stories.tsx']
                : []),
        ];
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsProjectConfig = configureTsProjectConfig;
function configureTsSolutionConfig(tree, schema) {
    const { project: projectName } = schema;
    const { root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const tsConfigPath = (0, path_1.join)(root, 'tsconfig.json');
    const tsConfigContent = (0, devkit_1.readJson)(tree, tsConfigPath);
    if (schema.uiFramework === '@storybook/angular') {
        if (!tsConfigContent.references
            ?.map((reference) => reference.path)
            ?.includes('./.storybook/tsconfig.json')) {
            tsConfigContent.references = [
                ...(tsConfigContent.references || []),
                {
                    path: './.storybook/tsconfig.json',
                },
            ];
        }
    }
    else {
        if (!tsConfigContent.references
            ?.map((reference) => reference.path)
            ?.includes('./tsconfig.storybook.json')) {
            tsConfigContent.references = [
                ...(tsConfigContent.references || []),
                {
                    path: './tsconfig.storybook.json',
                },
            ];
        }
    }
    (0, devkit_1.writeJson)(tree, tsConfigPath, tsConfigContent);
}
exports.configureTsSolutionConfig = configureTsSolutionConfig;
/**
 * When adding storybook we need to inform ESLint
 * of the additional tsconfig.json file which will be the only tsconfig
 * which includes *.stories files.
 *
 * This is done within the eslint config file.
 */
function updateLintConfig(tree, schema) {
    const { project: projectName } = schema;
    const { root } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    const eslintFile = (0, eslint_file_1.findEslintFile)(tree, root);
    if (!eslintFile) {
        return;
    }
    const parserConfigPath = (0, path_1.join)(root, schema.uiFramework === '@storybook/angular'
        ? '.storybook/tsconfig.json'
        : 'tsconfig.storybook.json');
    if ((0, flat_config_1.useFlatConfig)(tree)) {
        let config = tree.read(eslintFile, 'utf-8');
        const projectRegex = RegExp(/project:\s?\[?['"](.*)['"]\]?/g);
        let match;
        while ((match = projectRegex.exec(config)) !== null) {
            const matchSet = new Set(match[1].split(',').map((p) => p.trim().replace(/['"]/g, '')));
            matchSet.add(parserConfigPath);
            const insert = `project: [${Array.from(matchSet)
                .map((p) => `'${p}'`)
                .join(', ')}]`;
            config =
                config.slice(0, match.index) +
                    insert +
                    config.slice(match.index + match[0].length);
        }
        tree.write(eslintFile, config);
    }
    else {
        (0, devkit_1.updateJson)(tree, (0, path_1.join)(root, eslintFile), (json) => {
            if (typeof json.parserOptions?.project === 'string') {
                json.parserOptions.project = [json.parserOptions.project];
            }
            if (json.parserOptions?.project) {
                json.parserOptions.project = (0, utilities_1.dedupe)([
                    ...json.parserOptions.project,
                    parserConfigPath,
                ]);
            }
            const overrides = json.overrides || [];
            for (const o of overrides) {
                if (typeof o.parserOptions?.project === 'string') {
                    o.parserOptions.project = [o.parserOptions.project];
                }
                if (o.parserOptions?.project) {
                    o.parserOptions.project = (0, utilities_1.dedupe)([
                        ...o.parserOptions.project,
                        parserConfigPath,
                    ]);
                }
            }
            return json;
        });
    }
}
exports.updateLintConfig = updateLintConfig;
function normalizeSchema(schema) {
    const defaults = {
        configureCypress: true,
        linter: eslint_1.Linter.EsLint,
        js: false,
    };
    return {
        ...defaults,
        ...schema,
    };
}
exports.normalizeSchema = normalizeSchema;
function addStorybookToNamedInputs(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    if (nxJson.namedInputs) {
        const hasProductionFileset = !!nxJson.namedInputs?.production;
        if (hasProductionFileset) {
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/**/*.stories.@(js|jsx|ts|tsx|mdx)')) {
                nxJson.namedInputs.production.push('!{projectRoot}/**/*.stories.@(js|jsx|ts|tsx|mdx)');
            }
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/.storybook/**/*')) {
                nxJson.namedInputs.production.push('!{projectRoot}/.storybook/**/*');
            }
            if (!nxJson.namedInputs.production.includes('!{projectRoot}/tsconfig.storybook.json')) {
                nxJson.namedInputs.production.push('!{projectRoot}/tsconfig.storybook.json');
            }
        }
        (0, devkit_1.updateNxJson)(tree, nxJson);
    }
}
exports.addStorybookToNamedInputs = addStorybookToNamedInputs;
function addStorybookToTargetDefaults(tree) {
    const nxJson = (0, devkit_1.readNxJson)(tree);
    nxJson.targetDefaults ??= {};
    nxJson.targetDefaults['build-storybook'] ??= {};
    nxJson.targetDefaults['build-storybook'].inputs ??= [
        'default',
        nxJson.namedInputs && 'production' in nxJson.namedInputs
            ? '^production'
            : '^default',
    ];
    if (!nxJson.targetDefaults['build-storybook'].inputs.includes('{projectRoot}/.storybook/**/*')) {
        nxJson.targetDefaults['build-storybook'].inputs.push('{projectRoot}/.storybook/**/*');
    }
    // Delete the !{projectRoot}/.storybook/**/* glob from build-storybook
    // because we want to rebuild Storybook if the .storybook folder changes
    const index = nxJson.targetDefaults['build-storybook'].inputs.indexOf('!{projectRoot}/.storybook/**/*');
    if (index !== -1) {
        nxJson.targetDefaults['build-storybook'].inputs.splice(index, 1);
    }
    if (!nxJson.targetDefaults['build-storybook'].inputs.includes('{projectRoot}/tsconfig.storybook.json')) {
        nxJson.targetDefaults['build-storybook'].inputs.push('{projectRoot}/tsconfig.storybook.json');
    }
    (0, devkit_1.updateNxJson)(tree, nxJson);
}
exports.addStorybookToTargetDefaults = addStorybookToTargetDefaults;
function createProjectStorybookDir(tree, projectName, uiFramework, js, tsConfiguration, root, projectType, projectIsRootProjectInStandaloneWorkspace, interactionTests, mainDir, isNextJs, usesSwc, usesVite, viteConfigFilePath, hasPlugin, viteConfigFileName, useReactNative) {
    let projectDirectory = projectType === 'application'
        ? isNextJs
            ? 'components'
            : 'src/app'
        : 'src/lib';
    if (uiFramework === '@storybook/vue3-vite') {
        projectDirectory = 'src';
    }
    const storybookConfigExists = projectIsRootProjectInStandaloneWorkspace
        ? tree.exists('.storybook/main.js') || tree.exists('.storybook/main.ts')
        : tree.exists((0, path_1.join)(root, '.storybook/main.ts')) ||
            tree.exists((0, path_1.join)(root, '.storybook/main.js'));
    if (storybookConfigExists) {
        devkit_1.logger.warn(`Storybook configuration files already exist for ${projectName}!`);
        return;
    }
    const templatePath = (0, path_1.join)(__dirname, `../project-files${tsConfiguration ? '-ts' : ''}`);
    (0, devkit_1.generateFiles)(tree, templatePath, root, {
        tmpl: '',
        uiFramework,
        offsetFromRoot: (0, devkit_1.offsetFromRoot)(root),
        projectDirectory,
        projectType,
        interactionTests,
        mainDir,
        isNextJs: isNextJs && projectType === 'application',
        usesSwc,
        usesVite,
        isRootProject: projectIsRootProjectInStandaloneWorkspace,
        viteConfigFilePath,
        hasPlugin,
        viteConfigFileName,
        useReactNative,
    });
    if (js) {
        (0, devkit_1.toJS)(tree);
    }
    if (uiFramework !== '@storybook/angular') {
        // This file is only used for Angular
        // For non-Angular projects, we generate a file
        // called tsconfig.storybook.json at the root of the project
        // using the createStorybookTsconfigFile function
        // since Storybook is only taking into account .storybook/tsconfig.json
        // for Angular projects
        tree.delete((0, path_1.join)(root, '.storybook/tsconfig.json'));
    }
}
exports.createProjectStorybookDir = createProjectStorybookDir;
function getTsConfigPath(tree, projectName, path) {
    const { root, projectType } = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    return (0, path_1.join)(root, path?.length > 0
        ? path
        : projectType === 'application'
            ? 'tsconfig.app.json'
            : 'tsconfig.lib.json');
}
exports.getTsConfigPath = getTsConfigPath;
function addBuildStorybookToCacheableOperations(tree) {
    (0, devkit_1.updateJson)(tree, 'nx.json', (json) => ({
        ...json,
        tasksRunnerOptions: {
            ...(json.tasksRunnerOptions ?? {}),
            default: {
                ...(json.tasksRunnerOptions?.default ?? {}),
                options: {
                    ...(json.tasksRunnerOptions?.default?.options ?? {}),
                    cacheableOperations: Array.from(new Set([
                        ...(json.tasksRunnerOptions?.default?.options
                            ?.cacheableOperations ?? []),
                        'build-storybook',
                    ])),
                },
            },
        },
    }));
}
exports.addBuildStorybookToCacheableOperations = addBuildStorybookToCacheableOperations;
function projectIsRootProjectInStandaloneWorkspace(projectRoot) {
    return (0, path_1.relative)(devkit_1.workspaceRoot, projectRoot)?.length === 0;
}
exports.projectIsRootProjectInStandaloneWorkspace = projectIsRootProjectInStandaloneWorkspace;
function workspaceHasRootProject(tree) {
    return tree.exists('project.json');
}
exports.workspaceHasRootProject = workspaceHasRootProject;
function rootFileIsTs(tree, rootFileName, tsConfiguration) {
    if (tree.exists(`.storybook/${rootFileName}.ts`) && !tsConfiguration) {
        devkit_1.logger.info(`The root Storybook configuration is in TypeScript,
      so Nx will generate TypeScript Storybook configuration files
      in this project's .storybook folder as well.`);
        return true;
    }
    else if (tree.exists(`.storybook/${rootFileName}.js`) && tsConfiguration) {
        devkit_1.logger.info(`The root Storybook configuration is in JavaScript,
        so Nx will generate JavaScript Storybook configuration files
        in this project's .storybook folder as well.`);
        return false;
    }
    else {
        return tsConfiguration;
    }
}
exports.rootFileIsTs = rootFileIsTs;
async function getE2EProjectName(tree, mainProject) {
    let e2eProject;
    const graph = await (0, devkit_1.createProjectGraphAsync)();
    (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nx/cypress:cypress', (options, projectName) => {
        if (e2eProject) {
            return;
        }
        if (options['devServerTarget']) {
            const { project, target } = (0, devkit_1.parseTargetString)(options['devServerTarget'], graph);
            if ((project === mainProject && target === 'serve') ||
                (project === mainProject && target === 'storybook')) {
                e2eProject = projectName;
            }
        }
    });
    return e2eProject;
}
exports.getE2EProjectName = getE2EProjectName;
function findViteConfig(tree, projectRoot) {
    const allowsExt = ['js', 'mjs', 'ts', 'cjs', 'mts', 'cts'];
    for (const ext of allowsExt) {
        const viteConfigPath = (0, devkit_1.joinPathFragments)(projectRoot, `vite.config.${ext}`);
        if (tree.exists(viteConfigPath)) {
            return {
                fullConfigPath: viteConfigPath,
                viteConfigFileName: `vite.config.${ext}`,
            };
        }
    }
}
exports.findViteConfig = findViteConfig;
function findNextConfig(tree, projectRoot) {
    const allowsExt = ['js', 'mjs', 'cjs'];
    for (const ext of allowsExt) {
        const nextConfigPath = (0, devkit_1.joinPathFragments)(projectRoot, `next.config.${ext}`);
        if (tree.exists(nextConfigPath)) {
            return nextConfigPath;
        }
    }
}
exports.findNextConfig = findNextConfig;
function findMetroConfig(tree, projectRoot) {
    const nextConfigPath = (0, devkit_1.joinPathFragments)(projectRoot, `metro.config.js`);
    if (tree.exists(nextConfigPath)) {
        return nextConfigPath;
    }
}
exports.findMetroConfig = findMetroConfig;
function renameAndMoveOldTsConfig(projectRoot, pathToStorybookConfigFile, tree) {
    if (pathToStorybookConfigFile && tree.exists(pathToStorybookConfigFile)) {
        (0, devkit_1.updateJson)(tree, pathToStorybookConfigFile, (json) => {
            if (json.extends?.startsWith('../')) {
                // drop one level of nesting
                json.extends = json.extends.replace('../', './');
            }
            for (let i = 0; i < json.files?.length; i++) {
                // drop one level of nesting
                if (json.files[i].startsWith('../../../')) {
                    json.files[i] = json.files[i].replace('../../../', '../../');
                }
            }
            for (let i = 0; i < json.include?.length; i++) {
                if (json.include[i].startsWith('../')) {
                    json.include[i] = json.include[i].replace('../', '');
                }
                if (json.include[i] === '*.js') {
                    json.include[i] = '.storybook/*.js';
                }
                if (json.include[i] === '*.ts') {
                    json.include[i] = '.storybook/*.ts';
                }
            }
            for (let i = 0; i < json.exclude?.length; i++) {
                if (json.exclude[i].startsWith('../')) {
                    json.exclude[i] = json.exclude[i].replace('../', 'src/');
                }
            }
            return json;
        });
        tree.rename(pathToStorybookConfigFile, (0, devkit_1.joinPathFragments)(projectRoot, `tsconfig.storybook.json`));
    }
    const projectTsConfig = (0, devkit_1.joinPathFragments)(projectRoot, 'tsconfig.json');
    if (tree.exists(projectTsConfig)) {
        (0, devkit_1.updateJson)(tree, projectTsConfig, (json) => {
            for (let i = 0; i < json.references?.length; i++) {
                if (json.references[i].path === './.storybook/tsconfig.json') {
                    json.references[i].path = './tsconfig.storybook.json';
                    break;
                }
            }
            return json;
        });
    }
    const eslintFile = (0, eslint_file_1.findEslintFile)(tree, projectRoot);
    if (eslintFile) {
        const fileName = (0, devkit_1.joinPathFragments)(projectRoot, eslintFile);
        const config = tree.read(fileName, 'utf-8');
        tree.write(fileName, config.replace(/\.storybook\/tsconfig\.json/g, 'tsconfig.storybook.json'));
    }
}
exports.renameAndMoveOldTsConfig = renameAndMoveOldTsConfig;

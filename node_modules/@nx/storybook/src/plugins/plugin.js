"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createDependencies = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const fs_1 = require("fs");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const js_1 = require("@nx/js");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const cachePath = (0, path_1.join)(cache_directory_1.projectGraphCacheDirectory, 'storybook.hash');
const targetsCache = (0, fs_1.existsSync)(cachePath) ? readTargetsCache() : {};
const calculatedTargets = {};
function readTargetsCache() {
    return (0, devkit_1.readJsonFile)(cachePath);
}
function writeTargetsToCache(targets) {
    (0, devkit_1.writeJsonFile)(cachePath, targets);
}
const createDependencies = () => {
    writeTargetsToCache(calculatedTargets);
    return [];
};
exports.createDependencies = createDependencies;
exports.createNodes = [
    '**/.storybook/main.{js,ts,mjs,mts,cjs,cts}',
    (configFilePath, options, context) => {
        let projectRoot = '';
        if (configFilePath.includes('/.storybook')) {
            projectRoot = (0, path_1.dirname)(configFilePath).replace('/.storybook', '');
        }
        else {
            projectRoot = (0, path_1.dirname)(configFilePath).replace('.storybook', '');
        }
        if (projectRoot === '') {
            projectRoot = '.';
        }
        // Do not create a project if package.json and project.json isn't there.
        const siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(context.workspaceRoot, projectRoot));
        if (!siblingFiles.includes('package.json') &&
            !siblingFiles.includes('project.json')) {
            return {};
        }
        options = normalizeOptions(options);
        const hash = (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [
            (0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot)),
        ]);
        const projectName = buildProjectName(projectRoot, context.workspaceRoot);
        const targets = targetsCache[hash]
            ? targetsCache[hash]
            : buildStorybookTargets(configFilePath, projectRoot, options, context, projectName);
        calculatedTargets[hash] = targets;
        const result = {
            projects: {
                [projectRoot]: {
                    root: projectRoot,
                    targets,
                },
            },
        };
        return result;
    },
];
function buildStorybookTargets(configFilePath, projectRoot, options, context, projectName) {
    const buildOutputs = getOutputs(projectRoot);
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const storybookFramework = getStorybookConfig(configFilePath, context);
    const frameworkIsAngular = storybookFramework === "'@storybook/angular'";
    if (frameworkIsAngular && !projectName) {
        throw new Error(`Could not find a name for the project at '${projectRoot}'. Please make sure that the project has a package.json or project.json file with name specified.`);
    }
    const targets = {};
    targets[options.buildStorybookTargetName] = buildTarget(namedInputs, buildOutputs, projectRoot, frameworkIsAngular, projectName, configFilePath);
    targets[options.serveStorybookTargetName] = serveTarget(projectRoot, frameworkIsAngular, projectName, configFilePath);
    targets[options.testStorybookTargetName] = testTarget(projectRoot);
    targets[options.staticStorybookTargetName] = serveStaticTarget(options, projectRoot);
    return targets;
}
function buildTarget(namedInputs, outputs, projectRoot, frameworkIsAngular, projectName, configFilePath) {
    let targetConfig;
    if (frameworkIsAngular) {
        targetConfig = {
            executor: '@storybook/angular:build-storybook',
            options: {
                configDir: `${(0, path_1.dirname)(configFilePath)}`,
                browserTarget: `${projectName}:build-storybook`,
                compodoc: false,
                outputDir: (0, devkit_1.joinPathFragments)(projectRoot, 'storybook-static'),
            },
            cache: true,
            outputs,
            inputs: [
                ...('production' in namedInputs
                    ? ['production', '^production']
                    : ['default', '^default']),
                {
                    externalDependencies: [
                        'storybook',
                        '@storybook/angular',
                        '@storybook/test-runner',
                    ],
                },
            ],
        };
    }
    else {
        targetConfig = {
            command: `storybook build`,
            options: { cwd: projectRoot },
            cache: true,
            outputs,
            inputs: [
                ...('production' in namedInputs
                    ? ['production', '^production']
                    : ['default', '^default']),
                {
                    externalDependencies: ['storybook', '@storybook/test-runner'],
                },
            ],
        };
    }
    return targetConfig;
}
function serveTarget(projectRoot, frameworkIsAngular, projectName, configFilePath) {
    if (frameworkIsAngular) {
        return {
            executor: '@storybook/angular:start-storybook',
            options: {
                configDir: `${(0, path_1.dirname)(configFilePath)}`,
                browserTarget: `${projectName}:build-storybook`,
                compodoc: false,
            },
        };
    }
    else {
        return {
            command: `storybook dev`,
            options: { cwd: projectRoot },
        };
    }
}
function testTarget(projectRoot) {
    const targetConfig = {
        command: `test-storybook`,
        options: { cwd: projectRoot },
        inputs: [
            {
                externalDependencies: ['storybook', '@storybook/test-runner'],
            },
        ],
    };
    return targetConfig;
}
function serveStaticTarget(options, projectRoot) {
    const targetConfig = {
        executor: '@nx/web:file-server',
        options: {
            buildTarget: `${options.buildStorybookTargetName}`,
            staticFilePath: (0, devkit_1.joinPathFragments)(projectRoot, 'storybook-static'),
        },
    };
    return targetConfig;
}
function getStorybookConfig(configFilePath, context) {
    const resolvedPath = (0, path_1.join)(context.workspaceRoot, configFilePath);
    const mainTsJs = (0, fs_1.readFileSync)(resolvedPath, 'utf-8');
    const importDeclarations = tsquery_1.tsquery.query(mainTsJs, 'ImportDeclaration:has(ImportSpecifier:has([text="StorybookConfig"]))')?.[0];
    const storybookConfigImportPackage = tsquery_1.tsquery.query(importDeclarations, 'StringLiteral')?.[0];
    let frameworkName;
    if (storybookConfigImportPackage?.getText() === `'@storybook/core-common'`) {
        const frameworkPropertyAssignment = tsquery_1.tsquery.query(mainTsJs, `PropertyAssignment:has(Identifier:has([text="framework"]))`)?.[0];
        if (!frameworkPropertyAssignment) {
            return;
        }
        const propertyAssignments = tsquery_1.tsquery.query(frameworkPropertyAssignment, `PropertyAssignment:has(Identifier:has([text="name"]))`);
        const namePropertyAssignment = propertyAssignments?.find((expression) => {
            return expression.getText().startsWith('name');
        });
        if (!namePropertyAssignment) {
            const storybookConfigImportPackage = tsquery_1.tsquery.query(frameworkPropertyAssignment, 'StringLiteral')?.[0];
            frameworkName = storybookConfigImportPackage?.getText();
        }
        else {
            frameworkName = tsquery_1.tsquery
                .query(namePropertyAssignment, `StringLiteral`)?.[0]
                ?.getText();
        }
    }
    else {
        frameworkName = storybookConfigImportPackage?.getText();
    }
    return frameworkName;
}
function getOutputs(projectRoot) {
    const normalizedOutputPath = normalizeOutputPath(projectRoot);
    const outputs = [
        normalizedOutputPath,
        `{options.output-dir}`,
        `{options.outputDir}`,
        `{options.o}`,
    ];
    return outputs;
}
function normalizeOutputPath(projectRoot) {
    if (projectRoot === '.') {
        return `{projectRoot}/storybook-static`;
    }
    else {
        return `{workspaceRoot}/{projectRoot}/storybook-static`;
    }
}
function normalizeOptions(options) {
    options ??= {};
    options.buildStorybookTargetName = 'build-storybook';
    options.serveStorybookTargetName = 'storybook';
    options.testStorybookTargetName = 'test-storybook';
    options.staticStorybookTargetName = 'static-storybook';
    return options;
}
function buildProjectName(projectRoot, workspaceRoot) {
    const packageJsonPath = (0, path_1.join)(workspaceRoot, projectRoot, 'package.json');
    const projectJsonPath = (0, path_1.join)(workspaceRoot, projectRoot, 'project.json');
    let name;
    if ((0, fs_1.existsSync)(projectJsonPath)) {
        const projectJson = (0, devkit_1.parseJson)((0, fs_1.readFileSync)(projectJsonPath, 'utf-8'));
        name = projectJson.name;
    }
    else if ((0, fs_1.existsSync)(packageJsonPath)) {
        const packageJson = (0, devkit_1.parseJson)((0, fs_1.readFileSync)(packageJsonPath, 'utf-8'));
        name = packageJson.name;
    }
    return name;
}

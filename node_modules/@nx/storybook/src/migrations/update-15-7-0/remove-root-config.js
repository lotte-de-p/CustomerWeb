"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeRootConfig = void 0;
const devkit_1 = require("@nx/devkit");
const executor_options_utils_1 = require("@nx/devkit/src/generators/executor-options-utils");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const add_addon_essentials_to_all_1 = require("./add-addon-essentials-to-all");
const ts = require("typescript");
/**
 * The purpose of this migrator is to help users move away
 * from the root .storybook/ configuration folder and files.
 *
 * This is the second part of the migrator.
 *
 * If the root main.js file is empty, then we can safely delete it
 * and also remove all the references to it from the project-level
 * Storybook configuration files.
 *
 * Point the user to a guide that explains how to all these things.
 */
function removeRootConfig(tree, rootMainJsTsPath) {
    if (checkIfRootMainJsTsIsEmpty(tree, rootMainJsTsPath)) {
        const hasRemainingRootMainJsReferences = removeImportFromAllFiles(tree);
        tree.delete(rootMainJsTsPath);
        devkit_1.logger.warn(`
      We removed the root ${rootMainJsTsPath} file and we also
      removed all it's imports from all project-level Storybook configuration files.
      `);
        if (hasRemainingRootMainJsReferences.length) {
            devkit_1.logger.warn(`
        However, there are still other references to the root .storybook/main.js|ts file 
        in the following files: 

        ${hasRemainingRootMainJsReferences.join('\n')}

        Please remove them manually.
      `);
        }
        return true;
    }
}
exports.removeRootConfig = removeRootConfig;
function removeImportFromAllFiles(tree) {
    const hasRemainingRootMainJsReferences = [];
    (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@nrwl/storybook:build', (options) => {
        const hasRemainingReference = makeTheChanges(tree, options);
        if (hasRemainingReference) {
            hasRemainingRootMainJsReferences.push(hasRemainingReference);
        }
    });
    (0, executor_options_utils_1.forEachExecutorOptions)(tree, '@storybook/angular:build-storybook', (options) => {
        const hasRemainingReference = makeTheChanges(tree, options);
        if (hasRemainingReference) {
            hasRemainingRootMainJsReferences.push(hasRemainingReference);
        }
    });
    return hasRemainingRootMainJsReferences;
}
function makeTheChanges(tree, options) {
    const storybookDir = options?.['configDir'];
    if (storybookDir) {
        const mainJsTsPath = tree.exists(`${storybookDir}/main.js`)
            ? `${storybookDir}/main.js`
            : tree.exists(`${storybookDir}/main.ts`)
                ? `${storybookDir}/main.ts`
                : undefined;
        if (mainJsTsPath) {
            let mainJsTs = tree.read(mainJsTsPath, 'utf-8');
            const { rootMainVariableName, importExpression } = (0, add_addon_essentials_to_all_1.getRootMainVariableName)(mainJsTs);
            if (importExpression && rootMainVariableName) {
                const changesToBeMade = [
                    {
                        type: devkit_1.ChangeType.Delete,
                        start: importExpression.getStart(),
                        length: importExpression.getText().length,
                    },
                ];
                const spreadElements = tsquery_1.tsquery.query(mainJsTs, `SpreadElement:has(Identifier[name="${rootMainVariableName}"])`);
                spreadElements.forEach((spreadElement) => {
                    changesToBeMade.push({
                        type: devkit_1.ChangeType.Delete,
                        start: spreadElement.getStart(),
                        length: mainJsTs[spreadElement.getEnd()] === ','
                            ? spreadElement.getText().length + 1
                            : spreadElement.getText().length,
                    });
                });
                const spreadAssignments = tsquery_1.tsquery.query(mainJsTs, `SpreadAssignment:has(Identifier[name="${rootMainVariableName}"])`);
                spreadAssignments.forEach((spreadAssignment) => {
                    changesToBeMade.push({
                        type: devkit_1.ChangeType.Delete,
                        start: spreadAssignment.getStart(),
                        length: mainJsTs[spreadAssignment.getEnd()] === ','
                            ? spreadAssignment.getText().length + 1
                            : spreadAssignment.getText().length,
                    });
                });
                const findOtherRootMainUses = tsquery_1.tsquery.query(mainJsTs, `Identifier[name="${rootMainVariableName}"]`);
                findOtherRootMainUses.forEach((otherRootMainUse) => {
                    /**
                     * This would be mainly to remove the legacy
                     *
                     * if (rootMain.webpackFinal) {
                     *    config = await rootMain.webpackFinal(config, { configType });
                     * }
                     */
                    if (otherRootMainUse.parent.kind ===
                        ts.SyntaxKind.PropertyAccessExpression &&
                        otherRootMainUse.parent.parent?.kind === ts.SyntaxKind.IfStatement) {
                        changesToBeMade.push({
                            type: devkit_1.ChangeType.Delete,
                            start: otherRootMainUse.parent.parent.getStart(),
                            length: otherRootMainUse.parent.parent.getText().length + 1,
                        });
                    }
                });
                mainJsTs = (0, devkit_1.applyChangesToString)(mainJsTs, [...changesToBeMade]);
                tree.write(mainJsTsPath, mainJsTs);
                if (hasMoreRootMainUses(tree, mainJsTsPath, rootMainVariableName)) {
                    if (checkIfUsesOldSyntaxAndUpdate(tree, mainJsTsPath, rootMainVariableName)) {
                        return undefined;
                    }
                    return mainJsTsPath;
                }
            }
        }
    }
}
function checkIfUsesOldSyntaxAndUpdate(tree, filePath, rootMainVariableName) {
    const mainJsTs = tree.read(filePath, 'utf-8');
    const changesToBeMade = [];
    const { stringArray: addonsArrayString, expressionToDelete: addonsToDelete } = getPropertyArray('addons', mainJsTs, rootMainVariableName);
    const { stringArray: storiesArrayString, expressionToDelete: storiesToDelete, } = getPropertyArray('stories', mainJsTs, rootMainVariableName);
    if (storiesToDelete) {
        changesToBeMade.push(storiesToDelete);
    }
    if (addonsToDelete) {
        changesToBeMade.push(addonsToDelete);
    }
    if (addArrayToModuleExports('addons', mainJsTs, addonsArrayString)) {
        changesToBeMade.push(addArrayToModuleExports('addons', mainJsTs, addonsArrayString));
    }
    if (addArrayToModuleExports('stories', mainJsTs, storiesArrayString)) {
        changesToBeMade.push(addArrayToModuleExports('stories', mainJsTs, storiesArrayString));
    }
    if (changesToBeMade.length) {
        tree.write(filePath, (0, devkit_1.applyChangesToString)(mainJsTs, changesToBeMade));
        return true;
    }
}
function addArrayToModuleExports(propertyName, mainJsTs, arrayString) {
    if (!arrayString) {
        return;
    }
    const moduleExports = tsquery_1.tsquery.query(mainJsTs, `PropertyAccessExpression:has([expression.name="module"]):has([name="exports"]):has([name="${propertyName}"])`)?.[0];
    if (moduleExports) {
        const parentBinaryExpression = moduleExports.parent;
        const arrayExpression = tsquery_1.tsquery.query(parentBinaryExpression, `ArrayLiteralExpression`)?.[0];
        return {
            type: devkit_1.ChangeType.Insert,
            index: arrayExpression.getStart() + 1,
            text: arrayString,
        };
    }
    else {
        return {
            type: devkit_1.ChangeType.Insert,
            index: mainJsTs.length,
            text: `module.exports.${propertyName} = [${arrayString}];\n`,
        };
    }
}
function getPropertyArray(propertyName, mainJsTs, rootMainVariableName) {
    const propertyAccessExpression = tsquery_1.tsquery.query(mainJsTs, `PropertyAccessExpression:has([expression.name="${rootMainVariableName}"]):has([name="${propertyName}"])`)?.[0];
    if (propertyAccessExpression) {
        if (propertyAccessExpression?.getText() ===
            `${rootMainVariableName}.${propertyName}.push`) {
            const parentCallExpression = propertyAccessExpression.parent;
            const stringPropertyArray = tsquery_1.tsquery
                .query(parentCallExpression, `StringLiteral`)
                .map((stringLiteral) => stringLiteral?.getText());
            return {
                stringArray: `${stringPropertyArray.join(', ')}`,
                expressionToDelete: {
                    type: devkit_1.ChangeType.Delete,
                    start: parentCallExpression.getStart(),
                    length: parentCallExpression.getText().length + 1,
                },
            };
        }
    }
}
function hasMoreRootMainUses(tree, filePath, rootMainVariableName) {
    const mainJsTs = tree.read(filePath, 'utf-8');
    const findRemainingRootMainUses = tsquery_1.tsquery.query(mainJsTs, `Identifier[name="${rootMainVariableName}"]`);
    return findRemainingRootMainUses?.length > 0;
}
function checkIfRootMainJsTsIsEmpty(tree, rootMainJsTsPath) {
    const rootMainJsTs = tree.read(rootMainJsTsPath, 'utf-8');
    const mainConfigObject = tsquery_1.tsquery.query(rootMainJsTs, 'ObjectLiteralExpression');
    if (mainConfigObject?.length === 1 &&
        mainConfigObject[0]?.getText()?.replace(/\s/g, '') === '{}') {
        return true;
    }
}

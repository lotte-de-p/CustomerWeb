"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executorGeneratorInternal = exports.executorGenerator = exports.createExecutorsJson = void 0;
const devkit_1 = require("@nx/devkit");
const path = require("path");
const generator_1 = require("../lint-checks/generator");
const versions_1 = require("../../utils/versions");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
const path_1 = require("path");
function addFiles(host, options) {
    (0, devkit_1.generateFiles)(host, path.join(__dirname, './files/executor'), options.directory, {
        ...options,
    });
    if (options.unitTestRunner === 'none') {
        host.delete((0, devkit_1.joinPathFragments)(options.directory, `executor.spec.ts`));
    }
}
function addHasherFiles(host, options) {
    (0, devkit_1.generateFiles)(host, path.join(__dirname, './files/hasher'), options.directory, {
        ...options,
    });
    if (options.unitTestRunner === 'none') {
        host.delete((0, devkit_1.joinPathFragments)(options.directory, 'hasher.spec.ts'));
    }
}
async function createExecutorsJson(host, projectRoot, projectName, skipLintChecks) {
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'package.json'), (json) => {
        json.executors ??= './executors.json';
        return json;
    });
    (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'executors.json'), {
        executors: {},
    });
    if (!skipLintChecks) {
        await (0, generator_1.default)(host, {
            projectName,
        });
    }
}
exports.createExecutorsJson = createExecutorsJson;
async function updateExecutorJson(host, options) {
    const packageJson = (0, devkit_1.readJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'));
    const packageJsonExecutors = packageJson.executors ?? packageJson.builders;
    let executorsPath = packageJsonExecutors
        ? (0, devkit_1.joinPathFragments)(options.projectRoot, packageJsonExecutors)
        : null;
    if (!executorsPath) {
        executorsPath = (0, devkit_1.joinPathFragments)(options.projectRoot, 'executors.json');
    }
    if (!host.exists(executorsPath)) {
        await createExecutorsJson(host, options.projectRoot, options.project, options.skipLintChecks);
    }
    // add dependencies
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (json) => {
        json.dependencies = {
            '@nx/devkit': versions_1.nxVersion,
            ...json.dependencies,
        };
        return json;
    });
    return (0, devkit_1.updateJson)(host, executorsPath, (json) => {
        let executors = json.executors ?? json.builders;
        executors ||= {};
        executors[options.name] = {
            implementation: `./${(0, devkit_1.joinPathFragments)((0, path_1.relative)(options.projectRoot, options.directory), 'executor')}`,
            schema: `./${(0, devkit_1.joinPathFragments)((0, path_1.relative)(options.projectRoot, options.directory), 'schema.json')}`,
            description: options.description,
        };
        if (options.includeHasher) {
            executors[options.name].hasher = `./${(0, devkit_1.joinPathFragments)((0, path_1.relative)(options.projectRoot, options.directory), 'hasher')}`;
        }
        json.executors = executors;
        return json;
    });
}
async function normalizeOptions(tree, options) {
    const { project, artifactName, filePath, directory } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(tree, {
        artifactType: 'executor',
        callingGenerator: '@nx/plugin:executor',
        name: options.name,
        nameAndDirectoryFormat: options.nameAndDirectoryFormat,
        project: options.project,
        directory: options.directory,
        fileName: 'executor',
        derivedDirectory: 'executors',
    });
    const { className, propertyName } = (0, devkit_1.names)(artifactName);
    const { root: projectRoot } = (0, devkit_1.readProjectConfiguration)(tree, project);
    let description;
    if (options.description) {
        description = options.description;
    }
    else {
        description = `${options.name} executor`;
    }
    return {
        ...options,
        filePath,
        project,
        directory,
        className,
        propertyName,
        description,
        projectRoot,
    };
}
async function executorGenerator(tree, rawOptions) {
    await executorGeneratorInternal(tree, {
        nameAndDirectoryFormat: 'derived',
        ...rawOptions,
    });
}
exports.executorGenerator = executorGenerator;
async function executorGeneratorInternal(host, schema) {
    const options = await normalizeOptions(host, schema);
    addFiles(host, options);
    if (options.includeHasher) {
        addHasherFiles(host, options);
    }
    await updateExecutorJson(host, options);
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
}
exports.executorGeneratorInternal = executorGeneratorInternal;
exports.default = executorGenerator;

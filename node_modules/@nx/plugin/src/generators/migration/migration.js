"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrationGeneratorInternal = exports.migrationGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const path = require("path");
const path_1 = require("path");
const generator_1 = require("../lint-checks/generator");
const package_json_1 = require("nx/src/utils/package-json");
const versions_1 = require("../../utils/versions");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
async function normalizeOptions(tree, options) {
    let name;
    if (options.name) {
        name = (0, devkit_1.names)(options.name).fileName;
    }
    else {
        name = (0, devkit_1.names)(`update-${options.packageVersion}`).fileName;
    }
    const { project, fileName, artifactName, filePath, directory } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(tree, {
        artifactType: 'migration',
        callingGenerator: '@nx/plugin:migration',
        name: name,
        nameAndDirectoryFormat: options.nameAndDirectoryFormat,
        project: options.project,
        directory: options.directory,
        fileName: name,
        derivedDirectory: 'migrations',
    });
    const { className, propertyName } = (0, devkit_1.names)(artifactName);
    const { root: projectRoot, sourceRoot: projectSourceRoot } = (0, devkit_1.readProjectConfiguration)(tree, project);
    const description = options.description ?? `Migration for v${options.packageVersion}`;
    // const { root: projectRoot, sourceRoot: projectSourceRoot } =
    //   readProjectConfiguration(host, options.project);
    const normalized = {
        ...options,
        project,
        name: artifactName,
        directory,
        description,
        projectRoot,
        projectSourceRoot,
    };
    return normalized;
}
function addFiles(host, options) {
    (0, devkit_1.generateFiles)(host, path.join(__dirname, 'files/migration'), options.directory, { ...options, tmpl: '' });
}
function updateMigrationsJson(host, options) {
    const configuredMigrationPath = (0, package_json_1.readNxMigrateConfig)((0, devkit_1.readJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'))).migrations;
    const migrationsPath = (0, devkit_1.joinPathFragments)(options.projectRoot, configuredMigrationPath ?? 'migrations.json');
    const migrations = host.exists(migrationsPath)
        ? (0, devkit_1.readJson)(host, migrationsPath)
        : {};
    const generators = migrations.generators ?? {};
    generators[options.name] = {
        version: options.packageVersion,
        description: options.description,
        implementation: `./${(0, devkit_1.joinPathFragments)((0, path_1.relative)(options.projectRoot, options.directory), options.name)}`,
    };
    migrations.generators = generators;
    if (options.packageJsonUpdates) {
        const packageJsonUpdatesObj = migrations.packageJsonUpdates ?? {};
        if (!packageJsonUpdatesObj[options.packageVersion]) {
            packageJsonUpdatesObj[options.packageVersion] = {
                version: options.packageVersion,
                packages: {},
            };
        }
        migrations.packageJsonUpdates = packageJsonUpdatesObj;
    }
    (0, devkit_1.writeJson)(host, migrationsPath, migrations);
}
function updatePackageJson(host, options) {
    (0, devkit_1.updateJson)(host, path.join(options.projectRoot, 'package.json'), (json) => {
        const migrationKey = json['ng-update'] ? 'ng-update' : 'nx-migrations';
        const preexistingValue = json[migrationKey];
        if (typeof preexistingValue === 'string') {
            return json;
        }
        else if (!json[migrationKey]) {
            json[migrationKey] = {
                migrations: './migrations.json',
            };
        }
        else if (preexistingValue.migrations) {
            preexistingValue.migrations = './migrations.json';
        }
        // add dependencies
        json.dependencies = {
            '@nx/devkit': versions_1.nxVersion,
            ...json.dependencies,
        };
        return json;
    });
}
function updateProjectConfig(host, options) {
    const project = (0, devkit_1.readProjectConfiguration)(host, options.project);
    const assets = project.targets.build?.options?.assets;
    if (assets &&
        assets.filter((a) => a.glob === 'migrations.json').length === 0) {
        project.targets.build.options.assets = [
            ...assets,
            {
                input: `./${options.projectRoot}`,
                glob: 'migrations.json',
                output: '.',
            },
        ];
        (0, devkit_1.updateProjectConfiguration)(host, options.project, project);
    }
}
async function migrationGenerator(tree, rawOptions) {
    await migrationGeneratorInternal(tree, {
        nameAndDirectoryFormat: 'derived',
        ...rawOptions,
    });
}
exports.migrationGenerator = migrationGenerator;
async function migrationGeneratorInternal(host, schema) {
    const options = await normalizeOptions(host, schema);
    addFiles(host, options);
    updateMigrationsJson(host, options);
    updateProjectConfig(host, options);
    updateMigrationsJson(host, options);
    updatePackageJson(host, options);
    if (!host.exists('migrations.json')) {
        const packageJsonPath = (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json');
        (0, generator_1.addMigrationJsonChecks)(host, { projectName: options.project }, (0, devkit_1.readJson)(host, packageJsonPath));
    }
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
}
exports.migrationGeneratorInternal = migrationGeneratorInternal;
exports.default = migrationGenerator;

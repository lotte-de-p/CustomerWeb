"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generatorGeneratorInternal = exports.generatorGenerator = exports.createGeneratorsJson = void 0;
const devkit_1 = require("@nx/devkit");
const has_generator_1 = require("../../utils/has-generator");
const generator_1 = require("../lint-checks/generator");
const versions_1 = require("../../utils/versions");
const artifact_name_and_directory_utils_1 = require("@nx/devkit/src/generators/artifact-name-and-directory-utils");
const path_1 = require("path");
async function normalizeOptions(tree, options) {
    const { project, fileName, artifactName, filePath, directory } = await (0, artifact_name_and_directory_utils_1.determineArtifactNameAndDirectoryOptions)(tree, {
        artifactType: 'generator',
        callingGenerator: '@nx/plugin:generator',
        name: options.name,
        nameAndDirectoryFormat: options.nameAndDirectoryFormat,
        project: options.project,
        directory: options.directory,
        fileName: 'generator',
        derivedDirectory: 'generators',
    });
    const { className, propertyName } = (0, devkit_1.names)(artifactName);
    const { root: projectRoot, sourceRoot: projectSourceRoot } = (0, devkit_1.readProjectConfiguration)(tree, project);
    let description;
    if (options.description) {
        description = options.description;
    }
    else {
        description = `${options.name} generator`;
    }
    return {
        ...options,
        project,
        directory,
        fileName,
        className,
        propertyName,
        description,
        projectRoot,
        projectSourceRoot,
    };
}
function addFiles(host, options) {
    const indexPath = (0, path_1.join)(options.directory, 'files/src/index.ts.template');
    if (!host.exists(indexPath)) {
        host.write(indexPath, 'const variable = "<%= name %>";');
    }
    (0, devkit_1.generateFiles)(host, (0, path_1.join)(__dirname, './files/generator'), options.directory, {
        ...options,
        generatorFnName: `${options.propertyName}Generator`,
        schemaInterfaceName: `${options.className}GeneratorSchema`,
    });
    if (options.unitTestRunner === 'none') {
        host.delete((0, path_1.join)(options.directory, `generator.spec.ts`));
    }
}
async function createGeneratorsJson(host, projectRoot, projectName, skipLintChecks, skipFormat) {
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'package.json'), (json) => {
        json.generators ??= './generators.json';
        return json;
    });
    (0, devkit_1.writeJson)(host, (0, devkit_1.joinPathFragments)(projectRoot, 'generators.json'), {
        generators: {},
    });
    if (!skipLintChecks) {
        await (0, generator_1.default)(host, {
            projectName,
            skipFormat,
        });
    }
}
exports.createGeneratorsJson = createGeneratorsJson;
async function updateGeneratorJson(host, options) {
    const packageJson = (0, devkit_1.readJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'));
    const packageJsonGenerators = packageJson.generators ?? packageJson.schematics;
    let generatorsPath = packageJsonGenerators
        ? (0, devkit_1.joinPathFragments)(options.projectRoot, packageJsonGenerators)
        : null;
    if (!generatorsPath) {
        generatorsPath = (0, devkit_1.joinPathFragments)(options.projectRoot, 'generators.json');
    }
    if (!host.exists(generatorsPath)) {
        await createGeneratorsJson(host, options.projectRoot, options.project, options.skipLintChecks, options.skipFormat);
    }
    // add dependencies
    (0, devkit_1.updateJson)(host, (0, devkit_1.joinPathFragments)(options.projectRoot, 'package.json'), (json) => {
        json.dependencies = {
            '@nx/devkit': versions_1.nxVersion,
            ...json.dependencies,
        };
        return json;
    });
    (0, devkit_1.updateJson)(host, generatorsPath, (json) => {
        let generators = json.generators ?? json.schematics;
        generators = generators || {};
        generators[options.name] = {
            factory: `./${(0, devkit_1.joinPathFragments)((0, path_1.relative)(options.projectRoot, options.directory), 'generator')}`,
            schema: `./${(0, devkit_1.joinPathFragments)((0, path_1.relative)(options.projectRoot, options.directory), 'schema.json')}`,
            description: options.description,
        };
        // @todo(v17): Remove this, prop is defunct.
        if (options.name === 'preset') {
            generators[options.name]['x-use-standalone-layout'] = true;
        }
        json.generators = generators;
        return json;
    });
}
async function generatorGenerator(tree, rawOptions) {
    await generatorGeneratorInternal(tree, {
        nameAndDirectoryFormat: 'derived',
        ...rawOptions,
    });
}
exports.generatorGenerator = generatorGenerator;
async function generatorGeneratorInternal(host, schema) {
    const options = await normalizeOptions(host, schema);
    if ((0, has_generator_1.hasGenerator)(host, options.project, options.name)) {
        throw new Error(`Generator ${options.name} already exists.`);
    }
    addFiles(host, options);
    await updateGeneratorJson(host, options);
    if (!options.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
}
exports.generatorGeneratorInternal = generatorGeneratorInternal;
exports.default = generatorGenerator;

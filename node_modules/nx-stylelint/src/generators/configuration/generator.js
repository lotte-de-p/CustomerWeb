"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configurationGenerator = void 0;
const devkit_1 = require("@nx/devkit");
const formatter_1 = require("../../utils/formatter");
const generator_1 = require("../init/generator");
async function configurationGenerator(host, options) {
    const init = await (0, generator_1.initGenerator)(host, { skipFormat: options.skipFormat, scss: options.scss });
    const normalizedOptions = normalizeSchema(host, options);
    if (normalizedOptions.stylelintTargetExists) {
        devkit_1.logger.error(`Project '${options.project}' already has a stylelint target.`);
        return;
    }
    devkit_1.logger.info(`Adding Stylelint configuration and target to '${options.project}' ...\n`);
    createStylelintConfig(host, normalizedOptions);
    addStylelintTarget(host, normalizedOptions);
    if (options.skipFormat !== true)
        await (0, devkit_1.formatFiles)(host);
    return init;
}
exports.configurationGenerator = configurationGenerator;
exports.default = configurationGenerator;
function normalizeSchema(tree, options) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    const validFormatter = (0, formatter_1.isCoreFormatter)(options.formatter);
    if (options.formatter && !validFormatter) {
        devkit_1.logger.error(`Given formatter '${options.formatter}' is not a stylelint core formatter. Falling back to 'string' formatter.`);
    }
    return {
        ...options,
        formatter: validFormatter ? options.formatter : formatter_1.defaultFormatter,
        projectRoot: projectConfig.root,
        stylelintTargetExists: !!projectConfig.targets?.['stylelint'],
    };
}
function addStylelintTarget(tree, options) {
    const projectConfig = (0, devkit_1.readProjectConfiguration)(tree, options.project);
    const targetOptions = {
        lintFilePatterns: [(0, devkit_1.joinPathFragments)(options.projectRoot, '**', '*.css')],
        formatter: options.formatter === 'string' ? undefined : options.formatter,
    };
    if (options.scss) {
        targetOptions.lintFilePatterns ?? (targetOptions.lintFilePatterns = []);
        targetOptions.lintFilePatterns.push((0, devkit_1.joinPathFragments)(options.projectRoot, '**', '*.scss'));
    }
    projectConfig.targets = {
        ...projectConfig.targets,
        stylelint: {
            executor: 'nx-stylelint:lint',
            outputs: ['{options.outputFile}'],
            options: targetOptions,
        },
    };
    (0, devkit_1.updateProjectConfiguration)(tree, options.project, projectConfig);
}
function createStylelintConfig(tree, options) {
    const config = {
        extends: [(0, devkit_1.joinPathFragments)((0, devkit_1.offsetFromRoot)(options.projectRoot), '.stylelintrc.json')],
        ignoreFiles: ['!**/*'],
        overrides: [
            {
                files: ['**/*.css'],
                rules: {},
            },
        ],
    };
    if (options.scss) {
        config.overrides.push({
            files: ['**/*.scss'],
            rules: {},
        });
    }
    (0, devkit_1.writeJson)(tree, (0, devkit_1.joinPathFragments)(options.projectRoot, '.stylelintrc.json'), config);
}
//# sourceMappingURL=generator.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addToPlugins = exports.addToOutputTargets = exports.addOutputTarget = void 0;
const ts = require("typescript");
const common_1 = require("@nxext/common");
const devkit_1 = require("@nx/devkit");
const typescript_1 = require("nx/src/utils/typescript");
function addCodeIntoArray(source, identifier, toInsert) {
    const nodes = (0, typescript_1.findNodes)(source, [
        ts.SyntaxKind.ObjectLiteralExpression,
        ts.SyntaxKind.ArrayLiteralExpression,
    ]);
    let node = nodes[0];
    const matchingProperties = node &&
        node.properties
            .filter((prop) => prop.kind == ts.SyntaxKind.PropertyAssignment)
            .filter((prop) => {
            if (prop.name.kind === ts.SyntaxKind.Identifier) {
                return prop.name.getText(source) == identifier;
            }
            return false;
        });
    if (!matchingProperties) {
        return [];
    }
    if (matchingProperties.length == 0) {
        // We haven't found the field in the metadata declaration. Insert a new field.
        const expr = node;
        let position;
        let toInsert2;
        if (expr.properties.length == 0) {
            position = expr.getEnd() - 1;
            toInsert2 = `  ${identifier}: [${toInsert}]\n`;
        }
        else {
            node = expr.properties[expr.properties.length - 1];
            position = node.getEnd();
            // Get the indentation of the last element, if any.
            const text = node.getFullText(source);
            if (text.match('^\r?\r?\n')) {
                toInsert2 = `,${text.match(/^\r?\n\s+/)[0]}${identifier}: [${toInsert}]`;
            }
            else {
                toInsert2 = `, ${identifier}: [${toInsert}]`;
            }
        }
        return [
            {
                type: devkit_1.ChangeType.Insert,
                index: position,
                text: `\n${toInsert2}\n`,
            },
        ];
    }
    const assignment = matchingProperties[0];
    if (assignment.initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {
        return [];
    }
    const lastItem = getLastEntryOfOutputtargetArray(assignment);
    let toInsert2 = `, ${toInsert}`;
    if (lastItem.getText() === ',') {
        toInsert2 = toInsert;
    }
    return [
        {
            type: devkit_1.ChangeType.Insert,
            index: lastItem.getEnd(),
            text: `\n${toInsert2}\n`,
        },
    ];
}
function getLastEntryOfOutputtargetArray(node) {
    const arrayEntryList = node.getChildren()[2].getChildren()[1].getChildren();
    return arrayEntryList
        .sort((first, second) => first.getStart() - second.getStart())
        .pop();
}
function addOutputTarget(source, toInsert) {
    const outputTargetsIdentifier = 'outputTargets';
    return addCodeIntoArray(source, outputTargetsIdentifier, toInsert);
}
exports.addOutputTarget = addOutputTarget;
function addToOutputTargets(host, outputTargets, stencilConfigPath) {
    const stencilConfigSource = (0, common_1.readTsSourceFile)(host, stencilConfigPath);
    const changes = (0, devkit_1.applyChangesToString)(stencilConfigSource.text, addOutputTarget(stencilConfigSource, outputTargets.join(',')));
    host.write(stencilConfigPath, changes);
}
exports.addToOutputTargets = addToOutputTargets;
function addToPlugins(source, toInsert) {
    const pluginsIdentifier = 'plugins';
    return addCodeIntoArray(source, pluginsIdentifier, toInsert);
}
exports.addToPlugins = addToPlugins;
//# sourceMappingURL=plugins.js.map
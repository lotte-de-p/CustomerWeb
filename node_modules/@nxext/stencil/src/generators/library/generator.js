"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.librarySchematic = exports.libraryGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const typings_1 = require("../../utils/typings");
const utillities_1 = require("../../utils/utillities");
const init_1 = require("../../generators/init/init");
const update_tsconfig_1 = require("./lib/update-tsconfig");
const add_project_1 = require("./lib/add-project");
const make_lib_buildable_1 = require("../../generators/make-lib-buildable/make-lib-buildable");
const get_npm_scope_1 = require("@nx/js/src/utils/package-json/get-npm-scope");
function normalizeOptions(host, options) {
    const { libsDir } = (0, devkit_1.getWorkspaceLayout)(host);
    const npmScope = (0, get_npm_scope_1.getNpmScope)(host);
    const name = (0, devkit_1.names)(options.name).fileName;
    const projectDirectory = options.directory
        ? `${(0, devkit_1.names)(options.directory).fileName}/${name}`
        : name;
    const projectName = projectDirectory.replace(new RegExp('/', 'g'), '-');
    const projectRoot = `${libsDir}/${projectDirectory}`;
    const parsedTags = options.tags
        ? options.tags.split(',').map((s) => s.trim())
        : [];
    const style = (0, utillities_1.calculateStyle)(options.style);
    const appType = typings_1.AppType.library;
    const importPath = options.importPath || `@${npmScope}/${projectDirectory}`;
    return Object.assign(Object.assign({}, options), { projectName,
        projectRoot,
        projectDirectory,
        parsedTags,
        style,
        appType,
        importPath });
}
function createFiles(host, options) {
    (0, devkit_1.generateFiles)(host, (0, devkit_1.joinPathFragments)(__dirname, './files/lib'), options.projectRoot, Object.assign(Object.assign(Object.assign({}, options), (0, devkit_1.names)(options.name)), { offsetFromRoot: (0, devkit_1.offsetFromRoot)(options.projectRoot) }));
    if (options.unitTestRunner === 'none') {
        host.delete(`${options.projectRoot}/src/components/my-component/my-component.spec.ts`);
    }
    if (!options.component) {
        host.delete(`${options.projectRoot}/src/components/my-component`);
    }
}
function libraryGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const options = normalizeOptions(host, schema);
        if (options.publishable === true && !options.importPath) {
            throw new Error(`For publishable libs you have to provide a proper "--importPath" which needs to be a valid npm package name (e.g. my-awesome-lib or @myorg/my-lib)`);
        }
        const initTask = yield (0, init_1.initGenerator)(host, options);
        (0, add_project_1.addProject)(host, options);
        createFiles(host, options);
        (0, update_tsconfig_1.updateTsConfig)(host, options);
        if (options.buildable || options.publishable) {
            yield (0, make_lib_buildable_1.default)(host, {
                name: options.projectName,
                importPath: options.importPath,
                style: options.style,
            });
        }
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(host);
        }
        return (0, devkit_1.runTasksInSerial)(initTask);
    });
}
exports.libraryGenerator = libraryGenerator;
exports.default = libraryGenerator;
exports.librarySchematic = (0, devkit_1.convertNxGenerator)(libraryGenerator);
//# sourceMappingURL=generator.js.map
import { ChangeDetectorRef } from '@angular/core';
import { ComponentFactoryResolver } from '@angular/core';
import { ComponentRef } from '@angular/core';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { EnvironmentInjector } from '@angular/core';
import { EventEmitter } from '@angular/core';
import * as i0 from '@angular/core';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { IterableDiffers } from '@angular/core';
import { KeyValueDiffers } from '@angular/core';
import { NgComponentOutlet } from '@angular/common';
import { NgModuleRef } from '@angular/core';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { Renderer2 } from '@angular/core';
import { SimpleChanges } from '@angular/core';
import { StaticProvider } from '@angular/core';
import { Type } from '@angular/core';
import { ViewContainerRef } from '@angular/core';
import { ViewRef } from '@angular/core';

/**
 * @public
 */
export declare type AnyFunction = (...args: unknown[]) => unknown;

/**
 * @public
 */
export declare interface AttributesMap {
    [key: string]: string;
}

/**
 * @public
 */
export declare class ComponentOutletInjectorDirective implements DynamicComponentInjector {
    private componentOutlet;
    get componentRef(): ComponentRef<unknown>;
    constructor(componentOutlet: NgComponentOutlet);
    static ɵfac: i0.ɵɵFactoryDeclaration<ComponentOutletInjectorDirective, [{ host: true; }]>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ComponentOutletInjectorDirective, "[ngComponentOutlet]", ["ndcComponentOutletInjector"], {}, {}, never, never, true>;
}

/**
 * @public
 */
export declare class ComponentOutletInjectorModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<ComponentOutletInjectorModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<ComponentOutletInjectorModule, never, [typeof i1.ComponentOutletInjectorDirective, typeof i2.ComponentOutletIoDirective], [typeof i1.ComponentOutletInjectorDirective, typeof i2.ComponentOutletIoDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<ComponentOutletInjectorModule>;
}

/**
 * @public
 */
export declare class ComponentOutletIoDirective implements DoCheck {
    private ioService;
    ngComponentOutletNdcDynamicInputs?: InputsType | null;
    ngComponentOutletNdcDynamicOutputs?: OutputsType | null;
    constructor(ioService: IoService);
    ngDoCheck(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<ComponentOutletIoDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<ComponentOutletIoDirective, "[ngComponentOutletNdcDynamicInputs],[ngComponentOutletNdcDynamicOutputs]", ["ndcDynamicIo"], { "ngComponentOutletNdcDynamicInputs": "ngComponentOutletNdcDynamicInputs"; "ngComponentOutletNdcDynamicOutputs": "ngComponentOutletNdcDynamicOutputs"; }, {}, never, never, true>;
}

/**
 * @public
 */
export declare function defaultEventArgumentFactory(): string;

/**
 * @public
 */
export declare interface DirectiveRef<T> {
    instance: T;
    type: Type<T>;
    injector: Injector;
    hostComponent: unknown;
    hostView: ViewRef;
    location: ElementRef;
    changeDetectorRef: ChangeDetectorRef;
    onDestroy: (callback: Function) => void;
}

/**
 * @public
 */
export declare class DynamicAttributesDirective implements DoCheck {
    private renderer;
    private differs;
    private componentInjector?;
    ndcDynamicAttributes?: AttributesMap | null;
    ngComponentOutletNdcDynamicAttributes?: AttributesMap | null;
    private attrsDiffer;
    private lastCompType?;
    private lastAttrActions?;
    private get _attributes();
    private get nativeElement();
    private get compType();
    private get isCompChanged();
    constructor(renderer: Renderer2, differs: KeyValueDiffers, componentInjector?: DynamicComponentInjector | undefined);
    ngDoCheck(): void;
    setAttribute(name: string, value: string, namespace?: string): void;
    removeAttribute(name: string, namespace?: string): void;
    private updateAttributes;
    private changesToAttrActions;
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicAttributesDirective, [null, null, { optional: true; }]>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DynamicAttributesDirective, "[ndcDynamicAttributes],[ngComponentOutletNdcDynamicAttributes]", ["ndcDynamicAttributes"], { "ndcDynamicAttributes": "ndcDynamicAttributes"; "ngComponentOutletNdcDynamicAttributes": "ngComponentOutletNdcDynamicAttributes"; }, {}, never, never, true>;
}

/**
 * @public
 */
export declare class DynamicAttributesModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicAttributesModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<DynamicAttributesModule, never, [typeof i1_4.DynamicAttributesDirective], [typeof i1_4.DynamicAttributesDirective, typeof i2_2.ComponentOutletInjectorModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<DynamicAttributesModule>;
}

/**
 * @public
 */
export declare class DynamicComponent<C = unknown> implements OnChanges, DynamicComponentInjector {
    private vcr;
    private static UpdateOnInputs;
    ndcDynamicComponent?: Type<C> | null;
    ndcDynamicInjector?: Injector | null;
    ndcDynamicProviders?: StaticProvider[] | null;
    ndcDynamicContent?: Node[][];
    ndcDynamicNgModuleRef?: NgModuleRef<unknown>;
    ndcDynamicEnvironmentInjector?: EnvironmentInjector | NgModuleRef<unknown>;
    ndcDynamicCreated: EventEmitter<ComponentRef<C>>;
    componentRef: ComponentRef<C> | null;
    constructor(vcr: ViewContainerRef);
    ngOnChanges(changes: SimpleChanges): void;
    createDynamicComponent(): void;
    private _resolveInjector;
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicComponent<any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DynamicComponent<any>, "ndc-dynamic", never, { "ndcDynamicComponent": "ndcDynamicComponent"; "ndcDynamicInjector": "ndcDynamicInjector"; "ndcDynamicProviders": "ndcDynamicProviders"; "ndcDynamicContent": "ndcDynamicContent"; "ndcDynamicNgModuleRef": "ndcDynamicNgModuleRef"; "ndcDynamicEnvironmentInjector": "ndcDynamicEnvironmentInjector"; }, { "ndcDynamicCreated": "ndcDynamicCreated"; }, never, never, true>;
}

/**
 * @public
 */
export declare interface DynamicComponentInjector {
    componentRef: ComponentRef<unknown> | null;
}

/**
 * @public
 */
export declare const DynamicComponentInjectorToken: InjectionToken<DynamicComponentInjector>;

/**
 * @public
 */
export declare interface DynamicDirectiveDef<T> {
    type: Type<T>;
    inputs?: InputsType;
    outputs?: OutputsType;
}

/**
 * @public
 */
export declare function dynamicDirectiveDef<T>(type: Type<T>, inputs?: InputsType, outputs?: OutputsType): DynamicDirectiveDef<T>;

/**
 * @public
 * @experimental Dynamic directives is an experimental API that may not work as expected.
 *
 * NOTE: There is a known issue with OnChanges hook not beign triggered on dynamic directives
 * since this part of functionality has been removed from the core as Angular now
 * supports this out of the box for dynamic components.
 */
export declare class DynamicDirectivesDirective implements OnDestroy, DoCheck {
    private injector;
    private iterableDiffers;
    private ioFactoryService;
    private reflectService;
    private componentInjector?;
    ndcDynamicDirectives?: DynamicDirectiveDef<unknown>[] | null;
    ngComponentOutletNdcDynamicDirectives?: DynamicDirectiveDef<unknown>[] | null;
    ndcDynamicDirectivesCreated: EventEmitter<DirectiveRef<unknown>[]>;
    private lastCompInstance;
    private get directives();
    private get componentRef();
    private get compInstance();
    private get isCompChanged();
    private get hostInjector();
    private dirRef;
    private dirIo;
    private dirsDiffer;
    constructor(injector: Injector, iterableDiffers: IterableDiffers, ioFactoryService: IoFactoryService, reflectService: ReflectService, componentInjector?: DynamicComponentInjector | undefined);
    ngDoCheck(): void;
    ngOnDestroy(): void;
    private maybeDestroyDirectives;
    private processDirChanges;
    private updateDirectives;
    private updateDirective;
    private initDirective;
    private destroyAllDirectives;
    private destroyDirective;
    private initDirIO;
    private dirToCompDef;
    private destroyDirRef;
    private createDirective;
    private resolveDirParamTypes;
    private callInitHooks;
    private callHook;
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicDirectivesDirective, [null, null, null, null, { optional: true; }]>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DynamicDirectivesDirective, "[ndcDynamicDirectives],[ngComponentOutletNdcDynamicDirectives]", never, { "ndcDynamicDirectives": "ndcDynamicDirectives"; "ngComponentOutletNdcDynamicDirectives": "ngComponentOutletNdcDynamicDirectives"; }, { "ndcDynamicDirectivesCreated": "ndcDynamicDirectivesCreated"; }, never, never, true>;
}

/**
 * @public
 */
export declare class DynamicDirectivesModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicDirectivesModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<DynamicDirectivesModule, never, [typeof i1_5.DynamicDirectivesDirective], [typeof i1_5.DynamicDirectivesDirective, typeof i2_2.ComponentOutletInjectorModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<DynamicDirectivesModule>;
}

/**
 * @public
 */
export declare class DynamicIoDirective implements DoCheck {
    private ioService;
    ndcDynamicInputs?: InputsType | null;
    ndcDynamicOutputs?: OutputsType | null;
    constructor(ioService: IoService);
    ngDoCheck(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicIoDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DynamicIoDirective, "[ndcDynamicInputs],[ndcDynamicOutputs]", ["ndcDynamicIo"], { "ndcDynamicInputs": "ndcDynamicInputs"; "ndcDynamicOutputs": "ndcDynamicOutputs"; }, {}, never, never, true>;
}

/**
 * @public
 */
export declare class DynamicIoModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicIoModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<DynamicIoModule, never, [typeof i1_3.DynamicIoDirective], [typeof i1_3.DynamicIoDirective, typeof i2_2.ComponentOutletInjectorModule]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<DynamicIoModule>;
}

/**
 * @public
 */
export declare class DynamicModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<DynamicModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<DynamicModule, never, [typeof i1_2.DynamicIoModule, typeof i2_3.DynamicComponent], [typeof i1_2.DynamicIoModule, typeof i2_3.DynamicComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<DynamicModule>;
}

/**
 * @public
 * @deprecated Since v10.4.0 - Use {@link IoEventArgumentToken} instead!
 */
export declare const EventArgumentToken: InjectionToken<string>;

/**
 * @public
 */
export declare type EventHandler<T = unknown> = (event: T) => unknown;

declare namespace i1 {
    export {
        ComponentOutletInjectorDirective
    }
}

declare namespace i1_2 {
    export {
        DynamicIoModule
    }
}

declare namespace i1_3 {
    export {
        DynamicIoDirective
    }
}

declare namespace i1_4 {
    export {
        AttributesMap,
        DynamicAttributesDirective
    }
}

declare namespace i1_5 {
    export {
        dynamicDirectiveDef,
        DynamicDirectiveDef,
        DirectiveRef,
        DynamicDirectivesDirective
    }
}

declare namespace i2 {
    export {
        ComponentOutletIoDirective
    }
}

declare namespace i2_2 {
    export {
        ComponentOutletInjectorModule
    }
}

declare namespace i2_3 {
    export {
        DynamicComponent
    }
}

/**
 * @public
 */
export declare interface InputsType {
    [k: string]: unknown;
}

/**
 * @public
 */
export declare const IoEventArgumentToken: InjectionToken<string>;

/**
 * A token that holds provider for custom context of the output handlers
 * which should be provided using {@link IoEventContextToken} token
 *
 * @public
 */
export declare const IoEventContextProviderToken: InjectionToken<StaticProvider>;

/**
 * A token that holds custom context of the output handlers
 *
 * @public
 */
export declare const IoEventContextToken: InjectionToken<unknown>;

/**
 * @public
 */
export declare class IoFactoryService {
    private injector;
    constructor(injector: Injector);
    create(componentInjector: DynamicComponentInjector, ioOptions?: IoServiceOptions & IoFactoryServiceOptions): IoService;
    static ɵfac: i0.ɵɵFactoryDeclaration<IoFactoryService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<IoFactoryService>;
}

/**
 * @public
 */
export declare interface IoFactoryServiceOptions {
    injector?: Injector;
}

/**
 * @public
 */
export declare class IoService implements OnDestroy {
    private injector;
    private differs;
    private cfr;
    private options;
    private compInjector;
    private eventArgument;
    private cdr;
    private eventContextProvider;
    private lastComponentInst;
    private lastChangedInputs;
    private inputsDiffer;
    private compFactory;
    private outputsShouldDisconnect$;
    private outputsEventContext;
    private inputs;
    private outputs;
    private outputsChanged;
    private get compRef();
    private get componentInst();
    private get componentInstChanged();
    constructor(injector: Injector, differs: KeyValueDiffers, cfr: ComponentFactoryResolver, options: IoServiceOptions, compInjector: DynamicComponentInjector, eventArgument: string, cdr: ChangeDetectorRef, eventContextProvider: StaticProvider);
    ngOnDestroy(): void;
    /**
     * Call update whenever inputs/outputs may or did change.
     *
     * It will detect both new and mutated changes.
     */
    update(inputs?: InputsType | null, outputs?: OutputsType | null): void;
    private updateIO;
    private updateInputs;
    private bindOutputs;
    private disconnectOutputs;
    private getInputsChanges;
    private updateChangedInputs;
    private resolveCompFactory;
    private updateCompFactory;
    private resolveOutputs;
    private updateOutputsEventContext;
    private processOutputs;
    private processOutputArgs;
    private remapIO;
    private findPropByTplInMapping;
    static ɵfac: i0.ɵɵFactoryDeclaration<IoService, [null, null, null, null, null, null, null, { optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<IoService>;
}

/**
 * @public
 */
export declare class IoServiceOptions {
    trackOutputChanges: boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<IoServiceOptions, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<IoServiceOptions>;
}

/**
 * @public
 */
export declare type OutputExpression = EventHandler | OutputWithArgs;

/**
 * @public
 */
export declare interface OutputsType {
    [k: string]: OutputExpression | undefined;
}

/**
 * @public
 */
export declare interface OutputWithArgs {
    handler: AnyFunction;
    args?: unknown[];
}

/**
 * Reflect API subsystem required for lib to work
 *
 * @public
 */
export declare interface ReflectApi {
    getMetadata(type: string, obj: unknown): unknown[];
}

/**
 * @public
 */
export declare const ReflectRef: InjectionToken<ReflectApi>;

/**
 * @public
 */
export declare class ReflectService {
    private reflect;
    constructor(reflect: ReflectApi);
    getCtorParamTypes(ctor: Type<unknown>): unknown[];
    static ɵfac: i0.ɵɵFactoryDeclaration<ReflectService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ReflectService>;
}

export { }

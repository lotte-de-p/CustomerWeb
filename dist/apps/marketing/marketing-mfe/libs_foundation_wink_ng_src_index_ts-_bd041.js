(self["webpackChunkmarketing_mfe"] = self["webpackChunkmarketing_mfe"] || []).push([["libs_foundation_wink_ng_src_index_ts-_bd041"],{

/***/ 87493:
/*!******************************************************************************!*\
  !*** ./libs/foundation/wink/ng/src/generated/angular-component-lib/utils.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProxyCmp: () => (/* binding */ ProxyCmp),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement),
/* harmony export */   proxyInputs: () => (/* binding */ proxyInputs),
/* harmony export */   proxyMethods: () => (/* binding */ proxyMethods),
/* harmony export */   proxyOutputs: () => (/* binding */ proxyOutputs)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 44946);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable */
/* tslint:disable */

const proxyInputs = (Cmp, inputs) => {
  const Prototype = Cmp.prototype;
  inputs.forEach(item => {
    Object.defineProperty(Prototype, item, {
      get() {
        return this.el[item];
      },
      set(val) {
        this.z.runOutsideAngular(() => this.el[item] = val);
      },
      /**
       * In the event that proxyInputs is called
       * multiple times re-defining these inputs
       * will cause an error to be thrown. As a result
       * we set configurable: true to indicate these
       * properties can be changed.
       */
      configurable: true
    });
  });
};
const proxyMethods = (Cmp, methods) => {
  const Prototype = Cmp.prototype;
  methods.forEach(methodName => {
    Prototype[methodName] = function () {
      const args = arguments;
      return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));
    };
  });
};
const proxyOutputs = (instance, el, events) => {
  events.forEach(eventName => instance[eventName] = (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.fromEvent)(el, eventName));
};
const defineCustomElement = (tagName, customElement) => {
  if (customElement !== undefined && typeof customElements !== 'undefined' && !customElements.get(tagName)) {
    customElements.define(tagName, customElement);
  }
};
// tslint:disable-next-line: only-arrow-functions
function ProxyCmp(opts) {
  const decorator = function (cls) {
    const {
      defineCustomElementFn,
      inputs,
      methods
    } = opts;
    if (defineCustomElementFn !== undefined) {
      defineCustomElementFn();
    }
    if (inputs) {
      proxyInputs(cls, inputs);
    }
    if (methods) {
      proxyMethods(cls, methods);
    }
    return cls;
  };
  return decorator;
}

/***/ }),

/***/ 60561:
/*!********************************************************!*\
  !*** ./libs/foundation/wink/ng/src/generated/index.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DIRECTIVES: () => (/* binding */ DIRECTIVES)
/* harmony export */ });
/* harmony import */ var _proxies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proxies */ 85786);

const DIRECTIVES = [_proxies__WEBPACK_IMPORTED_MODULE_0__.WinkAccordion, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkAnimation, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkAvatar, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkBadge, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkButton, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkCheckBox, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkCheckBoxGroup, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkColumnCount, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkCustomerOrientation, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkDropdownMenu, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkFlyout, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkFormLabel, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkGlobalHeader, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkIcon, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkImg, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkIndicator, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkInput, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkIntentBar, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkLink, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkLogo, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkMainNavigation, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkNavigationList, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkNavigationListItem, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkNotification, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkParagraph, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkPricing, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkRadioButton, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkRadioGroup, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkRangeSlider, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkSelect, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkSheet, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkSpacer, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkStack, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkTabs, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkTextarea, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkTitle, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkToast, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkToaster, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkToggleSwitch, _proxies__WEBPACK_IMPORTED_MODULE_0__.WinkValidationMessage];

/***/ }),

/***/ 85786:
/*!**********************************************************!*\
  !*** ./libs/foundation/wink/ng/src/generated/proxies.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkAccordion: () => (/* binding */ WinkAccordion),
/* harmony export */   WinkAnimation: () => (/* binding */ WinkAnimation),
/* harmony export */   WinkAvatar: () => (/* binding */ WinkAvatar),
/* harmony export */   WinkBadge: () => (/* binding */ WinkBadge),
/* harmony export */   WinkButton: () => (/* binding */ WinkButton),
/* harmony export */   WinkCheckBox: () => (/* binding */ WinkCheckBox),
/* harmony export */   WinkCheckBoxGroup: () => (/* binding */ WinkCheckBoxGroup),
/* harmony export */   WinkColumnCount: () => (/* binding */ WinkColumnCount),
/* harmony export */   WinkCustomerOrientation: () => (/* binding */ WinkCustomerOrientation),
/* harmony export */   WinkDropdownMenu: () => (/* binding */ WinkDropdownMenu),
/* harmony export */   WinkFlyout: () => (/* binding */ WinkFlyout),
/* harmony export */   WinkFormLabel: () => (/* binding */ WinkFormLabel),
/* harmony export */   WinkGlobalHeader: () => (/* binding */ WinkGlobalHeader),
/* harmony export */   WinkIcon: () => (/* binding */ WinkIcon),
/* harmony export */   WinkImg: () => (/* binding */ WinkImg),
/* harmony export */   WinkIndicator: () => (/* binding */ WinkIndicator),
/* harmony export */   WinkInput: () => (/* binding */ WinkInput),
/* harmony export */   WinkIntentBar: () => (/* binding */ WinkIntentBar),
/* harmony export */   WinkLink: () => (/* binding */ WinkLink),
/* harmony export */   WinkLogo: () => (/* binding */ WinkLogo),
/* harmony export */   WinkMainNavigation: () => (/* binding */ WinkMainNavigation),
/* harmony export */   WinkNavigationList: () => (/* binding */ WinkNavigationList),
/* harmony export */   WinkNavigationListItem: () => (/* binding */ WinkNavigationListItem),
/* harmony export */   WinkNotification: () => (/* binding */ WinkNotification),
/* harmony export */   WinkParagraph: () => (/* binding */ WinkParagraph),
/* harmony export */   WinkPricing: () => (/* binding */ WinkPricing),
/* harmony export */   WinkRadioButton: () => (/* binding */ WinkRadioButton),
/* harmony export */   WinkRadioGroup: () => (/* binding */ WinkRadioGroup),
/* harmony export */   WinkRangeSlider: () => (/* binding */ WinkRangeSlider),
/* harmony export */   WinkSelect: () => (/* binding */ WinkSelect),
/* harmony export */   WinkSheet: () => (/* binding */ WinkSheet),
/* harmony export */   WinkSpacer: () => (/* binding */ WinkSpacer),
/* harmony export */   WinkStack: () => (/* binding */ WinkStack),
/* harmony export */   WinkTabs: () => (/* binding */ WinkTabs),
/* harmony export */   WinkTextarea: () => (/* binding */ WinkTextarea),
/* harmony export */   WinkTitle: () => (/* binding */ WinkTitle),
/* harmony export */   WinkToast: () => (/* binding */ WinkToast),
/* harmony export */   WinkToaster: () => (/* binding */ WinkToaster),
/* harmony export */   WinkToggleSwitch: () => (/* binding */ WinkToggleSwitch),
/* harmony export */   WinkValidationMessage: () => (/* binding */ WinkValidationMessage)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ 33829);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./angular-component-lib/utils */ 87493);
/* harmony import */ var _telenet_wink_core_components_wink_accordion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @telenet/wink-core/components/wink-accordion.js */ 17857);
/* harmony import */ var _telenet_wink_core_components_wink_animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @telenet/wink-core/components/wink-animation.js */ 70405);
/* harmony import */ var _telenet_wink_core_components_wink_avatar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @telenet/wink-core/components/wink-avatar.js */ 91318);
/* harmony import */ var _telenet_wink_core_components_wink_badge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @telenet/wink-core/components/wink-badge.js */ 94870);
/* harmony import */ var _telenet_wink_core_components_wink_button_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @telenet/wink-core/components/wink-button.js */ 78323);
/* harmony import */ var _telenet_wink_core_components_wink_check_box_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @telenet/wink-core/components/wink-check-box.js */ 11597);
/* harmony import */ var _telenet_wink_core_components_wink_check_box_group_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @telenet/wink-core/components/wink-check-box-group.js */ 69904);
/* harmony import */ var _telenet_wink_core_components_wink_column_count_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @telenet/wink-core/components/wink-column-count.js */ 23443);
/* harmony import */ var _telenet_wink_core_components_wink_customer_orientation_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @telenet/wink-core/components/wink-customer-orientation.js */ 96589);
/* harmony import */ var _telenet_wink_core_components_wink_dropdown_menu_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @telenet/wink-core/components/wink-dropdown-menu.js */ 35815);
/* harmony import */ var _telenet_wink_core_components_wink_flyout_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @telenet/wink-core/components/wink-flyout.js */ 83167);
/* harmony import */ var _telenet_wink_core_components_wink_form_label_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @telenet/wink-core/components/wink-form-label.js */ 7823);
/* harmony import */ var _telenet_wink_core_components_wink_global_header_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @telenet/wink-core/components/wink-global-header.js */ 34605);
/* harmony import */ var _telenet_wink_core_components_wink_icon_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @telenet/wink-core/components/wink-icon.js */ 48426);
/* harmony import */ var _telenet_wink_core_components_wink_img_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @telenet/wink-core/components/wink-img.js */ 3890);
/* harmony import */ var _telenet_wink_core_components_wink_indicator_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @telenet/wink-core/components/wink-indicator.js */ 82863);
/* harmony import */ var _telenet_wink_core_components_wink_input_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @telenet/wink-core/components/wink-input.js */ 47598);
/* harmony import */ var _telenet_wink_core_components_wink_intent_bar_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @telenet/wink-core/components/wink-intent-bar.js */ 34913);
/* harmony import */ var _telenet_wink_core_components_wink_link_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @telenet/wink-core/components/wink-link.js */ 61295);
/* harmony import */ var _telenet_wink_core_components_wink_logo_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @telenet/wink-core/components/wink-logo.js */ 63615);
/* harmony import */ var _telenet_wink_core_components_wink_main_navigation_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @telenet/wink-core/components/wink-main-navigation.js */ 8392);
/* harmony import */ var _telenet_wink_core_components_wink_navigation_list_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @telenet/wink-core/components/wink-navigation-list.js */ 94253);
/* harmony import */ var _telenet_wink_core_components_wink_navigation_list_item_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @telenet/wink-core/components/wink-navigation-list-item.js */ 67853);
/* harmony import */ var _telenet_wink_core_components_wink_notification_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @telenet/wink-core/components/wink-notification.js */ 41240);
/* harmony import */ var _telenet_wink_core_components_wink_paragraph_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @telenet/wink-core/components/wink-paragraph.js */ 49688);
/* harmony import */ var _telenet_wink_core_components_wink_pricing_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @telenet/wink-core/components/wink-pricing.js */ 12705);
/* harmony import */ var _telenet_wink_core_components_wink_radio_button_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @telenet/wink-core/components/wink-radio-button.js */ 87417);
/* harmony import */ var _telenet_wink_core_components_wink_radio_group_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @telenet/wink-core/components/wink-radio-group.js */ 81725);
/* harmony import */ var _telenet_wink_core_components_wink_range_slider_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @telenet/wink-core/components/wink-range-slider.js */ 64089);
/* harmony import */ var _telenet_wink_core_components_wink_select_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @telenet/wink-core/components/wink-select.js */ 1149);
/* harmony import */ var _telenet_wink_core_components_wink_sheet_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @telenet/wink-core/components/wink-sheet.js */ 22180);
/* harmony import */ var _telenet_wink_core_components_wink_spacer_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @telenet/wink-core/components/wink-spacer.js */ 42557);
/* harmony import */ var _telenet_wink_core_components_wink_stack_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @telenet/wink-core/components/wink-stack.js */ 4140);
/* harmony import */ var _telenet_wink_core_components_wink_tabs_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @telenet/wink-core/components/wink-tabs.js */ 78175);
/* harmony import */ var _telenet_wink_core_components_wink_textarea_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @telenet/wink-core/components/wink-textarea.js */ 62535);
/* harmony import */ var _telenet_wink_core_components_wink_title_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @telenet/wink-core/components/wink-title.js */ 53312);
/* harmony import */ var _telenet_wink_core_components_wink_toast_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @telenet/wink-core/components/wink-toast.js */ 55675);
/* harmony import */ var _telenet_wink_core_components_wink_toaster_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @telenet/wink-core/components/wink-toaster.js */ 33252);
/* harmony import */ var _telenet_wink_core_components_wink_toggle_switch_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! @telenet/wink-core/components/wink-toggle-switch.js */ 74097);
/* harmony import */ var _telenet_wink_core_components_wink_validation_message_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! @telenet/wink-core/components/wink-validation-message.js */ 96292);
var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = undefined && undefined.__metadata || function (k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/* tslint:disable */
/* auto-generated angular directive proxies */











































const _c0 = ["*"];
let WinkAccordion = class WinkAccordion {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkAccordion_Factory(t) {
    return new (t || WinkAccordion)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkAccordion,
    selectors: [["wink-accordion"]],
    inputs: {
      heading: "heading",
      icon: "icon",
      isExpanded: "isExpanded"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkAccordion_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkAccordion = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_accordion_js__WEBPACK_IMPORTED_MODULE_1__.defineCustomElement,
  inputs: ['heading', 'icon', 'isExpanded']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkAccordion);

let WinkAnimation = class WinkAnimation {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkAnimation_Factory(t) {
    return new (t || WinkAnimation)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkAnimation,
    selectors: [["wink-animation"]],
    inputs: {
      autoplay: "autoplay",
      clickToPlay: "clickToPlay",
      controls: "controls",
      count: "count",
      src: "src"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkAnimation_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkAnimation = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_animation_js__WEBPACK_IMPORTED_MODULE_2__.defineCustomElement,
  inputs: ['autoplay', 'clickToPlay', 'controls', 'count', 'src'],
  methods: ['toggleAnimation']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkAnimation);

let WinkAvatar = class WinkAvatar {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkAvatar_Factory(t) {
    return new (t || WinkAvatar)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkAvatar,
    selectors: [["wink-avatar"]],
    inputs: {
      size: "size",
      src: "src"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkAvatar_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkAvatar = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_avatar_js__WEBPACK_IMPORTED_MODULE_3__.defineCustomElement,
  inputs: ['size', 'src']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkAvatar);

let WinkBadge = class WinkBadge {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkBadge_Factory(t) {
    return new (t || WinkBadge)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkBadge,
    selectors: [["wink-badge"]],
    inputs: {
      background: "background",
      size: "size",
      text: "text"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkBadge_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkBadge = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_badge_js__WEBPACK_IMPORTED_MODULE_4__.defineCustomElement,
  inputs: ['background', 'size', 'text']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkBadge);

let WinkButton = class WinkButton {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkButton_Factory(t) {
    return new (t || WinkButton)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkButton,
    selectors: [["wink-button"]],
    inputs: {
      appearance: "appearance",
      element: "element",
      href: "href",
      icon: "icon",
      iconButtonAriaLabel: "iconButtonAriaLabel",
      iconPosition: "iconPosition",
      loadingText: "loadingText",
      size: "size",
      status: "status",
      target: "target",
      text: "text",
      type: "type",
      width: "width"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkButton_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkButton = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_button_js__WEBPACK_IMPORTED_MODULE_5__.defineCustomElement,
  inputs: ['appearance', 'element', 'href', 'icon', 'iconButtonAriaLabel', 'iconPosition', 'loadingText', 'size', 'status', 'target', 'text', 'type', 'width']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkButton);

let WinkCheckBox = class WinkCheckBox {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkCheckBox_Factory(t) {
    return new (t || WinkCheckBox)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkCheckBox,
    selectors: [["wink-check-box"]],
    inputs: {
      checkboxId: "checkboxId",
      checked: "checked",
      disabled: "disabled",
      error: "error",
      helper: "helper",
      label: "label",
      name: "name"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkCheckBox_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkCheckBox = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_check_box_js__WEBPACK_IMPORTED_MODULE_6__.defineCustomElement,
  inputs: ['checkboxId', 'checked', 'disabled', 'error', 'helper', 'label', 'name']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkCheckBox);

let WinkCheckBoxGroup = class WinkCheckBoxGroup {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkCheckBoxGroup_Factory(t) {
    return new (t || WinkCheckBoxGroup)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkCheckBoxGroup,
    selectors: [["wink-check-box-group"]],
    inputs: {
      direction: "direction",
      error: "error",
      helper: "helper",
      isRequired: "isRequired",
      label: "label",
      optionalText: "optionalText"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkCheckBoxGroup_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkCheckBoxGroup = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_check_box_group_js__WEBPACK_IMPORTED_MODULE_7__.defineCustomElement,
  inputs: ['direction', 'error', 'helper', 'isRequired', 'label', 'optionalText'],
  methods: ['setValidation']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkCheckBoxGroup);

let WinkColumnCount = class WinkColumnCount {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkColumnCount_Factory(t) {
    return new (t || WinkColumnCount)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkColumnCount,
    selectors: [["wink-column-count"]],
    inputs: {
      colsCount: "colsCount"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkColumnCount_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkColumnCount = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_column_count_js__WEBPACK_IMPORTED_MODULE_8__.defineCustomElement,
  inputs: ['colsCount']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkColumnCount);

let WinkCustomerOrientation = class WinkCustomerOrientation {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkCustomerOrientation_Factory(t) {
    return new (t || WinkCustomerOrientation)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkCustomerOrientation,
    selectors: [["wink-customer-orientation"]],
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkCustomerOrientation_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkCustomerOrientation = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_customer_orientation_js__WEBPACK_IMPORTED_MODULE_9__.defineCustomElement
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkCustomerOrientation);

let WinkDropdownMenu = class WinkDropdownMenu {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkDropdownMenu_Factory(t) {
    return new (t || WinkDropdownMenu)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkDropdownMenu,
    selectors: [["wink-dropdown-menu"]],
    inputs: {
      dropdownTabIndex: "dropdownTabIndex",
      heading: "heading",
      isExpanded: "isExpanded",
      itemSelected: "itemSelected"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkDropdownMenu_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkDropdownMenu = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_dropdown_menu_js__WEBPACK_IMPORTED_MODULE_10__.defineCustomElement,
  inputs: ['dropdownTabIndex', 'heading', 'isExpanded', 'itemSelected']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkDropdownMenu);

let WinkFlyout = class WinkFlyout {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    (0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.proxyOutputs)(this, this.el, ['flyoutBackLinkClicked']);
  }
  static ɵfac = function WinkFlyout_Factory(t) {
    return new (t || WinkFlyout)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkFlyout,
    selectors: [["wink-flyout"]],
    inputs: {
      flyoutId: "flyoutId"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkFlyout_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkFlyout = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_flyout_js__WEBPACK_IMPORTED_MODULE_11__.defineCustomElement,
  inputs: ['flyoutId']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkFlyout);

let WinkFormLabel = class WinkFormLabel {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkFormLabel_Factory(t) {
    return new (t || WinkFormLabel)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkFormLabel,
    selectors: [["wink-form-label"]],
    inputs: {
      helper: "helper",
      helperId: "helperId",
      isDisabled: "isDisabled",
      label: "label",
      labelId: "labelId",
      optionalText: "optionalText",
      rendition: "rendition",
      showOptional: "showOptional"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkFormLabel_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkFormLabel = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_form_label_js__WEBPACK_IMPORTED_MODULE_12__.defineCustomElement,
  inputs: ['helper', 'helperId', 'isDisabled', 'label', 'labelId', 'optionalText', 'rendition', 'showOptional']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkFormLabel);

let WinkGlobalHeader = class WinkGlobalHeader {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkGlobalHeader_Factory(t) {
    return new (t || WinkGlobalHeader)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkGlobalHeader,
    selectors: [["wink-global-header"]],
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkGlobalHeader_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkGlobalHeader = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_global_header_js__WEBPACK_IMPORTED_MODULE_13__.defineCustomElement
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkGlobalHeader);

let WinkIcon = class WinkIcon {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkIcon_Factory(t) {
    return new (t || WinkIcon)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkIcon,
    selectors: [["wink-icon"]],
    inputs: {
      appearance: "appearance",
      icon: "icon",
      size: "size"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkIcon_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkIcon = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_icon_js__WEBPACK_IMPORTED_MODULE_14__.defineCustomElement,
  inputs: ['appearance', 'icon', 'size']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkIcon);

let WinkImg = class WinkImg {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkImg_Factory(t) {
    return new (t || WinkImg)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkImg,
    selectors: [["wink-img"]],
    inputs: {
      alt: "alt",
      loading: "loading",
      srcDesktop: "srcDesktop",
      srcMobile: "srcMobile",
      srcTablet: "srcTablet"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkImg_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkImg = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_img_js__WEBPACK_IMPORTED_MODULE_15__.defineCustomElement,
  inputs: ['alt', 'loading', 'srcDesktop', 'srcMobile', 'srcTablet']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkImg);

let WinkIndicator = class WinkIndicator {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkIndicator_Factory(t) {
    return new (t || WinkIndicator)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkIndicator,
    selectors: [["wink-indicator"]],
    inputs: {
      direction: "direction",
      size: "size"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkIndicator_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkIndicator = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_indicator_js__WEBPACK_IMPORTED_MODULE_16__.defineCustomElement,
  inputs: ['direction', 'size']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkIndicator);

let WinkInput = class WinkInput {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    (0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.proxyOutputs)(this, this.el, ['valueChanged']);
  }
  static ɵfac = function WinkInput_Factory(t) {
    return new (t || WinkInput)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkInput,
    selectors: [["wink-input"]],
    inputs: {
      appearance: "appearance",
      autocomplete: "autocomplete",
      enterkeyhintOption: "enterkeyhintOption",
      error: "error",
      helper: "helper",
      iconLeft: "iconLeft",
      iconRight: "iconRight",
      inputId: "inputId",
      inputModeOption: "inputModeOption",
      isAutofocused: "isAutofocused",
      isDisabled: "isDisabled",
      isReadonly: "isReadonly",
      isRequired: "isRequired",
      label: "label",
      maxValue: "maxValue",
      minValue: "minValue",
      name: "name",
      optionalText: "optionalText",
      placeholder: "placeholder",
      postfixValue: "postfixValue",
      prefixValue: "prefixValue",
      size: "size",
      step: "step",
      type: "type",
      value: "value"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkInput_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkInput = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_input_js__WEBPACK_IMPORTED_MODULE_17__.defineCustomElement,
  inputs: ['appearance', 'autocomplete', 'enterkeyhintOption', 'error', 'helper', 'iconLeft', 'iconRight', 'inputId', 'inputModeOption', 'isAutofocused', 'isDisabled', 'isReadonly', 'isRequired', 'label', 'maxValue', 'minValue', 'name', 'optionalText', 'placeholder', 'postfixValue', 'prefixValue', 'size', 'step', 'type', 'value'],
  methods: ['setValidation']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkInput);

let WinkIntentBar = class WinkIntentBar {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkIntentBar_Factory(t) {
    return new (t || WinkIntentBar)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkIntentBar,
    selectors: [["wink-intent-bar"]],
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkIntentBar_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkIntentBar = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_intent_bar_js__WEBPACK_IMPORTED_MODULE_18__.defineCustomElement
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkIntentBar);

let WinkLink = class WinkLink {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkLink_Factory(t) {
    return new (t || WinkLink)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkLink,
    selectors: [["wink-link"]],
    inputs: {
      appearance: "appearance",
      href: "href",
      icon: "icon",
      iconAppearance: "iconAppearance",
      iconPosition: "iconPosition",
      isDisabled: "isDisabled",
      size: "size",
      target: "target"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkLink_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkLink = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_link_js__WEBPACK_IMPORTED_MODULE_19__.defineCustomElement,
  inputs: ['appearance', 'href', 'icon', 'iconAppearance', 'iconPosition', 'isDisabled', 'size', 'target']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkLink);

let WinkLogo = class WinkLogo {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkLogo_Factory(t) {
    return new (t || WinkLogo)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkLogo,
    selectors: [["wink-logo"]],
    inputs: {
      alt: "alt",
      appearance: "appearance",
      href: "href",
      target: "target"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkLogo_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkLogo = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_logo_js__WEBPACK_IMPORTED_MODULE_20__.defineCustomElement,
  inputs: ['alt', 'appearance', 'href', 'target']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkLogo);

let WinkMainNavigation = class WinkMainNavigation {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
    (0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.proxyOutputs)(this, this.el, ['mainNavigationItemClicked']);
  }
  static ɵfac = function WinkMainNavigation_Factory(t) {
    return new (t || WinkMainNavigation)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkMainNavigation,
    selectors: [["wink-main-navigation"]],
    inputs: {
      menuItems: "menuItems"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkMainNavigation_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkMainNavigation = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_main_navigation_js__WEBPACK_IMPORTED_MODULE_21__.defineCustomElement,
  inputs: ['menuItems']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkMainNavigation);

let WinkNavigationList = class WinkNavigationList {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkNavigationList_Factory(t) {
    return new (t || WinkNavigationList)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkNavigationList,
    selectors: [["wink-navigation-list"]],
    inputs: {
      hasBoldLinks: "hasBoldLinks",
      listTitle: "listTitle"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkNavigationList_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkNavigationList = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_navigation_list_js__WEBPACK_IMPORTED_MODULE_22__.defineCustomElement,
  inputs: ['hasBoldLinks', 'listTitle']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkNavigationList);

let WinkNavigationListItem = class WinkNavigationListItem {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkNavigationListItem_Factory(t) {
    return new (t || WinkNavigationListItem)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkNavigationListItem,
    selectors: [["wink-navigation-list-item"]],
    inputs: {
      href: "href",
      target: "target"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkNavigationListItem_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkNavigationListItem = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_navigation_list_item_js__WEBPACK_IMPORTED_MODULE_23__.defineCustomElement,
  inputs: ['href', 'target']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkNavigationListItem);

let WinkNotification = class WinkNotification {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkNotification_Factory(t) {
    return new (t || WinkNotification)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkNotification,
    selectors: [["wink-notification"]],
    inputs: {
      appearance: "appearance",
      hasCloseIcon: "hasCloseIcon"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkNotification_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkNotification = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_notification_js__WEBPACK_IMPORTED_MODULE_24__.defineCustomElement,
  inputs: ['appearance', 'hasCloseIcon']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkNotification);

let WinkParagraph = class WinkParagraph {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkParagraph_Factory(t) {
    return new (t || WinkParagraph)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkParagraph,
    selectors: [["wink-paragraph"]],
    inputs: {
      appearance: "appearance",
      size: "size"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkParagraph_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkParagraph = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_paragraph_js__WEBPACK_IMPORTED_MODULE_25__.defineCustomElement,
  inputs: ['appearance', 'size']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkParagraph);

let WinkPricing = class WinkPricing {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkPricing_Factory(t) {
    return new (t || WinkPricing)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkPricing,
    selectors: [["wink-pricing"]],
    inputs: {
      alignment: "alignment",
      annotation: "annotation",
      appearance: "appearance",
      duration: "duration",
      frequency: "frequency",
      price: "price",
      priceStrikethrough: "priceStrikethrough",
      startingFrom: "startingFrom"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkPricing_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkPricing = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_pricing_js__WEBPACK_IMPORTED_MODULE_26__.defineCustomElement,
  inputs: ['alignment', 'annotation', 'appearance', 'duration', 'frequency', 'price', 'priceStrikethrough', 'startingFrom']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkPricing);

let WinkRadioButton = class WinkRadioButton {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkRadioButton_Factory(t) {
    return new (t || WinkRadioButton)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkRadioButton,
    selectors: [["wink-radio-button"]],
    inputs: {
      checked: "checked",
      disabled: "disabled",
      error: "error",
      helper: "helper",
      label: "label",
      name: "name",
      radioButtonId: "radioButtonId"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkRadioButton_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkRadioButton = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_radio_button_js__WEBPACK_IMPORTED_MODULE_27__.defineCustomElement,
  inputs: ['checked', 'disabled', 'error', 'helper', 'label', 'name', 'radioButtonId']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkRadioButton);

let WinkRadioGroup = class WinkRadioGroup {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkRadioGroup_Factory(t) {
    return new (t || WinkRadioGroup)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkRadioGroup,
    selectors: [["wink-radio-group"]],
    inputs: {
      direction: "direction",
      error: "error",
      helper: "helper",
      isRequired: "isRequired",
      label: "label",
      optionalText: "optionalText"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkRadioGroup_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkRadioGroup = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_radio_group_js__WEBPACK_IMPORTED_MODULE_28__.defineCustomElement,
  inputs: ['direction', 'error', 'helper', 'isRequired', 'label', 'optionalText'],
  methods: ['setValidation']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkRadioGroup);

let WinkRangeSlider = class WinkRangeSlider {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkRangeSlider_Factory(t) {
    return new (t || WinkRangeSlider)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkRangeSlider,
    selectors: [["wink-range-slider"]],
    inputs: {
      bottomValue: "bottomValue",
      errorMessage: "errorMessage",
      helper: "helper",
      label: "label",
      maxValue: "maxValue",
      minValue: "minValue",
      showInput: "showInput",
      showValues: "showValues",
      sliderId: "sliderId",
      sliderType: "sliderType",
      step: "step",
      value: "value"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkRangeSlider_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkRangeSlider = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_range_slider_js__WEBPACK_IMPORTED_MODULE_29__.defineCustomElement,
  inputs: ['bottomValue', 'errorMessage', 'helper', 'label', 'maxValue', 'minValue', 'showInput', 'showValues', 'sliderId', 'sliderType', 'step', 'value'],
  methods: ['showFromValue', 'showToValue', 'getDragValue']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkRangeSlider);

let WinkSelect = class WinkSelect {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkSelect_Factory(t) {
    return new (t || WinkSelect)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkSelect,
    selectors: [["wink-select"]],
    inputs: {
      error: "error",
      helper: "helper",
      isDisabled: "isDisabled",
      isRequired: "isRequired",
      label: "label",
      placeholder: "placeholder",
      selectId: "selectId",
      selectName: "selectName",
      value: "value"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkSelect_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkSelect = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_select_js__WEBPACK_IMPORTED_MODULE_30__.defineCustomElement,
  inputs: ['error', 'helper', 'isDisabled', 'isRequired', 'label', 'placeholder', 'selectId', 'selectName', 'value']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkSelect);

let WinkSheet = class WinkSheet {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkSheet_Factory(t) {
    return new (t || WinkSheet)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkSheet,
    selectors: [["wink-sheet"]],
    inputs: {
      dashboard: "dashboard",
      isVisible: "isVisible",
      multipage: "multipage"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkSheet_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkSheet = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_sheet_js__WEBPACK_IMPORTED_MODULE_31__.defineCustomElement,
  inputs: ['dashboard', 'isVisible', 'multipage'],
  methods: ['open', 'close', 'nextPage']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkSheet);

let WinkSpacer = class WinkSpacer {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkSpacer_Factory(t) {
    return new (t || WinkSpacer)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkSpacer,
    selectors: [["wink-spacer"]],
    inputs: {
      size: "size"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkSpacer_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkSpacer = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_spacer_js__WEBPACK_IMPORTED_MODULE_32__.defineCustomElement,
  inputs: ['size']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkSpacer);

let WinkStack = class WinkStack {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkStack_Factory(t) {
    return new (t || WinkStack)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkStack,
    selectors: [["wink-stack"]],
    inputs: {
      alignItems: "alignItems",
      col: "col",
      direction: "direction",
      gap: "gap",
      justifyContent: "justifyContent",
      wrap: "wrap"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkStack_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkStack = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_stack_js__WEBPACK_IMPORTED_MODULE_33__.defineCustomElement,
  inputs: ['alignItems', 'col', 'direction', 'gap', 'justifyContent', 'wrap']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkStack);

let WinkTabs = class WinkTabs {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkTabs_Factory(t) {
    return new (t || WinkTabs)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkTabs,
    selectors: [["wink-tabs"]],
    inputs: {
      appearance: "appearance"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkTabs_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkTabs = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_tabs_js__WEBPACK_IMPORTED_MODULE_34__.defineCustomElement,
  inputs: ['appearance']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkTabs);

let WinkTextarea = class WinkTextarea {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkTextarea_Factory(t) {
    return new (t || WinkTextarea)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkTextarea,
    selectors: [["wink-textarea"]],
    inputs: {
      autocomplete: "autocomplete",
      enterkeyhintOption: "enterkeyhintOption",
      error: "error",
      helper: "helper",
      isDisabled: "isDisabled",
      isRequired: "isRequired",
      label: "label",
      maxlength: "maxlength",
      minlength: "minlength",
      name: "name",
      placeholder: "placeholder",
      rows: "rows",
      textareaId: "textareaId"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkTextarea_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkTextarea = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_textarea_js__WEBPACK_IMPORTED_MODULE_35__.defineCustomElement,
  inputs: ['autocomplete', 'enterkeyhintOption', 'error', 'helper', 'isDisabled', 'isRequired', 'label', 'maxlength', 'minlength', 'name', 'placeholder', 'rows', 'textareaId']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkTextarea);

let WinkTitle = class WinkTitle {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkTitle_Factory(t) {
    return new (t || WinkTitle)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkTitle,
    selectors: [["wink-title"]],
    inputs: {
      htmlTag: "htmlTag",
      noSeo: "noSeo",
      spacingY: "spacingY",
      text: "text"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkTitle_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkTitle = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_title_js__WEBPACK_IMPORTED_MODULE_36__.defineCustomElement,
  inputs: ['htmlTag', 'noSeo', 'spacingY', 'text']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkTitle);

let WinkToast = class WinkToast {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkToast_Factory(t) {
    return new (t || WinkToast)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkToast,
    selectors: [["wink-toast"]],
    inputs: {
      appearance: "appearance",
      currentTheme: "currentTheme",
      duration: "duration",
      href: "href",
      isOpen: "isOpen",
      linkText: "linkText",
      target: "target",
      text: "text",
      theme: "theme"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkToast_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkToast = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_toast_js__WEBPACK_IMPORTED_MODULE_37__.defineCustomElement,
  inputs: ['appearance', 'currentTheme', 'duration', 'href', 'isOpen', 'linkText', 'target', 'text', 'theme']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkToast);

let WinkToaster = class WinkToaster {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkToaster_Factory(t) {
    return new (t || WinkToaster)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkToaster,
    selectors: [["wink-toaster"]],
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkToaster_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkToaster = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_toaster_js__WEBPACK_IMPORTED_MODULE_38__.defineCustomElement,
  methods: ['winkCreateToast']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkToaster);

let WinkToggleSwitch = class WinkToggleSwitch {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkToggleSwitch_Factory(t) {
    return new (t || WinkToggleSwitch)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkToggleSwitch,
    selectors: [["wink-toggle-switch"]],
    inputs: {
      alignment: "alignment",
      checked: "checked",
      disabled: "disabled",
      label: "label",
      toggleSwitchId: "toggleSwitchId",
      toggleSwitchName: "toggleSwitchName"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkToggleSwitch_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkToggleSwitch = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_toggle_switch_js__WEBPACK_IMPORTED_MODULE_39__.defineCustomElement,
  inputs: ['alignment', 'checked', 'disabled', 'label', 'toggleSwitchId', 'toggleSwitchName']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkToggleSwitch);

let WinkValidationMessage = class WinkValidationMessage {
  z;
  el;
  constructor(c, r, z) {
    this.z = z;
    c.detach();
    this.el = r.nativeElement;
  }
  static ɵfac = function WinkValidationMessage_Factory(t) {
    return new (t || WinkValidationMessage)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
  };
  static ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
    type: WinkValidationMessage,
    selectors: [["wink-validation-message"]],
    inputs: {
      message: "message",
      type: "type"
    },
    standalone: true,
    features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵStandaloneFeature"]],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function WinkValidationMessage_Template(rf, ctx) {
      if (rf & 1) {
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();
        _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
};
WinkValidationMessage = __decorate([(0,_angular_component_lib_utils__WEBPACK_IMPORTED_MODULE_41__.ProxyCmp)({
  defineCustomElementFn: _telenet_wink_core_components_wink_validation_message_js__WEBPACK_IMPORTED_MODULE_40__.defineCustomElement,
  inputs: ['message', 'type']
}), __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef, _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone])], WinkValidationMessage);


/***/ }),

/***/ 86016:
/*!**********************************************!*\
  !*** ./libs/foundation/wink/ng/src/index.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DIRECTIVES: () => (/* reexport safe */ _generated__WEBPACK_IMPORTED_MODULE_0__.DIRECTIVES),
/* harmony export */   WinkAccordion: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkAccordion),
/* harmony export */   WinkAnimation: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkAnimation),
/* harmony export */   WinkAvatar: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkAvatar),
/* harmony export */   WinkBadge: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkBadge),
/* harmony export */   WinkButton: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkButton),
/* harmony export */   WinkCheckBox: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkCheckBox),
/* harmony export */   WinkCheckBoxGroup: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkCheckBoxGroup),
/* harmony export */   WinkColumnCount: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkColumnCount),
/* harmony export */   WinkCustomerOrientation: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkCustomerOrientation),
/* harmony export */   WinkDropdownMenu: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkDropdownMenu),
/* harmony export */   WinkFlyout: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkFlyout),
/* harmony export */   WinkFormLabel: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkFormLabel),
/* harmony export */   WinkGlobalHeader: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkGlobalHeader),
/* harmony export */   WinkIcon: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkIcon),
/* harmony export */   WinkImg: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkImg),
/* harmony export */   WinkIndicator: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkIndicator),
/* harmony export */   WinkInput: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkInput),
/* harmony export */   WinkIntentBar: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkIntentBar),
/* harmony export */   WinkLink: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkLink),
/* harmony export */   WinkLogo: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkLogo),
/* harmony export */   WinkMainNavigation: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkMainNavigation),
/* harmony export */   WinkNavigationList: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkNavigationList),
/* harmony export */   WinkNavigationListItem: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkNavigationListItem),
/* harmony export */   WinkNotification: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkNotification),
/* harmony export */   WinkParagraph: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkParagraph),
/* harmony export */   WinkPricing: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkPricing),
/* harmony export */   WinkRadioButton: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkRadioButton),
/* harmony export */   WinkRadioGroup: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkRadioGroup),
/* harmony export */   WinkRangeSlider: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkRangeSlider),
/* harmony export */   WinkSelect: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkSelect),
/* harmony export */   WinkSheet: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkSheet),
/* harmony export */   WinkSpacer: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkSpacer),
/* harmony export */   WinkStack: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkStack),
/* harmony export */   WinkTabs: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkTabs),
/* harmony export */   WinkTextarea: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkTextarea),
/* harmony export */   WinkTitle: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkTitle),
/* harmony export */   WinkToast: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkToast),
/* harmony export */   WinkToaster: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkToaster),
/* harmony export */   WinkToggleSwitch: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkToggleSwitch),
/* harmony export */   WinkValidationMessage: () => (/* reexport safe */ _generated_proxies__WEBPACK_IMPORTED_MODULE_1__.WinkValidationMessage)
/* harmony export */ });
/* harmony import */ var _generated__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generated */ 60561);
/* harmony import */ var _generated_proxies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generated/proxies */ 85786);



/***/ }),

/***/ 8071:
/*!***********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/animation.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Animation),
/* harmony export */   B: () => (/* binding */ Button),
/* harmony export */   a: () => (/* binding */ defineCustomElement$1),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _targets_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./targets.types.js */ 83638);
/* harmony import */ var _button_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./button.types.js */ 5074);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon.js */ 45477);





const ANIMATION_STATES = {
  play: 'play',
  pauze: 'pause',
  stop: 'stop'
};
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var lottie$1 = {
  exports: {}
};
(function (module, exports) {
  typeof navigator !== "undefined" && function (global, factory) {
    module.exports = factory();
  }(commonjsGlobal, function () {
    var svgNS = 'http://www.w3.org/2000/svg';
    var locationHref = '';
    var _useWebWorker = false;
    var initialDefaultFrame = -999999;
    var setWebWorker = function setWebWorker(flag) {
      _useWebWorker = !!flag;
    };
    var getWebWorker = function getWebWorker() {
      return _useWebWorker;
    };
    var setLocationHref = function setLocationHref(value) {
      locationHref = value;
    };
    var getLocationHref = function getLocationHref() {
      return locationHref;
    };
    function createTag(type) {
      // return {appendChild:function(){},setAttribute:function(){},style:{}}
      return document.createElement(type);
    }
    function extendPrototype(sources, destination) {
      var i;
      var len = sources.length;
      var sourcePrototype;
      for (i = 0; i < len; i += 1) {
        sourcePrototype = sources[i].prototype;
        for (var attr in sourcePrototype) {
          if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
        }
      }
    }
    function getDescriptor(object, prop) {
      return Object.getOwnPropertyDescriptor(object, prop);
    }
    function createProxyFunction(prototype) {
      function ProxyFunction() {}
      ProxyFunction.prototype = prototype;
      return ProxyFunction;
    }

    // import Howl from '../../3rd_party/howler';
    var audioControllerFactory = function () {
      function AudioController(audioFactory) {
        this.audios = [];
        this.audioFactory = audioFactory;
        this._volume = 1;
        this._isMuted = false;
      }
      AudioController.prototype = {
        addAudio: function addAudio(audio) {
          this.audios.push(audio);
        },
        pause: function pause() {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].pause();
          }
        },
        resume: function resume() {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].resume();
          }
        },
        setRate: function setRate(rateValue) {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].setRate(rateValue);
          }
        },
        createAudio: function createAudio(assetPath) {
          if (this.audioFactory) {
            return this.audioFactory(assetPath);
          }
          if (window.Howl) {
            return new window.Howl({
              src: [assetPath]
            });
          }
          return {
            isPlaying: false,
            play: function play() {
              this.isPlaying = true;
            },
            seek: function seek() {
              this.isPlaying = false;
            },
            playing: function playing() {},
            rate: function rate() {},
            setVolume: function setVolume() {}
          };
        },
        setAudioFactory: function setAudioFactory(audioFactory) {
          this.audioFactory = audioFactory;
        },
        setVolume: function setVolume(value) {
          this._volume = value;
          this._updateVolume();
        },
        mute: function mute() {
          this._isMuted = true;
          this._updateVolume();
        },
        unmute: function unmute() {
          this._isMuted = false;
          this._updateVolume();
        },
        getVolume: function getVolume() {
          return this._volume;
        },
        _updateVolume: function _updateVolume() {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
          }
        }
      };
      return function () {
        return new AudioController();
      };
    }();
    var createTypedArray = function () {
      function createRegularArray(type, len) {
        var i = 0;
        var arr = [];
        var value;
        switch (type) {
          case 'int16':
          case 'uint8c':
            value = 1;
            break;
          default:
            value = 1.1;
            break;
        }
        for (i = 0; i < len; i += 1) {
          arr.push(value);
        }
        return arr;
      }
      function createTypedArrayFactory(type, len) {
        if (type === 'float32') {
          return new Float32Array(len);
        }
        if (type === 'int16') {
          return new Int16Array(len);
        }
        if (type === 'uint8c') {
          return new Uint8ClampedArray(len);
        }
        return createRegularArray(type, len);
      }
      if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
        return createTypedArrayFactory;
      }
      return createRegularArray;
    }();
    function createSizedArray(len) {
      return Array.apply(null, {
        length: len
      });
    }
    function _typeof$6(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$6 = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof$6 = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof$6(obj);
    }
    var subframeEnabled = true;
    var expressionsPlugin = null;
    var expressionsInterfaces = null;
    var idPrefix$1 = '';
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    var bmPow = Math.pow;
    var bmSqrt = Math.sqrt;
    var bmFloor = Math.floor;
    var bmMax = Math.max;
    var bmMin = Math.min;
    var BMMath = {};
    (function () {
      var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
      var i;
      var len = propertyNames.length;
      for (i = 0; i < len; i += 1) {
        BMMath[propertyNames[i]] = Math[propertyNames[i]];
      }
    })();
    BMMath.random = Math.random;
    BMMath.abs = function (val) {
      var tOfVal = _typeof$6(val);
      if (tOfVal === 'object' && val.length) {
        var absArr = createSizedArray(val.length);
        var i;
        var len = val.length;
        for (i = 0; i < len; i += 1) {
          absArr[i] = Math.abs(val[i]);
        }
        return absArr;
      }
      return Math.abs(val);
    };
    var defaultCurveSegments = 150;
    var degToRads = Math.PI / 180;
    var roundCorner = 0.5519;
    function styleDiv(element) {
      element.style.position = 'absolute';
      element.style.top = 0;
      element.style.left = 0;
      element.style.display = 'block';
      element.style.transformOrigin = '0 0';
      element.style.webkitTransformOrigin = '0 0';
      element.style.backfaceVisibility = 'visible';
      element.style.webkitBackfaceVisibility = 'visible';
      element.style.transformStyle = 'preserve-3d';
      element.style.webkitTransformStyle = 'preserve-3d';
      element.style.mozTransformStyle = 'preserve-3d';
    }
    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
      this.type = type;
      this.currentTime = currentTime;
      this.totalTime = totalTime;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMCompleteEvent(type, frameMultiplier) {
      this.type = type;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
      this.type = type;
      this.currentLoop = currentLoop;
      this.totalLoops = totalLoops;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }
    function BMSegmentStartEvent(type, firstFrame, totalFrames) {
      this.type = type;
      this.firstFrame = firstFrame;
      this.totalFrames = totalFrames;
    }
    function BMDestroyEvent(type, target) {
      this.type = type;
      this.target = target;
    }
    function BMRenderFrameErrorEvent(nativeError, currentTime) {
      this.type = 'renderFrameError';
      this.nativeError = nativeError;
      this.currentTime = currentTime;
    }
    function BMConfigErrorEvent(nativeError) {
      this.type = 'configError';
      this.nativeError = nativeError;
    }
    var createElementID = function () {
      var _count = 0;
      return function createID() {
        _count += 1;
        return idPrefix$1 + '__lottie_element_' + _count;
      };
    }();
    function HSVtoRGB(h, s, v) {
      var r;
      var g;
      var b;
      var i;
      var f;
      var p;
      var q;
      var t;
      i = Math.floor(h * 6);
      f = h * 6 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      switch (i % 6) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      return [r, g, b];
    }
    function RGBtoHSV(r, g, b) {
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var d = max - min;
      var h;
      var s = max === 0 ? 0 : d / max;
      var v = max / 255;
      switch (max) {
        case min:
          h = 0;
          break;
        case r:
          h = g - b + d * (g < b ? 6 : 0);
          h /= 6 * d;
          break;
        case g:
          h = b - r + d * 2;
          h /= 6 * d;
          break;
        case b:
          h = r - g + d * 4;
          h /= 6 * d;
          break;
      }
      return [h, s, v];
    }
    function addSaturationToRGB(color, offset) {
      var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
      hsv[1] += offset;
      if (hsv[1] > 1) {
        hsv[1] = 1;
      } else if (hsv[1] <= 0) {
        hsv[1] = 0;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    function addBrightnessToRGB(color, offset) {
      var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
      hsv[2] += offset;
      if (hsv[2] > 1) {
        hsv[2] = 1;
      } else if (hsv[2] < 0) {
        hsv[2] = 0;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    function addHueToRGB(color, offset) {
      var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
      hsv[0] += offset / 360;
      if (hsv[0] > 1) {
        hsv[0] -= 1;
      } else if (hsv[0] < 0) {
        hsv[0] += 1;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }
    var rgbToHex = function () {
      var colorMap = [];
      var i;
      var hex;
      for (i = 0; i < 256; i += 1) {
        hex = i.toString(16);
        colorMap[i] = hex.length === 1 ? '0' + hex : hex;
      }
      return function (r, g, b) {
        if (r < 0) {
          r = 0;
        }
        if (g < 0) {
          g = 0;
        }
        if (b < 0) {
          b = 0;
        }
        return '#' + colorMap[r] + colorMap[g] + colorMap[b];
      };
    }();
    var setSubframeEnabled = function setSubframeEnabled(flag) {
      subframeEnabled = !!flag;
    };
    var getSubframeEnabled = function getSubframeEnabled() {
      return subframeEnabled;
    };
    var setExpressionsPlugin = function setExpressionsPlugin(value) {
      expressionsPlugin = value;
    };
    var getExpressionsPlugin = function getExpressionsPlugin() {
      return expressionsPlugin;
    };
    var setExpressionInterfaces = function setExpressionInterfaces(value) {
      expressionsInterfaces = value;
    };
    var getExpressionInterfaces = function getExpressionInterfaces() {
      return expressionsInterfaces;
    };
    var setDefaultCurveSegments = function setDefaultCurveSegments(value) {
      defaultCurveSegments = value;
    };
    var getDefaultCurveSegments = function getDefaultCurveSegments() {
      return defaultCurveSegments;
    };
    var setIdPrefix = function setIdPrefix(value) {
      idPrefix$1 = value;
    };
    function createNS(type) {
      // return {appendChild:function(){},setAttribute:function(){},style:{}}
      return document.createElementNS(svgNS, type);
    }
    function _typeof$5(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$5 = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof$5 = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof$5(obj);
    }
    var dataManager = function () {
      var _counterId = 1;
      var processes = [];
      var workerFn;
      var workerInstance;
      var workerProxy = {
        onmessage: function onmessage() {},
        postMessage: function postMessage(path) {
          workerFn({
            data: path
          });
        }
      };
      var _workerSelf = {
        postMessage: function postMessage(data) {
          workerProxy.onmessage({
            data: data
          });
        }
      };
      function createWorker(fn) {
        if (window.Worker && window.Blob && getWebWorker()) {
          var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], {
            type: 'text/javascript'
          }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });

          var url = URL.createObjectURL(blob);
          return new Worker(url);
        }
        workerFn = fn;
        return workerProxy;
      }
      function setupWorker() {
        if (!workerInstance) {
          workerInstance = createWorker(function workerStart(e) {
            function dataFunctionManager() {
              function completeLayers(layers, comps) {
                var layerData;
                var i;
                var len = layers.length;
                var j;
                var jLen;
                var k;
                var kLen;
                for (i = 0; i < len; i += 1) {
                  layerData = layers[i];
                  if ('ks' in layerData && !layerData.completed) {
                    layerData.completed = true;
                    if (layerData.hasMask) {
                      var maskProps = layerData.masksProperties;
                      jLen = maskProps.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (maskProps[j].pt.k.i) {
                          convertPathsToAbsoluteValues(maskProps[j].pt.k);
                        } else {
                          kLen = maskProps[j].pt.k.length;
                          for (k = 0; k < kLen; k += 1) {
                            if (maskProps[j].pt.k[k].s) {
                              convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                            }
                            if (maskProps[j].pt.k[k].e) {
                              convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                            }
                          }
                        }
                      }
                    }
                    if (layerData.ty === 0) {
                      layerData.layers = findCompLayers(layerData.refId, comps);
                      completeLayers(layerData.layers, comps);
                    } else if (layerData.ty === 4) {
                      completeShapes(layerData.shapes);
                    } else ;
                  }
                }
              }
              function completeChars(chars, assets) {
                if (chars) {
                  var i = 0;
                  var len = chars.length;
                  for (i = 0; i < len; i += 1) {
                    if (chars[i].t === 1) {
                      // var compData = findComp(chars[i].data.refId, assets);
                      chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;
                      // chars[i].data.op = 99999;
                      // chars[i].data.st = 0;
                      // chars[i].data.sr = 1;
                      // chars[i].w = compData.w;
                      // chars[i].data.ks = {
                      //   a: { k: [0, 0, 0], a: 0 },
                      //   p: { k: [0, -compData.h, 0], a: 0 },
                      //   r: { k: 0, a: 0 },
                      //   s: { k: [100, 100], a: 0 },
                      //   o: { k: 100, a: 0 },
                      // };

                      completeLayers(chars[i].data.layers, assets);
                    }
                  }
                }
              }
              function findComp(id, comps) {
                var i = 0;
                var len = comps.length;
                while (i < len) {
                  if (comps[i].id === id) {
                    return comps[i];
                  }
                  i += 1;
                }
                return null;
              }
              function findCompLayers(id, comps) {
                var comp = findComp(id, comps);
                if (comp) {
                  if (!comp.layers.__used) {
                    comp.layers.__used = true;
                    return comp.layers;
                  }
                  return JSON.parse(JSON.stringify(comp.layers));
                }
                return null;
              }
              function completeShapes(arr) {
                var i;
                var len = arr.length;
                var j;
                var jLen;
                for (i = len - 1; i >= 0; i -= 1) {
                  if (arr[i].ty === 'sh') {
                    if (arr[i].ks.k.i) {
                      convertPathsToAbsoluteValues(arr[i].ks.k);
                    } else {
                      jLen = arr[i].ks.k.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (arr[i].ks.k[j].s) {
                          convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                        }
                        if (arr[i].ks.k[j].e) {
                          convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                        }
                      }
                    }
                  } else if (arr[i].ty === 'gr') {
                    completeShapes(arr[i].it);
                  }
                }
              }
              function convertPathsToAbsoluteValues(path) {
                var i;
                var len = path.i.length;
                for (i = 0; i < len; i += 1) {
                  path.i[i][0] += path.v[i][0];
                  path.i[i][1] += path.v[i][1];
                  path.o[i][0] += path.v[i][0];
                  path.o[i][1] += path.v[i][1];
                }
              }
              function checkVersion(minimum, animVersionString) {
                var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
                if (minimum[0] > animVersion[0]) {
                  return true;
                }
                if (animVersion[0] > minimum[0]) {
                  return false;
                }
                if (minimum[1] > animVersion[1]) {
                  return true;
                }
                if (animVersion[1] > minimum[1]) {
                  return false;
                }
                if (minimum[2] > animVersion[2]) {
                  return true;
                }
                if (animVersion[2] > minimum[2]) {
                  return false;
                }
                return null;
              }
              var checkText = function () {
                var minimumVersion = [4, 4, 14];
                function updateTextLayer(textLayer) {
                  var documentData = textLayer.t.d;
                  textLayer.t.d = {
                    k: [{
                      s: documentData,
                      t: 0
                    }]
                  };
                }
                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 5) {
                      updateTextLayer(layers[i]);
                    }
                  }
                }
                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              var checkChars = function () {
                var minimumVersion = [4, 7, 99];
                return function (animationData) {
                  if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                    var i;
                    var len = animationData.chars.length;
                    for (i = 0; i < len; i += 1) {
                      var charData = animationData.chars[i];
                      if (charData.data && charData.data.shapes) {
                        completeShapes(charData.data.shapes);
                        charData.data.ip = 0;
                        charData.data.op = 99999;
                        charData.data.st = 0;
                        charData.data.sr = 1;
                        charData.data.ks = {
                          p: {
                            k: [0, 0],
                            a: 0
                          },
                          s: {
                            k: [100, 100],
                            a: 0
                          },
                          a: {
                            k: [0, 0],
                            a: 0
                          },
                          r: {
                            k: 0,
                            a: 0
                          },
                          o: {
                            k: 100,
                            a: 0
                          }
                        };
                        if (!animationData.chars[i].t) {
                          charData.data.shapes.push({
                            ty: 'no'
                          });
                          charData.data.shapes[0].it.push({
                            p: {
                              k: [0, 0],
                              a: 0
                            },
                            s: {
                              k: [100, 100],
                              a: 0
                            },
                            a: {
                              k: [0, 0],
                              a: 0
                            },
                            r: {
                              k: 0,
                              a: 0
                            },
                            o: {
                              k: 100,
                              a: 0
                            },
                            sk: {
                              k: 0,
                              a: 0
                            },
                            sa: {
                              k: 0,
                              a: 0
                            },
                            ty: 'tr'
                          });
                        }
                      }
                    }
                  }
                };
              }();
              var checkPathProperties = function () {
                var minimumVersion = [5, 7, 15];
                function updateTextLayer(textLayer) {
                  var pathData = textLayer.t.p;
                  if (typeof pathData.a === 'number') {
                    pathData.a = {
                      a: 0,
                      k: pathData.a
                    };
                  }
                  if (typeof pathData.p === 'number') {
                    pathData.p = {
                      a: 0,
                      k: pathData.p
                    };
                  }
                  if (typeof pathData.r === 'number') {
                    pathData.r = {
                      a: 0,
                      k: pathData.r
                    };
                  }
                }
                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 5) {
                      updateTextLayer(layers[i]);
                    }
                  }
                }
                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              var checkColors = function () {
                var minimumVersion = [4, 1, 9];
                function iterateShapes(shapes) {
                  var i;
                  var len = shapes.length;
                  var j;
                  var jLen;
                  for (i = 0; i < len; i += 1) {
                    if (shapes[i].ty === 'gr') {
                      iterateShapes(shapes[i].it);
                    } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
                      if (shapes[i].c.k && shapes[i].c.k[0].i) {
                        jLen = shapes[i].c.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (shapes[i].c.k[j].s) {
                            shapes[i].c.k[j].s[0] /= 255;
                            shapes[i].c.k[j].s[1] /= 255;
                            shapes[i].c.k[j].s[2] /= 255;
                            shapes[i].c.k[j].s[3] /= 255;
                          }
                          if (shapes[i].c.k[j].e) {
                            shapes[i].c.k[j].e[0] /= 255;
                            shapes[i].c.k[j].e[1] /= 255;
                            shapes[i].c.k[j].e[2] /= 255;
                            shapes[i].c.k[j].e[3] /= 255;
                          }
                        }
                      } else {
                        shapes[i].c.k[0] /= 255;
                        shapes[i].c.k[1] /= 255;
                        shapes[i].c.k[2] /= 255;
                        shapes[i].c.k[3] /= 255;
                      }
                    }
                  }
                }
                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 4) {
                      iterateShapes(layers[i].shapes);
                    }
                  }
                }
                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              var checkShapes = function () {
                var minimumVersion = [4, 4, 18];
                function completeClosingShapes(arr) {
                  var i;
                  var len = arr.length;
                  var j;
                  var jLen;
                  for (i = len - 1; i >= 0; i -= 1) {
                    if (arr[i].ty === 'sh') {
                      if (arr[i].ks.k.i) {
                        arr[i].ks.k.c = arr[i].closed;
                      } else {
                        jLen = arr[i].ks.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (arr[i].ks.k[j].s) {
                            arr[i].ks.k[j].s[0].c = arr[i].closed;
                          }
                          if (arr[i].ks.k[j].e) {
                            arr[i].ks.k[j].e[0].c = arr[i].closed;
                          }
                        }
                      }
                    } else if (arr[i].ty === 'gr') {
                      completeClosingShapes(arr[i].it);
                    }
                  }
                }
                function iterateLayers(layers) {
                  var layerData;
                  var i;
                  var len = layers.length;
                  var j;
                  var jLen;
                  var k;
                  var kLen;
                  for (i = 0; i < len; i += 1) {
                    layerData = layers[i];
                    if (layerData.hasMask) {
                      var maskProps = layerData.masksProperties;
                      jLen = maskProps.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (maskProps[j].pt.k.i) {
                          maskProps[j].pt.k.c = maskProps[j].cl;
                        } else {
                          kLen = maskProps[j].pt.k.length;
                          for (k = 0; k < kLen; k += 1) {
                            if (maskProps[j].pt.k[k].s) {
                              maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                            }
                            if (maskProps[j].pt.k[k].e) {
                              maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                            }
                          }
                        }
                      }
                    }
                    if (layerData.ty === 4) {
                      completeClosingShapes(layerData.shapes);
                    }
                  }
                }
                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }();
              function completeData(animationData) {
                if (animationData.__complete) {
                  return;
                }
                checkColors(animationData);
                checkText(animationData);
                checkChars(animationData);
                checkPathProperties(animationData);
                checkShapes(animationData);
                completeLayers(animationData.layers, animationData.assets);
                completeChars(animationData.chars, animationData.assets);
                animationData.__complete = true;
              }
              var moduleOb = {};
              moduleOb.completeData = completeData;
              moduleOb.checkColors = checkColors;
              moduleOb.checkChars = checkChars;
              moduleOb.checkPathProperties = checkPathProperties;
              moduleOb.checkShapes = checkShapes;
              moduleOb.completeLayers = completeLayers;
              return moduleOb;
            }
            if (!_workerSelf.dataManager) {
              _workerSelf.dataManager = dataFunctionManager();
            }
            if (!_workerSelf.assetLoader) {
              _workerSelf.assetLoader = function () {
                function formatResponse(xhr) {
                  // using typeof doubles the time of execution of this method,
                  // so if available, it's better to use the header to validate the type
                  var contentTypeHeader = xhr.getResponseHeader('content-type');
                  if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {
                    return xhr.response;
                  }
                  if (xhr.response && _typeof$5(xhr.response) === 'object') {
                    return xhr.response;
                  }
                  if (xhr.response && typeof xhr.response === 'string') {
                    return JSON.parse(xhr.response);
                  }
                  if (xhr.responseText) {
                    return JSON.parse(xhr.responseText);
                  }
                  return null;
                }
                function loadAsset(path, fullPath, callback, errorCallback) {
                  var response;
                  var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.

                  try {
                    // This crashes on Android WebView prior to KitKat
                    xhr.responseType = 'json';
                  } catch (err) {} // eslint-disable-line no-empty

                  xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                      if (xhr.status === 200) {
                        response = formatResponse(xhr);
                        callback(response);
                      } else {
                        try {
                          response = formatResponse(xhr);
                          callback(response);
                        } catch (err) {
                          if (errorCallback) {
                            errorCallback(err);
                          }
                        }
                      }
                    }
                  };
                  try {
                    // Hack to workaround banner validation
                    xhr.open(['G', 'E', 'T'].join(''), path, true);
                  } catch (error) {
                    // Hack to workaround banner validation
                    xhr.open(['G', 'E', 'T'].join(''), fullPath + '/' + path, true);
                  }
                  xhr.send();
                }
                return {
                  load: loadAsset
                };
              }();
            }
            if (e.data.type === 'loadAnimation') {
              _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
                _workerSelf.dataManager.completeData(data);
                _workerSelf.postMessage({
                  id: e.data.id,
                  payload: data,
                  status: 'success'
                });
              }, function () {
                _workerSelf.postMessage({
                  id: e.data.id,
                  status: 'error'
                });
              });
            } else if (e.data.type === 'complete') {
              var animation = e.data.animation;
              _workerSelf.dataManager.completeData(animation);
              _workerSelf.postMessage({
                id: e.data.id,
                payload: animation,
                status: 'success'
              });
            } else if (e.data.type === 'loadData') {
              _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
                _workerSelf.postMessage({
                  id: e.data.id,
                  payload: data,
                  status: 'success'
                });
              }, function () {
                _workerSelf.postMessage({
                  id: e.data.id,
                  status: 'error'
                });
              });
            }
          });
          workerInstance.onmessage = function (event) {
            var data = event.data;
            var id = data.id;
            var process = processes[id];
            processes[id] = null;
            if (data.status === 'success') {
              process.onComplete(data.payload);
            } else if (process.onError) {
              process.onError();
            }
          };
        }
      }
      function createProcess(onComplete, onError) {
        _counterId += 1;
        var id = 'processId_' + _counterId;
        processes[id] = {
          onComplete: onComplete,
          onError: onError
        };
        return id;
      }
      function loadAnimation(path, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: 'loadAnimation',
          path: path,
          fullPath: window.location.origin + window.location.pathname,
          id: processId
        });
      }
      function loadData(path, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: 'loadData',
          path: path,
          fullPath: window.location.origin + window.location.pathname,
          id: processId
        });
      }
      function completeAnimation(anim, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: 'complete',
          animation: anim,
          id: processId
        });
      }
      return {
        loadAnimation: loadAnimation,
        loadData: loadData,
        completeAnimation: completeAnimation
      };
    }();
    var ImagePreloader = function () {
      var proxyImage = function () {
        var canvas = createTag('canvas');
        canvas.width = 1;
        canvas.height = 1;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0,0,0,0)';
        ctx.fillRect(0, 0, 1, 1);
        return canvas;
      }();
      function imageLoaded() {
        this.loadedAssets += 1;
        if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
          if (this.imagesLoadedCb) {
            this.imagesLoadedCb(null);
          }
        }
      }
      function footageLoaded() {
        this.loadedFootagesCount += 1;
        if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
          if (this.imagesLoadedCb) {
            this.imagesLoadedCb(null);
          }
        }
      }
      function getAssetsPath(assetData, assetsPath, originalPath) {
        var path = '';
        if (assetData.e) {
          path = assetData.p;
        } else if (assetsPath) {
          var imagePath = assetData.p;
          if (imagePath.indexOf('images/') !== -1) {
            imagePath = imagePath.split('/')[1];
          }
          path = assetsPath + imagePath;
        } else {
          path = originalPath;
          path += assetData.u ? assetData.u : '';
          path += assetData.p;
        }
        return path;
      }
      function testImageLoaded(img) {
        var _count = 0;
        var intervalId = setInterval(function () {
          var box = img.getBBox();
          if (box.width || _count > 500) {
            this._imageLoaded();
            clearInterval(intervalId);
          }
          _count += 1;
        }.bind(this), 50);
      }
      function createImageData(assetData) {
        var path = getAssetsPath(assetData, this.assetsPath, this.path);
        var img = createNS('image');
        if (isSafari) {
          this.testImageLoaded(img);
        } else {
          img.addEventListener('load', this._imageLoaded, false);
        }
        img.addEventListener('error', function () {
          ob.img = proxyImage;
          this._imageLoaded();
        }.bind(this), false);
        img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
        if (this._elementHelper.append) {
          this._elementHelper.append(img);
        } else {
          this._elementHelper.appendChild(img);
        }
        var ob = {
          img: img,
          assetData: assetData
        };
        return ob;
      }
      function createImgData(assetData) {
        var path = getAssetsPath(assetData, this.assetsPath, this.path);
        var img = createTag('img');
        img.crossOrigin = 'anonymous';
        img.addEventListener('load', this._imageLoaded, false);
        img.addEventListener('error', function () {
          ob.img = proxyImage;
          this._imageLoaded();
        }.bind(this), false);
        img.src = path;
        var ob = {
          img: img,
          assetData: assetData
        };
        return ob;
      }
      function createFootageData(data) {
        var ob = {
          assetData: data
        };
        var path = getAssetsPath(data, this.assetsPath, this.path);
        dataManager.loadData(path, function (footageData) {
          ob.img = footageData;
          this._footageLoaded();
        }.bind(this), function () {
          ob.img = {};
          this._footageLoaded();
        }.bind(this));
        return ob;
      }
      function loadAssets(assets, cb) {
        this.imagesLoadedCb = cb;
        var i;
        var len = assets.length;
        for (i = 0; i < len; i += 1) {
          if (!assets[i].layers) {
            if (!assets[i].t || assets[i].t === 'seq') {
              this.totalImages += 1;
              this.images.push(this._createImageData(assets[i]));
            } else if (assets[i].t === 3) {
              this.totalFootages += 1;
              this.images.push(this.createFootageData(assets[i]));
            }
          }
        }
      }
      function setPath(path) {
        this.path = path || '';
      }
      function setAssetsPath(path) {
        this.assetsPath = path || '';
      }
      function getAsset(assetData) {
        var i = 0;
        var len = this.images.length;
        while (i < len) {
          if (this.images[i].assetData === assetData) {
            return this.images[i].img;
          }
          i += 1;
        }
        return null;
      }
      function destroy() {
        this.imagesLoadedCb = null;
        this.images.length = 0;
      }
      function loadedImages() {
        return this.totalImages === this.loadedAssets;
      }
      function loadedFootages() {
        return this.totalFootages === this.loadedFootagesCount;
      }
      function setCacheType(type, elementHelper) {
        if (type === 'svg') {
          this._elementHelper = elementHelper;
          this._createImageData = this.createImageData.bind(this);
        } else {
          this._createImageData = this.createImgData.bind(this);
        }
      }
      function ImagePreloaderFactory() {
        this._imageLoaded = imageLoaded.bind(this);
        this._footageLoaded = footageLoaded.bind(this);
        this.testImageLoaded = testImageLoaded.bind(this);
        this.createFootageData = createFootageData.bind(this);
        this.assetsPath = '';
        this.path = '';
        this.totalImages = 0;
        this.totalFootages = 0;
        this.loadedAssets = 0;
        this.loadedFootagesCount = 0;
        this.imagesLoadedCb = null;
        this.images = [];
      }
      ImagePreloaderFactory.prototype = {
        loadAssets: loadAssets,
        setAssetsPath: setAssetsPath,
        setPath: setPath,
        loadedImages: loadedImages,
        loadedFootages: loadedFootages,
        destroy: destroy,
        getAsset: getAsset,
        createImgData: createImgData,
        createImageData: createImageData,
        imageLoaded: imageLoaded,
        footageLoaded: footageLoaded,
        setCacheType: setCacheType
      };
      return ImagePreloaderFactory;
    }();
    function BaseEvent() {}
    BaseEvent.prototype = {
      triggerEvent: function triggerEvent(eventName, args) {
        if (this._cbs[eventName]) {
          var callbacks = this._cbs[eventName];
          for (var i = 0; i < callbacks.length; i += 1) {
            callbacks[i](args);
          }
        }
      },
      addEventListener: function addEventListener(eventName, callback) {
        if (!this._cbs[eventName]) {
          this._cbs[eventName] = [];
        }
        this._cbs[eventName].push(callback);
        return function () {
          this.removeEventListener(eventName, callback);
        }.bind(this);
      },
      removeEventListener: function removeEventListener(eventName, callback) {
        if (!callback) {
          this._cbs[eventName] = null;
        } else if (this._cbs[eventName]) {
          var i = 0;
          var len = this._cbs[eventName].length;
          while (i < len) {
            if (this._cbs[eventName][i] === callback) {
              this._cbs[eventName].splice(i, 1);
              i -= 1;
              len -= 1;
            }
            i += 1;
          }
          if (!this._cbs[eventName].length) {
            this._cbs[eventName] = null;
          }
        }
      }
    };
    var markerParser = function () {
      function parsePayloadLines(payload) {
        var lines = payload.split('\r\n');
        var keys = {};
        var line;
        var keysCount = 0;
        for (var i = 0; i < lines.length; i += 1) {
          line = lines[i].split(':');
          if (line.length === 2) {
            keys[line[0]] = line[1].trim();
            keysCount += 1;
          }
        }
        if (keysCount === 0) {
          throw new Error();
        }
        return keys;
      }
      return function (_markers) {
        var markers = [];
        for (var i = 0; i < _markers.length; i += 1) {
          var _marker = _markers[i];
          var markerData = {
            time: _marker.tm,
            duration: _marker.dr
          };
          try {
            markerData.payload = JSON.parse(_markers[i].cm);
          } catch (_) {
            try {
              markerData.payload = parsePayloadLines(_markers[i].cm);
            } catch (__) {
              markerData.payload = {
                name: _markers[i].cm
              };
            }
          }
          markers.push(markerData);
        }
        return markers;
      };
    }();
    var ProjectInterface = function () {
      function registerComposition(comp) {
        this.compositions.push(comp);
      }
      return function () {
        function _thisProjectFunction(name) {
          var i = 0;
          var len = this.compositions.length;
          while (i < len) {
            if (this.compositions[i].data && this.compositions[i].data.nm === name) {
              if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
                this.compositions[i].prepareFrame(this.currentFrame);
              }
              return this.compositions[i].compInterface;
            }
            i += 1;
          }
          return null;
        }
        _thisProjectFunction.compositions = [];
        _thisProjectFunction.currentFrame = 0;
        _thisProjectFunction.registerComposition = registerComposition;
        return _thisProjectFunction;
      };
    }();
    var renderers = {};
    var registerRenderer = function registerRenderer(key, value) {
      renderers[key] = value;
    };
    function getRenderer(key) {
      return renderers[key];
    }
    function getRegisteredRenderer() {
      // Returns canvas by default for compatibility
      if (renderers.canvas) {
        return 'canvas';
      } // Returns any renderer that is registered

      for (var key in renderers) {
        if (renderers[key]) {
          return key;
        }
      }
      return '';
    }
    function _typeof$4(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$4 = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof$4 = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof$4(obj);
    }
    var AnimationItem = function AnimationItem() {
      this._cbs = [];
      this.name = '';
      this.path = '';
      this.isLoaded = false;
      this.currentFrame = 0;
      this.currentRawFrame = 0;
      this.firstFrame = 0;
      this.totalFrames = 0;
      this.frameRate = 0;
      this.frameMult = 0;
      this.playSpeed = 1;
      this.playDirection = 1;
      this.playCount = 0;
      this.animationData = {};
      this.assets = [];
      this.isPaused = true;
      this.autoplay = false;
      this.loop = true;
      this.renderer = null;
      this.animationID = createElementID();
      this.assetsPath = '';
      this.timeCompleted = 0;
      this.segmentPos = 0;
      this.isSubframeEnabled = getSubframeEnabled();
      this.segments = [];
      this._idle = true;
      this._completedLoop = false;
      this.projectInterface = ProjectInterface();
      this.imagePreloader = new ImagePreloader();
      this.audioController = audioControllerFactory();
      this.markers = [];
      this.configAnimation = this.configAnimation.bind(this);
      this.onSetupError = this.onSetupError.bind(this);
      this.onSegmentComplete = this.onSegmentComplete.bind(this);
      this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);
      this.expressionsPlugin = getExpressionsPlugin();
    };
    extendPrototype([BaseEvent], AnimationItem);
    AnimationItem.prototype.setParams = function (params) {
      if (params.wrapper || params.container) {
        this.wrapper = params.wrapper || params.container;
      }
      var animType = 'svg';
      if (params.animType) {
        animType = params.animType;
      } else if (params.renderer) {
        animType = params.renderer;
      }
      var RendererClass = getRenderer(animType);
      this.renderer = new RendererClass(this, params.rendererSettings);
      this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
      this.renderer.setProjectInterface(this.projectInterface);
      this.animType = animType;
      if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {
        this.loop = true;
      } else if (params.loop === false) {
        this.loop = false;
      } else {
        this.loop = parseInt(params.loop, 10);
      }
      this.autoplay = 'autoplay' in params ? params.autoplay : true;
      this.name = params.name ? params.name : '';
      this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
      this.assetsPath = params.assetsPath;
      this.initialSegment = params.initialSegment;
      if (params.audioFactory) {
        this.audioController.setAudioFactory(params.audioFactory);
      }
      if (params.animationData) {
        this.setupAnimation(params.animationData);
      } else if (params.path) {
        if (params.path.lastIndexOf('\\') !== -1) {
          this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
        } else {
          this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
        }
        this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
        this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));
        dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
      }
    };
    AnimationItem.prototype.onSetupError = function () {
      this.trigger('data_failed');
    };
    AnimationItem.prototype.setupAnimation = function (data) {
      dataManager.completeAnimation(data, this.configAnimation);
    };
    AnimationItem.prototype.setData = function (wrapper, animationData) {
      if (animationData) {
        if (_typeof$4(animationData) !== 'object') {
          animationData = JSON.parse(animationData);
        }
      }
      var params = {
        wrapper: wrapper,
        animationData: animationData
      };
      var wrapperAttributes = wrapper.attributes;
      params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
      params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : getRegisteredRenderer() || 'canvas';
      var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';
      if (loop === 'false') {
        params.loop = false;
      } else if (loop === 'true') {
        params.loop = true;
      } else if (loop !== '') {
        params.loop = parseInt(loop, 10);
      }
      var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
      params.autoplay = autoplay !== 'false';
      params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';
      var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
      ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';
      if (prerender === 'false') {
        params.prerender = false;
      }
      if (!params.path) {
        this.trigger('destroy');
      } else {
        this.setParams(params);
      }
    };
    AnimationItem.prototype.includeLayers = function (data) {
      if (data.op > this.animationData.op) {
        this.animationData.op = data.op;
        this.totalFrames = Math.floor(data.op - this.animationData.ip);
      }
      var layers = this.animationData.layers;
      var i;
      var len = layers.length;
      var newLayers = data.layers;
      var j;
      var jLen = newLayers.length;
      for (j = 0; j < jLen; j += 1) {
        i = 0;
        while (i < len) {
          if (layers[i].id === newLayers[j].id) {
            layers[i] = newLayers[j];
            break;
          }
          i += 1;
        }
      }
      if (data.chars || data.fonts) {
        this.renderer.globalData.fontManager.addChars(data.chars);
        this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
      }
      if (data.assets) {
        len = data.assets.length;
        for (i = 0; i < len; i += 1) {
          this.animationData.assets.push(data.assets[i]);
        }
      }
      this.animationData.__complete = false;
      dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
    };
    AnimationItem.prototype.onSegmentComplete = function (data) {
      this.animationData = data;
      var expressionsPlugin = getExpressionsPlugin();
      if (expressionsPlugin) {
        expressionsPlugin.initExpressions(this);
      }
      this.loadNextSegment();
    };
    AnimationItem.prototype.loadNextSegment = function () {
      var segments = this.animationData.segments;
      if (!segments || segments.length === 0 || !this.autoloadSegments) {
        this.trigger('data_ready');
        this.timeCompleted = this.totalFrames;
        return;
      }
      var segment = segments.shift();
      this.timeCompleted = segment.time * this.frameRate;
      var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
      this.segmentPos += 1;
      dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {
        this.trigger('data_failed');
      }.bind(this));
    };
    AnimationItem.prototype.loadSegments = function () {
      var segments = this.animationData.segments;
      if (!segments) {
        this.timeCompleted = this.totalFrames;
      }
      this.loadNextSegment();
    };
    AnimationItem.prototype.imagesLoaded = function () {
      this.trigger('loaded_images');
      this.checkLoaded();
    };
    AnimationItem.prototype.preloadImages = function () {
      this.imagePreloader.setAssetsPath(this.assetsPath);
      this.imagePreloader.setPath(this.path);
      this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    };
    AnimationItem.prototype.configAnimation = function (animData) {
      if (!this.renderer) {
        return;
      }
      try {
        this.animationData = animData;
        if (this.initialSegment) {
          this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
          this.firstFrame = Math.round(this.initialSegment[0]);
        } else {
          this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
          this.firstFrame = Math.round(this.animationData.ip);
        }
        this.renderer.configAnimation(animData);
        if (!animData.assets) {
          animData.assets = [];
        }
        this.assets = this.animationData.assets;
        this.frameRate = this.animationData.fr;
        this.frameMult = this.animationData.fr / 1000;
        this.renderer.searchExtraCompositions(animData.assets);
        this.markers = markerParser(animData.markers || []);
        this.trigger('config_ready');
        this.preloadImages();
        this.loadSegments();
        this.updaFrameModifier();
        this.waitForFontsLoaded();
        if (this.isPaused) {
          this.audioController.pause();
        }
      } catch (error) {
        this.triggerConfigError(error);
      }
    };
    AnimationItem.prototype.waitForFontsLoaded = function () {
      if (!this.renderer) {
        return;
      }
      if (this.renderer.globalData.fontManager.isLoaded) {
        this.checkLoaded();
      } else {
        setTimeout(this.waitForFontsLoaded.bind(this), 20);
      }
    };
    AnimationItem.prototype.checkLoaded = function () {
      if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {
        this.isLoaded = true;
        var expressionsPlugin = getExpressionsPlugin();
        if (expressionsPlugin) {
          expressionsPlugin.initExpressions(this);
        }
        this.renderer.initItems();
        setTimeout(function () {
          this.trigger('DOMLoaded');
        }.bind(this), 0);
        this.gotoFrame();
        if (this.autoplay) {
          this.play();
        }
      }
    };
    AnimationItem.prototype.resize = function (width, height) {
      // Adding this validation for backwards compatibility in case an event object was being passed down
      var _width = typeof width === 'number' ? width : undefined;
      var _height = typeof height === 'number' ? height : undefined;
      this.renderer.updateContainerSize(_width, _height);
    };
    AnimationItem.prototype.setSubframe = function (flag) {
      this.isSubframeEnabled = !!flag;
    };
    AnimationItem.prototype.gotoFrame = function () {
      this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

      if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
        this.currentFrame = this.timeCompleted;
      }
      this.trigger('enterFrame');
      this.renderFrame();
      this.trigger('drawnFrame');
    };
    AnimationItem.prototype.renderFrame = function () {
      if (this.isLoaded === false || !this.renderer) {
        return;
      }
      try {
        if (this.expressionsPlugin) {
          this.expressionsPlugin.resetFrame();
        }
        this.renderer.renderFrame(this.currentFrame + this.firstFrame);
      } catch (error) {
        this.triggerRenderFrameError(error);
      }
    };
    AnimationItem.prototype.play = function (name) {
      if (name && this.name !== name) {
        return;
      }
      if (this.isPaused === true) {
        this.isPaused = false;
        this.trigger('_play');
        this.audioController.resume();
        if (this._idle) {
          this._idle = false;
          this.trigger('_active');
        }
      }
    };
    AnimationItem.prototype.pause = function (name) {
      if (name && this.name !== name) {
        return;
      }
      if (this.isPaused === false) {
        this.isPaused = true;
        this.trigger('_pause');
        this._idle = true;
        this.trigger('_idle');
        this.audioController.pause();
      }
    };
    AnimationItem.prototype.togglePause = function (name) {
      if (name && this.name !== name) {
        return;
      }
      if (this.isPaused === true) {
        this.play();
      } else {
        this.pause();
      }
    };
    AnimationItem.prototype.stop = function (name) {
      if (name && this.name !== name) {
        return;
      }
      this.pause();
      this.playCount = 0;
      this._completedLoop = false;
      this.setCurrentRawFrameValue(0);
    };
    AnimationItem.prototype.getMarkerData = function (markerName) {
      var marker;
      for (var i = 0; i < this.markers.length; i += 1) {
        marker = this.markers[i];
        if (marker.payload && marker.payload.name === markerName) {
          return marker;
        }
      }
      return null;
    };
    AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
      if (name && this.name !== name) {
        return;
      }
      var numValue = Number(value);
      if (isNaN(numValue)) {
        var marker = this.getMarkerData(value);
        if (marker) {
          this.goToAndStop(marker.time, true);
        }
      } else if (isFrame) {
        this.setCurrentRawFrameValue(value);
      } else {
        this.setCurrentRawFrameValue(value * this.frameModifier);
      }
      this.pause();
    };
    AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
      if (name && this.name !== name) {
        return;
      }
      var numValue = Number(value);
      if (isNaN(numValue)) {
        var marker = this.getMarkerData(value);
        if (marker) {
          if (!marker.duration) {
            this.goToAndStop(marker.time, true);
          } else {
            this.playSegments([marker.time, marker.time + marker.duration], true);
          }
        }
      } else {
        this.goToAndStop(numValue, isFrame, name);
      }
      this.play();
    };
    AnimationItem.prototype.advanceTime = function (value) {
      if (this.isPaused === true || this.isLoaded === false) {
        return;
      }
      var nextValue = this.currentRawFrame + value * this.frameModifier;
      var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
      // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.

      if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
        if (!this.loop || this.playCount === this.loop) {
          if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
            _isComplete = true;
            nextValue = this.totalFrames - 1;
          }
        } else if (nextValue >= this.totalFrames) {
          this.playCount += 1;
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            this.setCurrentRawFrameValue(nextValue % this.totalFrames);
            this._completedLoop = true;
            this.trigger('loopComplete');
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }
      } else if (nextValue < 0) {
        if (!this.checkSegments(nextValue % this.totalFrames)) {
          if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
            // eslint-disable-line no-plusplus
            this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
            if (!this._completedLoop) {
              this._completedLoop = true;
            } else {
              this.trigger('loopComplete');
            }
          } else {
            _isComplete = true;
            nextValue = 0;
          }
        }
      } else {
        this.setCurrentRawFrameValue(nextValue);
      }
      if (_isComplete) {
        this.setCurrentRawFrameValue(nextValue);
        this.pause();
        this.trigger('complete');
      }
    };
    AnimationItem.prototype.adjustSegment = function (arr, offset) {
      this.playCount = 0;
      if (arr[1] < arr[0]) {
        if (this.frameModifier > 0) {
          if (this.playSpeed < 0) {
            this.setSpeed(-this.playSpeed);
          } else {
            this.setDirection(-1);
          }
        }
        this.totalFrames = arr[0] - arr[1];
        this.timeCompleted = this.totalFrames;
        this.firstFrame = arr[1];
        this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
      } else if (arr[1] > arr[0]) {
        if (this.frameModifier < 0) {
          if (this.playSpeed < 0) {
            this.setSpeed(-this.playSpeed);
          } else {
            this.setDirection(1);
          }
        }
        this.totalFrames = arr[1] - arr[0];
        this.timeCompleted = this.totalFrames;
        this.firstFrame = arr[0];
        this.setCurrentRawFrameValue(0.001 + offset);
      }
      this.trigger('segmentStart');
    };
    AnimationItem.prototype.setSegment = function (init, end) {
      var pendingFrame = -1;
      if (this.isPaused) {
        if (this.currentRawFrame + this.firstFrame < init) {
          pendingFrame = init;
        } else if (this.currentRawFrame + this.firstFrame > end) {
          pendingFrame = end - init;
        }
      }
      this.firstFrame = init;
      this.totalFrames = end - init;
      this.timeCompleted = this.totalFrames;
      if (pendingFrame !== -1) {
        this.goToAndStop(pendingFrame, true);
      }
    };
    AnimationItem.prototype.playSegments = function (arr, forceFlag) {
      if (forceFlag) {
        this.segments.length = 0;
      }
      if (_typeof$4(arr[0]) === 'object') {
        var i;
        var len = arr.length;
        for (i = 0; i < len; i += 1) {
          this.segments.push(arr[i]);
        }
      } else {
        this.segments.push(arr);
      }
      if (this.segments.length && forceFlag) {
        this.adjustSegment(this.segments.shift(), 0);
      }
      if (this.isPaused) {
        this.play();
      }
    };
    AnimationItem.prototype.resetSegments = function (forceFlag) {
      this.segments.length = 0;
      this.segments.push([this.animationData.ip, this.animationData.op]);
      if (forceFlag) {
        this.checkSegments(0);
      }
    };
    AnimationItem.prototype.checkSegments = function (offset) {
      if (this.segments.length) {
        this.adjustSegment(this.segments.shift(), offset);
        return true;
      }
      return false;
    };
    AnimationItem.prototype.destroy = function (name) {
      if (name && this.name !== name || !this.renderer) {
        return;
      }
      this.renderer.destroy();
      this.imagePreloader.destroy();
      this.trigger('destroy');
      this._cbs = null;
      this.onEnterFrame = null;
      this.onLoopComplete = null;
      this.onComplete = null;
      this.onSegmentStart = null;
      this.onDestroy = null;
      this.renderer = null;
      this.expressionsPlugin = null;
      this.imagePreloader = null;
      this.projectInterface = null;
    };
    AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
      this.currentRawFrame = value;
      this.gotoFrame();
    };
    AnimationItem.prototype.setSpeed = function (val) {
      this.playSpeed = val;
      this.updaFrameModifier();
    };
    AnimationItem.prototype.setDirection = function (val) {
      this.playDirection = val < 0 ? -1 : 1;
      this.updaFrameModifier();
    };
    AnimationItem.prototype.setLoop = function (isLooping) {
      this.loop = isLooping;
    };
    AnimationItem.prototype.setVolume = function (val, name) {
      if (name && this.name !== name) {
        return;
      }
      this.audioController.setVolume(val);
    };
    AnimationItem.prototype.getVolume = function () {
      return this.audioController.getVolume();
    };
    AnimationItem.prototype.mute = function (name) {
      if (name && this.name !== name) {
        return;
      }
      this.audioController.mute();
    };
    AnimationItem.prototype.unmute = function (name) {
      if (name && this.name !== name) {
        return;
      }
      this.audioController.unmute();
    };
    AnimationItem.prototype.updaFrameModifier = function () {
      this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
      this.audioController.setRate(this.playSpeed * this.playDirection);
    };
    AnimationItem.prototype.getPath = function () {
      return this.path;
    };
    AnimationItem.prototype.getAssetsPath = function (assetData) {
      var path = '';
      if (assetData.e) {
        path = assetData.p;
      } else if (this.assetsPath) {
        var imagePath = assetData.p;
        if (imagePath.indexOf('images/') !== -1) {
          imagePath = imagePath.split('/')[1];
        }
        path = this.assetsPath + imagePath;
      } else {
        path = this.path;
        path += assetData.u ? assetData.u : '';
        path += assetData.p;
      }
      return path;
    };
    AnimationItem.prototype.getAssetData = function (id) {
      var i = 0;
      var len = this.assets.length;
      while (i < len) {
        if (id === this.assets[i].id) {
          return this.assets[i];
        }
        i += 1;
      }
      return null;
    };
    AnimationItem.prototype.hide = function () {
      this.renderer.hide();
    };
    AnimationItem.prototype.show = function () {
      this.renderer.show();
    };
    AnimationItem.prototype.getDuration = function (isFrame) {
      return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
    };
    AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {
      try {
        var element = this.renderer.getElementByPath(path);
        element.updateDocumentData(documentData, index);
      } catch (error) {// TODO: decide how to handle catch case
      }
    };
    AnimationItem.prototype.trigger = function (name) {
      if (this._cbs && this._cbs[name]) {
        switch (name) {
          case 'enterFrame':
            this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
            break;
          case 'drawnFrame':
            this.drawnFrameEvent.currentTime = this.currentFrame;
            this.drawnFrameEvent.totalTime = this.totalFrames;
            this.drawnFrameEvent.direction = this.frameModifier;
            this.triggerEvent(name, this.drawnFrameEvent);
            break;
          case 'loopComplete':
            this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
            break;
          case 'complete':
            this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
            break;
          case 'segmentStart':
            this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
            break;
          case 'destroy':
            this.triggerEvent(name, new BMDestroyEvent(name, this));
            break;
          default:
            this.triggerEvent(name);
        }
      }
      if (name === 'enterFrame' && this.onEnterFrame) {
        this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
      }
      if (name === 'loopComplete' && this.onLoopComplete) {
        this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
      }
      if (name === 'complete' && this.onComplete) {
        this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
      }
      if (name === 'segmentStart' && this.onSegmentStart) {
        this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
      }
      if (name === 'destroy' && this.onDestroy) {
        this.onDestroy.call(this, new BMDestroyEvent(name, this));
      }
    };
    AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
      var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
      this.triggerEvent('error', error);
      if (this.onError) {
        this.onError.call(this, error);
      }
    };
    AnimationItem.prototype.triggerConfigError = function (nativeError) {
      var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
      this.triggerEvent('error', error);
      if (this.onError) {
        this.onError.call(this, error);
      }
    };
    var animationManager = function () {
      var moduleOb = {};
      var registeredAnimations = [];
      var initTime = 0;
      var len = 0;
      var playingAnimationsNum = 0;
      var _stopped = true;
      var _isFrozen = false;
      function removeElement(ev) {
        var i = 0;
        var animItem = ev.target;
        while (i < len) {
          if (registeredAnimations[i].animation === animItem) {
            registeredAnimations.splice(i, 1);
            i -= 1;
            len -= 1;
            if (!animItem.isPaused) {
              subtractPlayingCount();
            }
          }
          i += 1;
        }
      }
      function registerAnimation(element, animationData) {
        if (!element) {
          return null;
        }
        var i = 0;
        while (i < len) {
          if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
            return registeredAnimations[i].animation;
          }
          i += 1;
        }
        var animItem = new AnimationItem();
        setupAnimation(animItem, element);
        animItem.setData(element, animationData);
        return animItem;
      }
      function getRegisteredAnimations() {
        var i;
        var lenAnims = registeredAnimations.length;
        var animations = [];
        for (i = 0; i < lenAnims; i += 1) {
          animations.push(registeredAnimations[i].animation);
        }
        return animations;
      }
      function addPlayingCount() {
        playingAnimationsNum += 1;
        activate();
      }
      function subtractPlayingCount() {
        playingAnimationsNum -= 1;
      }
      function setupAnimation(animItem, element) {
        animItem.addEventListener('destroy', removeElement);
        animItem.addEventListener('_active', addPlayingCount);
        animItem.addEventListener('_idle', subtractPlayingCount);
        registeredAnimations.push({
          elem: element,
          animation: animItem
        });
        len += 1;
      }
      function loadAnimation(params) {
        var animItem = new AnimationItem();
        setupAnimation(animItem, null);
        animItem.setParams(params);
        return animItem;
      }
      function setSpeed(val, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setSpeed(val, animation);
        }
      }
      function setDirection(val, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setDirection(val, animation);
        }
      }
      function play(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.play(animation);
        }
      }
      function resume(nowTime) {
        var elapsedTime = nowTime - initTime;
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.advanceTime(elapsedTime);
        }
        initTime = nowTime;
        if (playingAnimationsNum && !_isFrozen) {
          window.requestAnimationFrame(resume);
        } else {
          _stopped = true;
        }
      }
      function first(nowTime) {
        initTime = nowTime;
        window.requestAnimationFrame(resume);
      }
      function pause(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.pause(animation);
        }
      }
      function goToAndStop(value, isFrame, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
        }
      }
      function stop(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.stop(animation);
        }
      }
      function togglePause(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.togglePause(animation);
        }
      }
      function destroy(animation) {
        var i;
        for (i = len - 1; i >= 0; i -= 1) {
          registeredAnimations[i].animation.destroy(animation);
        }
      }
      function searchAnimations(animationData, standalone, renderer) {
        var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));
        var i;
        var lenAnims = animElements.length;
        for (i = 0; i < lenAnims; i += 1) {
          if (renderer) {
            animElements[i].setAttribute('data-bm-type', renderer);
          }
          registerAnimation(animElements[i], animationData);
        }
        if (standalone && lenAnims === 0) {
          if (!renderer) {
            renderer = 'svg';
          }
          var body = document.getElementsByTagName('body')[0];
          body.innerText = '';
          var div = createTag('div');
          div.style.width = '100%';
          div.style.height = '100%';
          div.setAttribute('data-bm-type', renderer);
          body.appendChild(div);
          registerAnimation(div, animationData);
        }
      }
      function resize() {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.resize();
        }
      }
      function activate() {
        if (!_isFrozen && playingAnimationsNum) {
          if (_stopped) {
            window.requestAnimationFrame(first);
            _stopped = false;
          }
        }
      }
      function freeze() {
        _isFrozen = true;
      }
      function unfreeze() {
        _isFrozen = false;
        activate();
      }
      function setVolume(val, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setVolume(val, animation);
        }
      }
      function mute(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.mute(animation);
        }
      }
      function unmute(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.unmute(animation);
        }
      }
      moduleOb.registerAnimation = registerAnimation;
      moduleOb.loadAnimation = loadAnimation;
      moduleOb.setSpeed = setSpeed;
      moduleOb.setDirection = setDirection;
      moduleOb.play = play;
      moduleOb.pause = pause;
      moduleOb.stop = stop;
      moduleOb.togglePause = togglePause;
      moduleOb.searchAnimations = searchAnimations;
      moduleOb.resize = resize; // moduleOb.start = start;

      moduleOb.goToAndStop = goToAndStop;
      moduleOb.destroy = destroy;
      moduleOb.freeze = freeze;
      moduleOb.unfreeze = unfreeze;
      moduleOb.setVolume = setVolume;
      moduleOb.mute = mute;
      moduleOb.unmute = unmute;
      moduleOb.getRegisteredAnimations = getRegisteredAnimations;
      return moduleOb;
    }();

    /* eslint-disable */
    var BezierFactory = function () {
      /**
         * BezierEasing - use bezier curve for transition easing function
         * by Gaëtan Renaudeau 2014 - 2015 – MIT License
         *
         * Credits: is based on Firefox's nsSMILKeySpline.cpp
         * Usage:
         * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
         * spline.get(x) => returns the easing value | x must be in [0, 1] range
         *
         */
      var ob = {};
      ob.getBezierEasing = getBezierEasing;
      var beziers = {};
      function getBezierEasing(a, b, c, d, nm) {
        var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
        if (beziers[str]) {
          return beziers[str];
        }
        var bezEasing = new BezierEasing([a, b, c, d]);
        beziers[str] = bezEasing;
        return bezEasing;
      } // These values are established by empiricism with tests (tradeoff: performance VS precision)

      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 0.001;
      var SUBDIVISION_PRECISION = 0.0000001;
      var SUBDIVISION_MAX_ITERATIONS = 10;
      var kSplineTableSize = 11;
      var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
      var float32ArraySupported = typeof Float32Array === 'function';
      function A(aA1, aA2) {
        return 1.0 - 3.0 * aA2 + 3.0 * aA1;
      }
      function B(aA1, aA2) {
        return 3.0 * aA2 - 6.0 * aA1;
      }
      function C(aA1) {
        return 3.0 * aA1;
      } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.

      function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
      } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.

      function getSlope(aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
      }
      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX,
          currentT,
          i = 0;
        do {
          currentT = aA + (aB - aA) / 2.0;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0.0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }
      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0.0) return aGuessT;
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }
      /**
         * points is an array of [ mX1, mY1, mX2, mY2 ]
         */

      function BezierEasing(points) {
        this._p = points;
        this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        this._precomputed = false;
        this.get = this.get.bind(this);
      }
      BezierEasing.prototype = {
        get: function get(x) {
          var mX1 = this._p[0],
            mY1 = this._p[1],
            mX2 = this._p[2],
            mY2 = this._p[3];
          if (!this._precomputed) this._precompute();
          if (mX1 === mY1 && mX2 === mY2) return x; // linear
          // Because JavaScript number are imprecise, we should guarantee the extremes are right.

          if (x === 0) return 0;
          if (x === 1) return 1;
          return calcBezier(this._getTForX(x), mY1, mY2);
        },
        // Private part
        _precompute: function _precompute() {
          var mX1 = this._p[0],
            mY1 = this._p[1],
            mX2 = this._p[2],
            mY2 = this._p[3];
          this._precomputed = true;
          if (mX1 !== mY1 || mX2 !== mY2) {
            this._calcSampleValues();
          }
        },
        _calcSampleValues: function _calcSampleValues() {
          var mX1 = this._p[0],
            mX2 = this._p[2];
          for (var i = 0; i < kSplineTableSize; ++i) {
            this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
          }
        },
        /**
             * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
             */
        _getTForX: function _getTForX(aX) {
          var mX1 = this._p[0],
            mX2 = this._p[2],
            mSampleValues = this._mSampleValues;
          var intervalStart = 0.0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;
          for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample; // Interpolate to provide an initial guess for t

          var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          }
          if (initialSlope === 0.0) {
            return guessForT;
          }
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      };
      return ob;
    }();
    var pooling = function () {
      function _double(arr) {
        return arr.concat(createSizedArray(arr.length));
      }
      return {
        "double": _double
      };
    }();
    var poolFactory = function () {
      return function (initialLength, _create, _release) {
        var _length = 0;
        var _maxLength = initialLength;
        var pool = createSizedArray(_maxLength);
        var ob = {
          newElement: newElement,
          release: release
        };
        function newElement() {
          var element;
          if (_length) {
            _length -= 1;
            element = pool[_length];
          } else {
            element = _create();
          }
          return element;
        }
        function release(element) {
          if (_length === _maxLength) {
            pool = pooling["double"](pool);
            _maxLength *= 2;
          }
          if (_release) {
            _release(element);
          }
          pool[_length] = element;
          _length += 1;
        }
        return ob;
      };
    }();
    var bezierLengthPool = function () {
      function create() {
        return {
          addedLength: 0,
          percents: createTypedArray('float32', getDefaultCurveSegments()),
          lengths: createTypedArray('float32', getDefaultCurveSegments())
        };
      }
      return poolFactory(8, create);
    }();
    var segmentsLengthPool = function () {
      function create() {
        return {
          lengths: [],
          totalLength: 0
        };
      }
      function release(element) {
        var i;
        var len = element.lengths.length;
        for (i = 0; i < len; i += 1) {
          bezierLengthPool.release(element.lengths[i]);
        }
        element.lengths.length = 0;
      }
      return poolFactory(8, create, release);
    }();
    function bezFunction() {
      var math = Math;
      function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
        var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
        return det1 > -0.001 && det1 < 0.001;
      }
      function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
        if (z1 === 0 && z2 === 0 && z3 === 0) {
          return pointOnLine2D(x1, y1, x2, y2, x3, y3);
        }
        var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
        var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
        var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
        var diffDist;
        if (dist1 > dist2) {
          if (dist1 > dist3) {
            diffDist = dist1 - dist2 - dist3;
          } else {
            diffDist = dist3 - dist2 - dist1;
          }
        } else if (dist3 > dist2) {
          diffDist = dist3 - dist2 - dist1;
        } else {
          diffDist = dist2 - dist1 - dist3;
        }
        return diffDist > -0.0001 && diffDist < 0.0001;
      }
      var getBezierLength = function () {
        return function (pt1, pt2, pt3, pt4) {
          var curveSegments = getDefaultCurveSegments();
          var k;
          var i;
          var len;
          var ptCoord;
          var perc;
          var addedLength = 0;
          var ptDistance;
          var point = [];
          var lastPoint = [];
          var lengthData = bezierLengthPool.newElement();
          len = pt3.length;
          for (k = 0; k < curveSegments; k += 1) {
            perc = k / (curveSegments - 1);
            ptDistance = 0;
            for (i = 0; i < len; i += 1) {
              ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
              point[i] = ptCoord;
              if (lastPoint[i] !== null) {
                ptDistance += bmPow(point[i] - lastPoint[i], 2);
              }
              lastPoint[i] = point[i];
            }
            if (ptDistance) {
              ptDistance = bmSqrt(ptDistance);
              addedLength += ptDistance;
            }
            lengthData.percents[k] = perc;
            lengthData.lengths[k] = addedLength;
          }
          lengthData.addedLength = addedLength;
          return lengthData;
        };
      }();
      function getSegmentsLength(shapeData) {
        var segmentsLength = segmentsLengthPool.newElement();
        var closed = shapeData.c;
        var pathV = shapeData.v;
        var pathO = shapeData.o;
        var pathI = shapeData.i;
        var i;
        var len = shapeData._length;
        var lengths = segmentsLength.lengths;
        var totalLength = 0;
        for (i = 0; i < len - 1; i += 1) {
          lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
          totalLength += lengths[i].addedLength;
        }
        if (closed && len) {
          lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
          totalLength += lengths[i].addedLength;
        }
        segmentsLength.totalLength = totalLength;
        return segmentsLength;
      }
      function BezierData(length) {
        this.segmentLength = 0;
        this.points = new Array(length);
      }
      function PointData(partial, point) {
        this.partialLength = partial;
        this.point = point;
      }
      var buildBezierData = function () {
        var storedData = {};
        return function (pt1, pt2, pt3, pt4) {
          var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
          if (!storedData[bezierName]) {
            var curveSegments = getDefaultCurveSegments();
            var k;
            var i;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point;
            var lastPoint = null;
            if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
              curveSegments = 2;
            }
            var bezierData = new BezierData(curveSegments);
            len = pt3.length;
            for (k = 0; k < curveSegments; k += 1) {
              point = createSizedArray(len);
              perc = k / (curveSegments - 1);
              ptDistance = 0;
              for (i = 0; i < len; i += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                point[i] = ptCoord;
                if (lastPoint !== null) {
                  ptDistance += bmPow(point[i] - lastPoint[i], 2);
                }
              }
              ptDistance = bmSqrt(ptDistance);
              addedLength += ptDistance;
              bezierData.points[k] = new PointData(ptDistance, point);
              lastPoint = point;
            }
            bezierData.segmentLength = addedLength;
            storedData[bezierName] = bezierData;
          }
          return storedData[bezierName];
        };
      }();
      function getDistancePerc(perc, bezierData) {
        var percents = bezierData.percents;
        var lengths = bezierData.lengths;
        var len = percents.length;
        var initPos = bmFloor((len - 1) * perc);
        var lengthPos = perc * bezierData.addedLength;
        var lPerc = 0;
        if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
          return percents[initPos];
        }
        var dir = lengths[initPos] > lengthPos ? -1 : 1;
        var flag = true;
        while (flag) {
          if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
            lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
            flag = false;
          } else {
            initPos += dir;
          }
          if (initPos < 0 || initPos >= len - 1) {
            // FIX for TypedArrays that don't store floating point values with enough accuracy
            if (initPos === len - 1) {
              return percents[initPos];
            }
            flag = false;
          }
        }
        return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
      }
      function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
        var t1 = getDistancePerc(percent, bezierData);
        var u1 = 1 - t1;
        var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
        var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
        return [ptX, ptY];
      }
      var bezierSegmentPoints = createTypedArray('float32', 8);
      function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
        if (startPerc < 0) {
          startPerc = 0;
        } else if (startPerc > 1) {
          startPerc = 1;
        }
        var t0 = getDistancePerc(startPerc, bezierData);
        endPerc = endPerc > 1 ? 1 : endPerc;
        var t1 = getDistancePerc(endPerc, bezierData);
        var i;
        var len = pt1.length;
        var u0 = 1 - t0;
        var u1 = 1 - t1;
        var u0u0u0 = u0 * u0 * u0;
        var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase

        var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase

        var t0t0t0 = t0 * t0 * t0; //

        var u0u0u1 = u0 * u0 * u1;
        var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase

        var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase

        var t0t0t1 = t0 * t0 * t1; //

        var u0u1u1 = u0 * u1 * u1;
        var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase

        var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase

        var t0t1t1 = t0 * t1 * t1; //

        var u1u1u1 = u1 * u1 * u1;
        var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase

        var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase

        var t1t1t1 = t1 * t1 * t1;
        for (i = 0; i < len; i += 1) {
          bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

          bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

          bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

          bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
        }
        return bezierSegmentPoints;
      }
      return {
        getSegmentsLength: getSegmentsLength,
        getNewSegment: getNewSegment,
        getPointInSegment: getPointInSegment,
        buildBezierData: buildBezierData,
        pointOnLine2D: pointOnLine2D,
        pointOnLine3D: pointOnLine3D
      };
    }
    var bez = bezFunction();
    var initFrame = initialDefaultFrame;
    var mathAbs = Math.abs;
    function interpolateValue(frameNum, caching) {
      var offsetTime = this.offsetTime;
      var newValue;
      if (this.propType === 'multidimensional') {
        newValue = createTypedArray('float32', this.pv.length);
      }
      var iterationIndex = caching.lastIndex;
      var i = iterationIndex;
      var len = this.keyframes.length - 1;
      var flag = true;
      var keyData;
      var nextKeyData;
      var keyframeMetadata;
      while (flag) {
        keyData = this.keyframes[i];
        nextKeyData = this.keyframes[i + 1];
        if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
          if (keyData.h) {
            keyData = nextKeyData;
          }
          iterationIndex = 0;
          break;
        }
        if (nextKeyData.t - offsetTime > frameNum) {
          iterationIndex = i;
          break;
        }
        if (i < len - 1) {
          i += 1;
        } else {
          iterationIndex = 0;
          flag = false;
        }
      }
      keyframeMetadata = this.keyframesMetadata[i] || {};
      var k;
      var kLen;
      var perc;
      var jLen;
      var j;
      var fnc;
      var nextKeyTime = nextKeyData.t - offsetTime;
      var keyTime = keyData.t - offsetTime;
      var endValue;
      if (keyData.to) {
        if (!keyframeMetadata.bezierData) {
          keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
        }
        var bezierData = keyframeMetadata.bezierData;
        if (frameNum >= nextKeyTime || frameNum < keyTime) {
          var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
          kLen = bezierData.points[ind].point.length;
          for (k = 0; k < kLen; k += 1) {
            newValue[k] = bezierData.points[ind].point[k];
          } // caching._lastKeyframeIndex = -1;
        } else {
          if (keyframeMetadata.__fnct) {
            fnc = keyframeMetadata.__fnct;
          } else {
            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
            keyframeMetadata.__fnct = fnc;
          }
          perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
          var distanceInLine = bezierData.segmentLength * perc;
          var segmentPerc;
          var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
          j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
          flag = true;
          jLen = bezierData.points.length;
          while (flag) {
            addedLength += bezierData.points[j].partialLength;
            if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
              kLen = bezierData.points[j].point.length;
              for (k = 0; k < kLen; k += 1) {
                newValue[k] = bezierData.points[j].point[k];
              }
              break;
            } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
              segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
              kLen = bezierData.points[j].point.length;
              for (k = 0; k < kLen; k += 1) {
                newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
              }
              break;
            }
            if (j < jLen - 1) {
              j += 1;
            } else {
              flag = false;
            }
          }
          caching._lastPoint = j;
          caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
          caching._lastKeyframeIndex = i;
        }
      } else {
        var outX;
        var outY;
        var inX;
        var inY;
        var keyValue;
        len = keyData.s.length;
        endValue = nextKeyData.s || keyData.e;
        if (this.sh && keyData.h !== 1) {
          if (frameNum >= nextKeyTime) {
            newValue[0] = endValue[0];
            newValue[1] = endValue[1];
            newValue[2] = endValue[2];
          } else if (frameNum <= keyTime) {
            newValue[0] = keyData.s[0];
            newValue[1] = keyData.s[1];
            newValue[2] = keyData.s[2];
          } else {
            var quatStart = createQuaternion(keyData.s);
            var quatEnd = createQuaternion(endValue);
            var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
            quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
          }
        } else {
          for (i = 0; i < len; i += 1) {
            if (keyData.h !== 1) {
              if (frameNum >= nextKeyTime) {
                perc = 1;
              } else if (frameNum < keyTime) {
                perc = 0;
              } else {
                if (keyData.o.x.constructor === Array) {
                  if (!keyframeMetadata.__fnct) {
                    keyframeMetadata.__fnct = [];
                  }
                  if (!keyframeMetadata.__fnct[i]) {
                    outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];
                    outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];
                    inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];
                    inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyframeMetadata.__fnct[i] = fnc;
                  } else {
                    fnc = keyframeMetadata.__fnct[i];
                  }
                } else if (!keyframeMetadata.__fnct) {
                  outX = keyData.o.x;
                  outY = keyData.o.y;
                  inX = keyData.i.x;
                  inY = keyData.i.y;
                  fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                  keyData.keyframeMetadata = fnc;
                } else {
                  fnc = keyframeMetadata.__fnct;
                }
                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
              }
            }
            endValue = nextKeyData.s || keyData.e;
            keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;
            if (this.propType === 'multidimensional') {
              newValue[i] = keyValue;
            } else {
              newValue = keyValue;
            }
          }
        }
      }
      caching.lastIndex = iterationIndex;
      return newValue;
    } // based on @Toji's https://github.com/toji/gl-matrix/

    function slerp(a, b, t) {
      var out = [];
      var ax = a[0];
      var ay = a[1];
      var az = a[2];
      var aw = a[3];
      var bx = b[0];
      var by = b[1];
      var bz = b[2];
      var bw = b[3];
      var omega;
      var cosom;
      var sinom;
      var scale0;
      var scale1;
      cosom = ax * bx + ay * by + az * bz + aw * bw;
      if (cosom < 0.0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }
      if (1.0 - cosom > 0.000001) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        scale0 = 1.0 - t;
        scale1 = t;
      }
      out[0] = scale0 * ax + scale1 * bx;
      out[1] = scale0 * ay + scale1 * by;
      out[2] = scale0 * az + scale1 * bz;
      out[3] = scale0 * aw + scale1 * bw;
      return out;
    }
    function quaternionToEuler(out, quat) {
      var qx = quat[0];
      var qy = quat[1];
      var qz = quat[2];
      var qw = quat[3];
      var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
      var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
      var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
      out[0] = heading / degToRads;
      out[1] = attitude / degToRads;
      out[2] = bank / degToRads;
    }
    function createQuaternion(values) {
      var heading = values[0] * degToRads;
      var attitude = values[1] * degToRads;
      var bank = values[2] * degToRads;
      var c1 = Math.cos(heading / 2);
      var c2 = Math.cos(attitude / 2);
      var c3 = Math.cos(bank / 2);
      var s1 = Math.sin(heading / 2);
      var s2 = Math.sin(attitude / 2);
      var s3 = Math.sin(bank / 2);
      var w = c1 * c2 * c3 - s1 * s2 * s3;
      var x = s1 * s2 * c3 + c1 * c2 * s3;
      var y = s1 * c2 * c3 + c1 * s2 * s3;
      var z = c1 * s2 * c3 - s1 * c2 * s3;
      return [x, y, z, w];
    }
    function getValueAtCurrentTime() {
      var frameNum = this.comp.renderedFrame - this.offsetTime;
      var initTime = this.keyframes[0].t - this.offsetTime;
      var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
      if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
        if (this._caching.lastFrame >= frameNum) {
          this._caching._lastKeyframeIndex = -1;
          this._caching.lastIndex = 0;
        }
        var renderResult = this.interpolateValue(frameNum, this._caching);
        this.pv = renderResult;
      }
      this._caching.lastFrame = frameNum;
      return this.pv;
    }
    function setVValue(val) {
      var multipliedValue;
      if (this.propType === 'unidimensional') {
        multipliedValue = val * this.mult;
        if (mathAbs(this.v - multipliedValue) > 0.00001) {
          this.v = multipliedValue;
          this._mdf = true;
        }
      } else {
        var i = 0;
        var len = this.v.length;
        while (i < len) {
          multipliedValue = val[i] * this.mult;
          if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
            this.v[i] = multipliedValue;
            this._mdf = true;
          }
          i += 1;
        }
      }
    }
    function processEffectsSequence() {
      if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
        return;
      }
      if (this.lock) {
        this.setVValue(this.pv);
        return;
      }
      this.lock = true;
      this._mdf = this._isFirstFrame;
      var i;
      var len = this.effectsSequence.length;
      var finalValue = this.kf ? this.pv : this.data.k;
      for (i = 0; i < len; i += 1) {
        finalValue = this.effectsSequence[i](finalValue);
      }
      this.setVValue(finalValue);
      this._isFirstFrame = false;
      this.lock = false;
      this.frameId = this.elem.globalData.frameId;
    }
    function addEffect(effectFunction) {
      this.effectsSequence.push(effectFunction);
      this.container.addDynamicProperty(this);
    }
    function ValueProperty(elem, data, mult, container) {
      this.propType = 'unidimensional';
      this.mult = mult || 1;
      this.data = data;
      this.v = mult ? data.k * mult : data.k;
      this.pv = data.k;
      this._mdf = false;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.k = false;
      this.kf = false;
      this.vel = 0;
      this.effectsSequence = [];
      this._isFirstFrame = true;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.addEffect = addEffect;
    }
    function MultiDimensionalProperty(elem, data, mult, container) {
      this.propType = 'multidimensional';
      this.mult = mult || 1;
      this.data = data;
      this._mdf = false;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.k = false;
      this.kf = false;
      this.frameId = -1;
      var i;
      var len = data.k.length;
      this.v = createTypedArray('float32', len);
      this.pv = createTypedArray('float32', len);
      this.vel = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        this.v[i] = data.k[i] * this.mult;
        this.pv[i] = data.k[i];
      }
      this._isFirstFrame = true;
      this.effectsSequence = [];
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.addEffect = addEffect;
    }
    function KeyframedValueProperty(elem, data, mult, container) {
      this.propType = 'unidimensional';
      this.keyframes = data.k;
      this.keyframesMetadata = [];
      this.offsetTime = elem.data.st;
      this.frameId = -1;
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: 0,
        _lastKeyframeIndex: -1
      };
      this.k = true;
      this.kf = true;
      this.data = data;
      this.mult = mult || 1;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.v = initFrame;
      this.pv = initFrame;
      this._isFirstFrame = true;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.interpolateValue = interpolateValue;
      this.effectsSequence = [getValueAtCurrentTime.bind(this)];
      this.addEffect = addEffect;
    }
    function KeyframedMultidimensionalProperty(elem, data, mult, container) {
      this.propType = 'multidimensional';
      var i;
      var len = data.k.length;
      var s;
      var e;
      var to;
      var ti;
      for (i = 0; i < len - 1; i += 1) {
        if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
          s = data.k[i].s;
          e = data.k[i + 1].s;
          to = data.k[i].to;
          ti = data.k[i].ti;
          if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
            data.k[i].to = null;
            data.k[i].ti = null;
          }
          if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
            if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
              data.k[i].to = null;
              data.k[i].ti = null;
            }
          }
        }
      }
      this.effectsSequence = [getValueAtCurrentTime.bind(this)];
      this.data = data;
      this.keyframes = data.k;
      this.keyframesMetadata = [];
      this.offsetTime = elem.data.st;
      this.k = true;
      this.kf = true;
      this._isFirstFrame = true;
      this.mult = mult || 1;
      this.elem = elem;
      this.container = container;
      this.comp = elem.comp;
      this.getValue = processEffectsSequence;
      this.setVValue = setVValue;
      this.interpolateValue = interpolateValue;
      this.frameId = -1;
      var arrLen = data.k[0].s.length;
      this.v = createTypedArray('float32', arrLen);
      this.pv = createTypedArray('float32', arrLen);
      for (i = 0; i < arrLen; i += 1) {
        this.v[i] = initFrame;
        this.pv[i] = initFrame;
      }
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: createTypedArray('float32', arrLen)
      };
      this.addEffect = addEffect;
    }
    var PropertyFactory = function () {
      function getProp(elem, data, type, mult, container) {
        if (data.sid) {
          data = elem.globalData.slotManager.getProp(data);
        }
        var p;
        if (!data.k.length) {
          p = new ValueProperty(elem, data, mult, container);
        } else if (typeof data.k[0] === 'number') {
          p = new MultiDimensionalProperty(elem, data, mult, container);
        } else {
          switch (type) {
            case 0:
              p = new KeyframedValueProperty(elem, data, mult, container);
              break;
            case 1:
              p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
              break;
          }
        }
        if (p.effectsSequence.length) {
          container.addDynamicProperty(p);
        }
        return p;
      }
      var ob = {
        getProp: getProp
      };
      return ob;
    }();
    function DynamicPropertyContainer() {}
    DynamicPropertyContainer.prototype = {
      addDynamicProperty: function addDynamicProperty(prop) {
        if (this.dynamicProperties.indexOf(prop) === -1) {
          this.dynamicProperties.push(prop);
          this.container.addDynamicProperty(this);
          this._isAnimated = true;
        }
      },
      iterateDynamicProperties: function iterateDynamicProperties() {
        this._mdf = false;
        var i;
        var len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          this.dynamicProperties[i].getValue();
          if (this.dynamicProperties[i]._mdf) {
            this._mdf = true;
          }
        }
      },
      initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
        this.container = container;
        this.dynamicProperties = [];
        this._mdf = false;
        this._isAnimated = false;
      }
    };
    var pointPool = function () {
      function create() {
        return createTypedArray('float32', 2);
      }
      return poolFactory(8, create);
    }();
    function ShapePath() {
      this.c = false;
      this._length = 0;
      this._maxLength = 8;
      this.v = createSizedArray(this._maxLength);
      this.o = createSizedArray(this._maxLength);
      this.i = createSizedArray(this._maxLength);
    }
    ShapePath.prototype.setPathData = function (closed, len) {
      this.c = closed;
      this.setLength(len);
      var i = 0;
      while (i < len) {
        this.v[i] = pointPool.newElement();
        this.o[i] = pointPool.newElement();
        this.i[i] = pointPool.newElement();
        i += 1;
      }
    };
    ShapePath.prototype.setLength = function (len) {
      while (this._maxLength < len) {
        this.doubleArrayLength();
      }
      this._length = len;
    };
    ShapePath.prototype.doubleArrayLength = function () {
      this.v = this.v.concat(createSizedArray(this._maxLength));
      this.i = this.i.concat(createSizedArray(this._maxLength));
      this.o = this.o.concat(createSizedArray(this._maxLength));
      this._maxLength *= 2;
    };
    ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
      var arr;
      this._length = Math.max(this._length, pos + 1);
      if (this._length >= this._maxLength) {
        this.doubleArrayLength();
      }
      switch (type) {
        case 'v':
          arr = this.v;
          break;
        case 'i':
          arr = this.i;
          break;
        case 'o':
          arr = this.o;
          break;
        default:
          arr = [];
          break;
      }
      if (!arr[pos] || arr[pos] && !replace) {
        arr[pos] = pointPool.newElement();
      }
      arr[pos][0] = x;
      arr[pos][1] = y;
    };
    ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
      this.setXYAt(vX, vY, 'v', pos, replace);
      this.setXYAt(oX, oY, 'o', pos, replace);
      this.setXYAt(iX, iY, 'i', pos, replace);
    };
    ShapePath.prototype.reverse = function () {
      var newPath = new ShapePath();
      newPath.setPathData(this.c, this._length);
      var vertices = this.v;
      var outPoints = this.o;
      var inPoints = this.i;
      var init = 0;
      if (this.c) {
        newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
        init = 1;
      }
      var cnt = this._length - 1;
      var len = this._length;
      var i;
      for (i = init; i < len; i += 1) {
        newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
        cnt -= 1;
      }
      return newPath;
    };
    ShapePath.prototype.length = function () {
      return this._length;
    };
    var shapePool = function () {
      function create() {
        return new ShapePath();
      }
      function release(shapePath) {
        var len = shapePath._length;
        var i;
        for (i = 0; i < len; i += 1) {
          pointPool.release(shapePath.v[i]);
          pointPool.release(shapePath.i[i]);
          pointPool.release(shapePath.o[i]);
          shapePath.v[i] = null;
          shapePath.i[i] = null;
          shapePath.o[i] = null;
        }
        shapePath._length = 0;
        shapePath.c = false;
      }
      function clone(shape) {
        var cloned = factory.newElement();
        var i;
        var len = shape._length === undefined ? shape.v.length : shape._length;
        cloned.setLength(len);
        cloned.c = shape.c;
        for (i = 0; i < len; i += 1) {
          cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
        }
        return cloned;
      }
      var factory = poolFactory(4, create, release);
      factory.clone = clone;
      return factory;
    }();
    function ShapeCollection() {
      this._length = 0;
      this._maxLength = 4;
      this.shapes = createSizedArray(this._maxLength);
    }
    ShapeCollection.prototype.addShape = function (shapeData) {
      if (this._length === this._maxLength) {
        this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      }
      this.shapes[this._length] = shapeData;
      this._length += 1;
    };
    ShapeCollection.prototype.releaseShapes = function () {
      var i;
      for (i = 0; i < this._length; i += 1) {
        shapePool.release(this.shapes[i]);
      }
      this._length = 0;
    };
    var shapeCollectionPool = function () {
      var ob = {
        newShapeCollection: newShapeCollection,
        release: release
      };
      var _length = 0;
      var _maxLength = 4;
      var pool = createSizedArray(_maxLength);
      function newShapeCollection() {
        var shapeCollection;
        if (_length) {
          _length -= 1;
          shapeCollection = pool[_length];
        } else {
          shapeCollection = new ShapeCollection();
        }
        return shapeCollection;
      }
      function release(shapeCollection) {
        var i;
        var len = shapeCollection._length;
        for (i = 0; i < len; i += 1) {
          shapePool.release(shapeCollection.shapes[i]);
        }
        shapeCollection._length = 0;
        if (_length === _maxLength) {
          pool = pooling["double"](pool);
          _maxLength *= 2;
        }
        pool[_length] = shapeCollection;
        _length += 1;
      }
      return ob;
    }();
    var ShapePropertyFactory = function () {
      var initFrame = -999999;
      function interpolateShape(frameNum, previousValue, caching) {
        var iterationIndex = caching.lastIndex;
        var keyPropS;
        var keyPropE;
        var isHold;
        var j;
        var k;
        var jLen;
        var kLen;
        var perc;
        var vertexValue;
        var kf = this.keyframes;
        if (frameNum < kf[0].t - this.offsetTime) {
          keyPropS = kf[0].s[0];
          isHold = true;
          iterationIndex = 0;
        } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
          keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
          /* if(kf[kf.length - 1].s){
                    keyPropS = kf[kf.length - 1].s[0];
                }else{
                    keyPropS = kf[kf.length - 2].e[0];
                } */

          isHold = true;
        } else {
          var i = iterationIndex;
          var len = kf.length - 1;
          var flag = true;
          var keyData;
          var nextKeyData;
          var keyframeMetadata;
          while (flag) {
            keyData = kf[i];
            nextKeyData = kf[i + 1];
            if (nextKeyData.t - this.offsetTime > frameNum) {
              break;
            }
            if (i < len - 1) {
              i += 1;
            } else {
              flag = false;
            }
          }
          keyframeMetadata = this.keyframesMetadata[i] || {};
          isHold = keyData.h === 1;
          iterationIndex = i;
          if (!isHold) {
            if (frameNum >= nextKeyData.t - this.offsetTime) {
              perc = 1;
            } else if (frameNum < keyData.t - this.offsetTime) {
              perc = 0;
            } else {
              var fnc;
              if (keyframeMetadata.__fnct) {
                fnc = keyframeMetadata.__fnct;
              } else {
                fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                keyframeMetadata.__fnct = fnc;
              }
              perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
            }
            keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
          }
          keyPropS = keyData.s[0];
        }
        jLen = previousValue._length;
        kLen = keyPropS.i[0].length;
        caching.lastIndex = iterationIndex;
        for (j = 0; j < jLen; j += 1) {
          for (k = 0; k < kLen; k += 1) {
            vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
            previousValue.i[j][k] = vertexValue;
            vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
            previousValue.o[j][k] = vertexValue;
            vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
            previousValue.v[j][k] = vertexValue;
          }
        }
      }
      function interpolateShapeCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        var lastFrame = this._caching.lastFrame;
        if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
          /// /
          this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
          this.interpolateShape(frameNum, this.pv, this._caching); /// /
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }
      function resetShape() {
        this.paths = this.localShapeCollection;
      }
      function shapesEqual(shape1, shape2) {
        if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
          return false;
        }
        var i;
        var len = shape1._length;
        for (i = 0; i < len; i += 1) {
          if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
            return false;
          }
        }
        return true;
      }
      function setVValue(newPath) {
        if (!shapesEqual(this.v, newPath)) {
          this.v = shapePool.clone(newPath);
          this.localShapeCollection.releaseShapes();
          this.localShapeCollection.addShape(this.v);
          this._mdf = true;
          this.paths = this.localShapeCollection;
        }
      }
      function processEffectsSequence() {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        if (!this.effectsSequence.length) {
          this._mdf = false;
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = false;
        var finalValue;
        if (this.kf) {
          finalValue = this.pv;
        } else if (this.data.ks) {
          finalValue = this.data.ks.k;
        } else {
          finalValue = this.data.pt.k;
        }
        var i;
        var len = this.effectsSequence.length;
        for (i = 0; i < len; i += 1) {
          finalValue = this.effectsSequence[i](finalValue);
        }
        this.setVValue(finalValue);
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }
      function ShapeProperty(elem, data, type) {
        this.propType = 'shape';
        this.comp = elem.comp;
        this.container = elem;
        this.elem = elem;
        this.data = data;
        this.k = false;
        this.kf = false;
        this._mdf = false;
        var pathData = type === 3 ? data.pt.k : data.ks.k;
        this.v = shapePool.clone(pathData);
        this.pv = shapePool.clone(this.v);
        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
        this.paths = this.localShapeCollection;
        this.paths.addShape(this.v);
        this.reset = resetShape;
        this.effectsSequence = [];
      }
      function addEffect(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }
      ShapeProperty.prototype.interpolateShape = interpolateShape;
      ShapeProperty.prototype.getValue = processEffectsSequence;
      ShapeProperty.prototype.setVValue = setVValue;
      ShapeProperty.prototype.addEffect = addEffect;
      function KeyframedShapeProperty(elem, data, type) {
        this.propType = 'shape';
        this.comp = elem.comp;
        this.elem = elem;
        this.container = elem;
        this.offsetTime = elem.data.st;
        this.keyframes = type === 3 ? data.pt.k : data.ks.k;
        this.keyframesMetadata = [];
        this.k = true;
        this.kf = true;
        var len = this.keyframes[0].s[0].i.length;
        this.v = shapePool.newElement();
        this.v.setPathData(this.keyframes[0].s[0].c, len);
        this.pv = shapePool.clone(this.v);
        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
        this.paths = this.localShapeCollection;
        this.paths.addShape(this.v);
        this.lastFrame = initFrame;
        this.reset = resetShape;
        this._caching = {
          lastFrame: initFrame,
          lastIndex: 0
        };
        this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
      }
      KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
      KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
      KeyframedShapeProperty.prototype.setVValue = setVValue;
      KeyframedShapeProperty.prototype.addEffect = addEffect;
      var EllShapeProperty = function () {
        var cPoint = roundCorner;
        function EllShapePropertyFactory(elem, data) {
          this.v = shapePool.newElement();
          this.v.setPathData(true, 4);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.localShapeCollection.addShape(this.v);
          this.d = data.d;
          this.elem = elem;
          this.comp = elem.comp;
          this.frameId = -1;
          this.initDynamicPropertyContainer(elem);
          this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
          this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertEllToPath();
          }
        }
        EllShapePropertyFactory.prototype = {
          reset: resetShape,
          getValue: function getValue() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertEllToPath();
            }
          },
          convertEllToPath: function convertEllToPath() {
            var p0 = this.p.v[0];
            var p1 = this.p.v[1];
            var s0 = this.s.v[0] / 2;
            var s1 = this.s.v[1] / 2;
            var _cw = this.d !== 3;
            var _v = this.v;
            _v.v[0][0] = p0;
            _v.v[0][1] = p1 - s1;
            _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.v[1][1] = p1;
            _v.v[2][0] = p0;
            _v.v[2][1] = p1 + s1;
            _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.v[3][1] = p1;
            _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
            _v.i[0][1] = p1 - s1;
            _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.i[1][1] = p1 - s1 * cPoint;
            _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
            _v.i[2][1] = p1 + s1;
            _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.i[3][1] = p1 + s1 * cPoint;
            _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
            _v.o[0][1] = p1 - s1;
            _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.o[1][1] = p1 + s1 * cPoint;
            _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
            _v.o[2][1] = p1 + s1;
            _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.o[3][1] = p1 - s1 * cPoint;
          }
        };
        extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
        return EllShapePropertyFactory;
      }();
      var StarShapeProperty = function () {
        function StarShapePropertyFactory(elem, data) {
          this.v = shapePool.newElement();
          this.v.setPathData(true, 0);
          this.elem = elem;
          this.comp = elem.comp;
          this.data = data;
          this.frameId = -1;
          this.d = data.d;
          this.initDynamicPropertyContainer(elem);
          if (data.sy === 1) {
            this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
            this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
            this.convertToPath = this.convertStarToPath;
          } else {
            this.convertToPath = this.convertPolygonToPath;
          }
          this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
          this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
          this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
          this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
          this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.localShapeCollection.addShape(this.v);
          this.paths = this.localShapeCollection;
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertToPath();
          }
        }
        StarShapePropertyFactory.prototype = {
          reset: resetShape,
          getValue: function getValue() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertToPath();
            }
          },
          convertStarToPath: function convertStarToPath() {
            var numPts = Math.floor(this.pt.v) * 2;
            var angle = Math.PI * 2 / numPts;
            /* this.v.v.length = numPts;
                    this.v.i.length = numPts;
                    this.v.o.length = numPts; */

            var longFlag = true;
            var longRad = this.or.v;
            var shortRad = this.ir.v;
            var longRound = this.os.v;
            var shortRound = this.is.v;
            var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
            var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
            var i;
            var rad;
            var roundness;
            var perimSegment;
            var currentAng = -Math.PI / 2;
            currentAng += this.r.v;
            var dir = this.data.d === 3 ? -1 : 1;
            this.v._length = 0;
            for (i = 0; i < numPts; i += 1) {
              rad = longFlag ? longRad : shortRad;
              roundness = longFlag ? longRound : shortRound;
              perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
              var x = rad * Math.cos(currentAng);
              var y = rad * Math.sin(currentAng);
              var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
              var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
              x += +this.p.v[0];
              y += +this.p.v[1];
              this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
              /* this.v.v[i] = [x,y];
                        this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                        this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                        this.v._length = numPts; */

              longFlag = !longFlag;
              currentAng += angle * dir;
            }
          },
          convertPolygonToPath: function convertPolygonToPath() {
            var numPts = Math.floor(this.pt.v);
            var angle = Math.PI * 2 / numPts;
            var rad = this.or.v;
            var roundness = this.os.v;
            var perimSegment = 2 * Math.PI * rad / (numPts * 4);
            var i;
            var currentAng = -Math.PI * 0.5;
            var dir = this.data.d === 3 ? -1 : 1;
            currentAng += this.r.v;
            this.v._length = 0;
            for (i = 0; i < numPts; i += 1) {
              var x = rad * Math.cos(currentAng);
              var y = rad * Math.sin(currentAng);
              var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
              var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
              x += +this.p.v[0];
              y += +this.p.v[1];
              this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
              currentAng += angle * dir;
            }
            this.paths.length = 0;
            this.paths[0] = this.v;
          }
        };
        extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
        return StarShapePropertyFactory;
      }();
      var RectShapeProperty = function () {
        function RectShapePropertyFactory(elem, data) {
          this.v = shapePool.newElement();
          this.v.c = true;
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.localShapeCollection.addShape(this.v);
          this.paths = this.localShapeCollection;
          this.elem = elem;
          this.comp = elem.comp;
          this.frameId = -1;
          this.d = data.d;
          this.initDynamicPropertyContainer(elem);
          this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
          this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
          this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertRectToPath();
          }
        }
        RectShapePropertyFactory.prototype = {
          convertRectToPath: function convertRectToPath() {
            var p0 = this.p.v[0];
            var p1 = this.p.v[1];
            var v0 = this.s.v[0] / 2;
            var v1 = this.s.v[1] / 2;
            var round = bmMin(v0, v1, this.r.v);
            var cPoint = round * (1 - roundCorner);
            this.v._length = 0;
            if (this.d === 2 || this.d === 1) {
              this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
              if (round !== 0) {
                this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
              } else {
                this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
              }
            } else {
              this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
              if (round !== 0) {
                this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
              } else {
                this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
              }
            }
          },
          getValue: function getValue() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertRectToPath();
            }
          },
          reset: resetShape
        };
        extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
        return RectShapePropertyFactory;
      }();
      function getShapeProp(elem, data, type) {
        var prop;
        if (type === 3 || type === 4) {
          var dataProp = type === 3 ? data.pt : data.ks;
          var keys = dataProp.k;
          if (keys.length) {
            prop = new KeyframedShapeProperty(elem, data, type);
          } else {
            prop = new ShapeProperty(elem, data, type);
          }
        } else if (type === 5) {
          prop = new RectShapeProperty(elem, data);
        } else if (type === 6) {
          prop = new EllShapeProperty(elem, data);
        } else if (type === 7) {
          prop = new StarShapeProperty(elem, data);
        }
        if (prop.k) {
          elem.addDynamicProperty(prop);
        }
        return prop;
      }
      function getConstructorFunction() {
        return ShapeProperty;
      }
      function getKeyframedConstructorFunction() {
        return KeyframedShapeProperty;
      }
      var ob = {};
      ob.getShapeProp = getShapeProp;
      ob.getConstructorFunction = getConstructorFunction;
      ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
      return ob;
    }();

    /*!
     Transformation Matrix v2.0
     (c) Epistemex 2014-2015
     www.epistemex.com
     By Ken Fyrstenberg
     Contributions by leeoniya.
     License: MIT, header required.
     */

    /**
     * 2D transformation matrix object initialized with identity matrix.
     *
     * The matrix can synchronize a canvas context by supplying the context
     * as an argument, or later apply current absolute transform to an
     * existing context.
     *
     * All values are handled as floating point values.
     *
     * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
     * @prop {number} a - scale x
     * @prop {number} b - shear y
     * @prop {number} c - shear x
     * @prop {number} d - scale y
     * @prop {number} e - translate x
     * @prop {number} f - translate y
     * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
     * @constructor
     */

    var Matrix = function () {
      var _cos = Math.cos;
      var _sin = Math.sin;
      var _tan = Math.tan;
      var _rnd = Math.round;
      function reset() {
        this.props[0] = 1;
        this.props[1] = 0;
        this.props[2] = 0;
        this.props[3] = 0;
        this.props[4] = 0;
        this.props[5] = 1;
        this.props[6] = 0;
        this.props[7] = 0;
        this.props[8] = 0;
        this.props[9] = 0;
        this.props[10] = 1;
        this.props[11] = 0;
        this.props[12] = 0;
        this.props[13] = 0;
        this.props[14] = 0;
        this.props[15] = 1;
        return this;
      }
      function rotate(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function rotateX(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
      }
      function rotateY(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
      }
      function rotateZ(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function shear(sx, sy) {
        return this._t(1, sy, sx, 1, 0, 0);
      }
      function skew(ax, ay) {
        return this.shear(_tan(ax), _tan(ay));
      }
      function skewFromAxis(ax, angle) {
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
      }
      function scale(sx, sy, sz) {
        if (!sz && sz !== 0) {
          sz = 1;
        }
        if (sx === 1 && sy === 1 && sz === 1) {
          return this;
        }
        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
      }
      function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        this.props[0] = a;
        this.props[1] = b;
        this.props[2] = c;
        this.props[3] = d;
        this.props[4] = e;
        this.props[5] = f;
        this.props[6] = g;
        this.props[7] = h;
        this.props[8] = i;
        this.props[9] = j;
        this.props[10] = k;
        this.props[11] = l;
        this.props[12] = m;
        this.props[13] = n;
        this.props[14] = o;
        this.props[15] = p;
        return this;
      }
      function translate(tx, ty, tz) {
        tz = tz || 0;
        if (tx !== 0 || ty !== 0 || tz !== 0) {
          return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
        }
        return this;
      }
      function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
        var _p = this.props;
        if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
          // NOTE: commenting this condition because TurboFan deoptimizes code when present
          // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
          _p[12] = _p[12] * a2 + _p[15] * m2;
          _p[13] = _p[13] * f2 + _p[15] * n2;
          _p[14] = _p[14] * k2 + _p[15] * o2;
          _p[15] *= p2; // }

          this._identityCalculated = false;
          return this;
        }
        var a1 = _p[0];
        var b1 = _p[1];
        var c1 = _p[2];
        var d1 = _p[3];
        var e1 = _p[4];
        var f1 = _p[5];
        var g1 = _p[6];
        var h1 = _p[7];
        var i1 = _p[8];
        var j1 = _p[9];
        var k1 = _p[10];
        var l1 = _p[11];
        var m1 = _p[12];
        var n1 = _p[13];
        var o1 = _p[14];
        var p1 = _p[15];
        /* matrix order (canvas compatible):
             * ace
             * bdf
             * 001
             */

        _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
        _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
        _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
        _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
        _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
        _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
        _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
        _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
        _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
        _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
        _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
        _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
        _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
        _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
        _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
        _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
        this._identityCalculated = false;
        return this;
      }
      function multiply(matrix) {
        var matrixProps = matrix.props;
        return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
      }
      function isIdentity() {
        if (!this._identityCalculated) {
          this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
          this._identityCalculated = true;
        }
        return this._identity;
      }
      function equals(matr) {
        var i = 0;
        while (i < 16) {
          if (matr.props[i] !== this.props[i]) {
            return false;
          }
          i += 1;
        }
        return true;
      }
      function clone(matr) {
        var i;
        for (i = 0; i < 16; i += 1) {
          matr.props[i] = this.props[i];
        }
        return matr;
      }
      function cloneFromProps(props) {
        var i;
        for (i = 0; i < 16; i += 1) {
          this.props[i] = props[i];
        }
      }
      function applyToPoint(x, y, z) {
        return {
          x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
          y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
          z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
        };
        /* return {
             x: x * me.a + y * me.c + me.e,
             y: x * me.b + y * me.d + me.f
             }; */
      }
      function applyToX(x, y, z) {
        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
      }
      function applyToY(x, y, z) {
        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
      }
      function applyToZ(x, y, z) {
        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
      }
      function getInverseMatrix() {
        var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
        var a = this.props[5] / determinant;
        var b = -this.props[1] / determinant;
        var c = -this.props[4] / determinant;
        var d = this.props[0] / determinant;
        var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
        var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
        var inverseMatrix = new Matrix();
        inverseMatrix.props[0] = a;
        inverseMatrix.props[1] = b;
        inverseMatrix.props[4] = c;
        inverseMatrix.props[5] = d;
        inverseMatrix.props[12] = e;
        inverseMatrix.props[13] = f;
        return inverseMatrix;
      }
      function inversePoint(pt) {
        var inverseMatrix = this.getInverseMatrix();
        return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
      }
      function inversePoints(pts) {
        var i;
        var len = pts.length;
        var retPts = [];
        for (i = 0; i < len; i += 1) {
          retPts[i] = inversePoint(pts[i]);
        }
        return retPts;
      }
      function applyToTriplePoints(pt1, pt2, pt3) {
        var arr = createTypedArray('float32', 6);
        if (this.isIdentity()) {
          arr[0] = pt1[0];
          arr[1] = pt1[1];
          arr[2] = pt2[0];
          arr[3] = pt2[1];
          arr[4] = pt3[0];
          arr[5] = pt3[1];
        } else {
          var p0 = this.props[0];
          var p1 = this.props[1];
          var p4 = this.props[4];
          var p5 = this.props[5];
          var p12 = this.props[12];
          var p13 = this.props[13];
          arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
          arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
          arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
          arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
          arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
          arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
        }
        return arr;
      }
      function applyToPointArray(x, y, z) {
        var arr;
        if (this.isIdentity()) {
          arr = [x, y, z];
        } else {
          arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
        }
        return arr;
      }
      function applyToPointStringified(x, y) {
        if (this.isIdentity()) {
          return x + ',' + y;
        }
        var _p = this.props;
        return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
      }
      function toCSS() {
        // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

        /* if(this.isIdentity()) {
                return '';
            } */
        var i = 0;
        var props = this.props;
        var cssValue = 'matrix3d(';
        var v = 10000;
        while (i < 16) {
          cssValue += _rnd(props[i] * v) / v;
          cssValue += i === 15 ? ')' : ',';
          i += 1;
        }
        return cssValue;
      }
      function roundMatrixProperty(val) {
        var v = 10000;
        if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {
          return _rnd(val * v) / v;
        }
        return val;
      }
      function to2dCSS() {
        // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

        /* if(this.isIdentity()) {
                return '';
            } */
        var props = this.props;
        var _a = roundMatrixProperty(props[0]);
        var _b = roundMatrixProperty(props[1]);
        var _c = roundMatrixProperty(props[4]);
        var _d = roundMatrixProperty(props[5]);
        var _e = roundMatrixProperty(props[12]);
        var _f = roundMatrixProperty(props[13]);
        return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
      }
      return function () {
        this.reset = reset;
        this.rotate = rotate;
        this.rotateX = rotateX;
        this.rotateY = rotateY;
        this.rotateZ = rotateZ;
        this.skew = skew;
        this.skewFromAxis = skewFromAxis;
        this.shear = shear;
        this.scale = scale;
        this.setTransform = setTransform;
        this.translate = translate;
        this.transform = transform;
        this.multiply = multiply;
        this.applyToPoint = applyToPoint;
        this.applyToX = applyToX;
        this.applyToY = applyToY;
        this.applyToZ = applyToZ;
        this.applyToPointArray = applyToPointArray;
        this.applyToTriplePoints = applyToTriplePoints;
        this.applyToPointStringified = applyToPointStringified;
        this.toCSS = toCSS;
        this.to2dCSS = to2dCSS;
        this.clone = clone;
        this.cloneFromProps = cloneFromProps;
        this.equals = equals;
        this.inversePoints = inversePoints;
        this.inversePoint = inversePoint;
        this.getInverseMatrix = getInverseMatrix;
        this._t = this.transform;
        this.isIdentity = isIdentity;
        this._identity = true;
        this._identityCalculated = false;
        this.props = createTypedArray('float32', 16);
        this.reset();
      };
    }();
    function _typeof$3(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$3 = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof$3 = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof$3(obj);
    }
    var lottie = {};
    function setLocation(href) {
      setLocationHref(href);
    }
    function searchAnimations() {
      {
        animationManager.searchAnimations();
      }
    }
    function setSubframeRendering(flag) {
      setSubframeEnabled(flag);
    }
    function setPrefix(prefix) {
      setIdPrefix(prefix);
    }
    function loadAnimation(params) {
      return animationManager.loadAnimation(params);
    }
    function setQuality(value) {
      if (typeof value === 'string') {
        switch (value) {
          case 'high':
            setDefaultCurveSegments(200);
            break;
          default:
          case 'medium':
            setDefaultCurveSegments(50);
            break;
          case 'low':
            setDefaultCurveSegments(10);
            break;
        }
      } else if (!isNaN(value) && value > 1) {
        setDefaultCurveSegments(value);
      }
    }
    function inBrowser() {
      return typeof navigator !== 'undefined';
    }
    function installPlugin(type, plugin) {
      if (type === 'expressions') {
        setExpressionsPlugin(plugin);
      }
    }
    function getFactory(name) {
      switch (name) {
        case 'propertyFactory':
          return PropertyFactory;
        case 'shapePropertyFactory':
          return ShapePropertyFactory;
        case 'matrix':
          return Matrix;
        default:
          return null;
      }
    }
    lottie.play = animationManager.play;
    lottie.pause = animationManager.pause;
    lottie.setLocationHref = setLocation;
    lottie.togglePause = animationManager.togglePause;
    lottie.setSpeed = animationManager.setSpeed;
    lottie.setDirection = animationManager.setDirection;
    lottie.stop = animationManager.stop;
    lottie.searchAnimations = searchAnimations;
    lottie.registerAnimation = animationManager.registerAnimation;
    lottie.loadAnimation = loadAnimation;
    lottie.setSubframeRendering = setSubframeRendering;
    lottie.resize = animationManager.resize; // lottie.start = start;

    lottie.goToAndStop = animationManager.goToAndStop;
    lottie.destroy = animationManager.destroy;
    lottie.setQuality = setQuality;
    lottie.inBrowser = inBrowser;
    lottie.installPlugin = installPlugin;
    lottie.freeze = animationManager.freeze;
    lottie.unfreeze = animationManager.unfreeze;
    lottie.setVolume = animationManager.setVolume;
    lottie.mute = animationManager.mute;
    lottie.unmute = animationManager.unmute;
    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
    lottie.useWebWorker = setWebWorker;
    lottie.setIDPrefix = setPrefix;
    lottie.__getFactory = getFactory;
    lottie.version = '5.12.2';
    function checkReady() {
      if (document.readyState === 'complete') {
        clearInterval(readyStateCheckInterval);
        searchAnimations();
      }
    }
    function getQueryVariable(variable) {
      var vars = queryString.split('&');
      for (var i = 0; i < vars.length; i += 1) {
        var pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) {
          // eslint-disable-line eqeqeq
          return decodeURIComponent(pair[1]);
        }
      }
      return null;
    }
    var queryString = '';
    {
      var scripts = document.getElementsByTagName('script');
      var index = scripts.length - 1;
      var myScript = scripts[index] || {
        src: ''
      };
      queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, '') : ''; // eslint-disable-line no-useless-escape

      getQueryVariable('renderer');
    }
    var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility

    try {
      if (!(_typeof$3(exports) === 'object' && 'object' !== 'undefined') && !(typeof undefined === 'function') // eslint-disable-line no-undef
      ) {
        window.bodymovin = lottie;
      }
    } catch (err) {//
    }
    var ShapeModifiers = function () {
      var ob = {};
      var modifiers = {};
      ob.registerModifier = registerModifier;
      ob.getModifier = getModifier;
      function registerModifier(nm, factory) {
        if (!modifiers[nm]) {
          modifiers[nm] = factory;
        }
      }
      function getModifier(nm, elem, data) {
        return new modifiers[nm](elem, data);
      }
      return ob;
    }();
    function ShapeModifier() {}
    ShapeModifier.prototype.initModifierProperties = function () {};
    ShapeModifier.prototype.addShapeToModifier = function () {};
    ShapeModifier.prototype.addShape = function (data) {
      if (!this.closed) {
        // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
        data.sh.container.addDynamicProperty(data.sh);
        var shapeData = {
          shape: data.sh,
          data: data,
          localShapeCollection: shapeCollectionPool.newShapeCollection()
        };
        this.shapes.push(shapeData);
        this.addShapeToModifier(shapeData);
        if (this._isAnimated) {
          data.setAsAnimated();
        }
      }
    };
    ShapeModifier.prototype.init = function (elem, data) {
      this.shapes = [];
      this.elem = elem;
      this.initDynamicPropertyContainer(elem);
      this.initModifierProperties(elem, data);
      this.frameId = initialDefaultFrame;
      this.closed = false;
      this.k = false;
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.getValue(true);
      }
    };
    ShapeModifier.prototype.processKeys = function () {
      if (this.elem.globalData.frameId === this.frameId) {
        return;
      }
      this.frameId = this.elem.globalData.frameId;
      this.iterateDynamicProperties();
    };
    extendPrototype([DynamicPropertyContainer], ShapeModifier);
    function TrimModifier() {}
    extendPrototype([ShapeModifier], TrimModifier);
    TrimModifier.prototype.initModifierProperties = function (elem, data) {
      this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
      this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
      this.sValue = 0;
      this.eValue = 0;
      this.getValue = this.processKeys;
      this.m = data.m;
      this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    };
    TrimModifier.prototype.addShapeToModifier = function (shapeData) {
      shapeData.pathsData = [];
    };
    TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
      var segments = [];
      if (e <= 1) {
        segments.push({
          s: s,
          e: e
        });
      } else if (s >= 1) {
        segments.push({
          s: s - 1,
          e: e - 1
        });
      } else {
        segments.push({
          s: s,
          e: 1
        });
        segments.push({
          s: 0,
          e: e - 1
        });
      }
      var shapeSegments = [];
      var i;
      var len = segments.length;
      var segmentOb;
      for (i = 0; i < len; i += 1) {
        segmentOb = segments[i];
        if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
          var shapeS;
          var shapeE;
          if (segmentOb.s * totalModifierLength <= addedLength) {
            shapeS = 0;
          } else {
            shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
          }
          if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
            shapeE = 1;
          } else {
            shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
          }
          shapeSegments.push([shapeS, shapeE]);
        }
      }
      if (!shapeSegments.length) {
        shapeSegments.push([0, 0]);
      }
      return shapeSegments;
    };
    TrimModifier.prototype.releasePathsData = function (pathsData) {
      var i;
      var len = pathsData.length;
      for (i = 0; i < len; i += 1) {
        segmentsLengthPool.release(pathsData[i]);
      }
      pathsData.length = 0;
      return pathsData;
    };
    TrimModifier.prototype.processShapes = function (_isFirstFrame) {
      var s;
      var e;
      if (this._mdf || _isFirstFrame) {
        var o = this.o.v % 360 / 360;
        if (o < 0) {
          o += 1;
        }
        if (this.s.v > 1) {
          s = 1 + o;
        } else if (this.s.v < 0) {
          s = 0 + o;
        } else {
          s = this.s.v + o;
        }
        if (this.e.v > 1) {
          e = 1 + o;
        } else if (this.e.v < 0) {
          e = 0 + o;
        } else {
          e = this.e.v + o;
        }
        if (s > e) {
          var _s = s;
          s = e;
          e = _s;
        }
        s = Math.round(s * 10000) * 0.0001;
        e = Math.round(e * 10000) * 0.0001;
        this.sValue = s;
        this.eValue = e;
      } else {
        s = this.sValue;
        e = this.eValue;
      }
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var pathsData;
      var pathData;
      var totalShapeLength;
      var totalModifierLength = 0;
      if (e === s) {
        for (i = 0; i < len; i += 1) {
          this.shapes[i].localShapeCollection.releaseShapes();
          this.shapes[i].shape._mdf = true;
          this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
          if (this._mdf) {
            this.shapes[i].pathsData.length = 0;
          }
        }
      } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
        var segments = [];
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used

          if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
            shapeData.shape.paths = shapeData.localShapeCollection;
          } else {
            shapePaths = shapeData.shape.paths;
            jLen = shapePaths._length;
            totalShapeLength = 0;
            if (!shapeData.shape._mdf && shapeData.pathsData.length) {
              totalShapeLength = shapeData.totalShapeLength;
            } else {
              pathsData = this.releasePathsData(shapeData.pathsData);
              for (j = 0; j < jLen; j += 1) {
                pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                pathsData.push(pathData);
                totalShapeLength += pathData.totalLength;
              }
              shapeData.totalShapeLength = totalShapeLength;
              shapeData.pathsData = pathsData;
            }
            totalModifierLength += totalShapeLength;
            shapeData.shape._mdf = true;
          }
        }
        var shapeS = s;
        var shapeE = e;
        var addedLength = 0;
        var edges;
        for (i = len - 1; i >= 0; i -= 1) {
          shapeData = this.shapes[i];
          if (shapeData.shape._mdf) {
            localShapeCollection = shapeData.localShapeCollection;
            localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group

            if (this.m === 2 && len > 1) {
              edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
              addedLength += shapeData.totalShapeLength;
            } else {
              edges = [[shapeS, shapeE]];
            }
            jLen = edges.length;
            for (j = 0; j < jLen; j += 1) {
              shapeS = edges[j][0];
              shapeE = edges[j][1];
              segments.length = 0;
              if (shapeE <= 1) {
                segments.push({
                  s: shapeData.totalShapeLength * shapeS,
                  e: shapeData.totalShapeLength * shapeE
                });
              } else if (shapeS >= 1) {
                segments.push({
                  s: shapeData.totalShapeLength * (shapeS - 1),
                  e: shapeData.totalShapeLength * (shapeE - 1)
                });
              } else {
                segments.push({
                  s: shapeData.totalShapeLength * shapeS,
                  e: shapeData.totalShapeLength
                });
                segments.push({
                  s: 0,
                  e: shapeData.totalShapeLength * (shapeE - 1)
                });
              }
              var newShapesData = this.addShapes(shapeData, segments[0]);
              if (segments[0].s !== segments[0].e) {
                if (segments.length > 1) {
                  var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                  if (lastShapeInCollection.c) {
                    var lastShape = newShapesData.pop();
                    this.addPaths(newShapesData, localShapeCollection);
                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                  } else {
                    this.addPaths(newShapesData, localShapeCollection);
                    newShapesData = this.addShapes(shapeData, segments[1]);
                  }
                }
                this.addPaths(newShapesData, localShapeCollection);
              }
            }
            shapeData.shape.paths = localShapeCollection;
          }
        }
      } else if (this._mdf) {
        for (i = 0; i < len; i += 1) {
          // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
          // Don't remove this even if it's losing cached info.
          this.shapes[i].pathsData.length = 0;
          this.shapes[i].shape._mdf = true;
        }
      }
    };
    TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
      var i;
      var len = newPaths.length;
      for (i = 0; i < len; i += 1) {
        localShapeCollection.addShape(newPaths[i]);
      }
    };
    TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
      shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
      shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
      if (newShape) {
        shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
      }
      shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
    };
    TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
      shapePath.setXYAt(points[1], points[5], 'o', pos);
      shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
      if (newShape) {
        shapePath.setXYAt(points[0], points[4], 'v', pos);
      }
      shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
    };
    TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
      var pathsData = shapeData.pathsData;
      var shapePaths = shapeData.shape.paths.shapes;
      var i;
      var len = shapeData.shape.paths._length;
      var j;
      var jLen;
      var addedLength = 0;
      var currentLengthData;
      var segmentCount;
      var lengths;
      var segment;
      var shapes = [];
      var initPos;
      var newShape = true;
      if (!shapePath) {
        shapePath = shapePool.newElement();
        segmentCount = 0;
        initPos = 0;
      } else {
        segmentCount = shapePath._length;
        initPos = shapePath._length;
      }
      shapes.push(shapePath);
      for (i = 0; i < len; i += 1) {
        lengths = pathsData[i].lengths;
        shapePath.c = shapePaths[i].c;
        jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
        for (j = 1; j < jLen; j += 1) {
          currentLengthData = lengths[j - 1];
          if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
            addedLength += currentLengthData.addedLength;
            shapePath.c = false;
          } else if (addedLength > shapeSegment.e) {
            shapePath.c = false;
            break;
          } else {
            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
              this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
              newShape = false;
            } else {
              segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
              this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

              newShape = false;
              shapePath.c = false;
            }
            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }
        }
        if (shapePaths[i].c && lengths.length) {
          currentLengthData = lengths[j - 1];
          if (addedLength <= shapeSegment.e) {
            var segmentLength = lengths[j - 1].addedLength;
            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
              this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
              newShape = false;
            } else {
              segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
              this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

              newShape = false;
              shapePath.c = false;
            }
          } else {
            shapePath.c = false;
          }
          addedLength += currentLengthData.addedLength;
          segmentCount += 1;
        }
        if (shapePath._length) {
          shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
          shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
        }
        if (addedLength > shapeSegment.e) {
          break;
        }
        if (i < len - 1) {
          shapePath = shapePool.newElement();
          newShape = true;
          shapes.push(shapePath);
          segmentCount = 0;
        }
      }
      return shapes;
    };
    function PuckerAndBloatModifier() {}
    extendPrototype([ShapeModifier], PuckerAndBloatModifier);
    PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
      this._isAnimated = !!this.amount.effectsSequence.length;
    };
    PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
      var percent = amount / 100;
      var centerPoint = [0, 0];
      var pathLength = path._length;
      var i = 0;
      for (i = 0; i < pathLength; i += 1) {
        centerPoint[0] += path.v[i][0];
        centerPoint[1] += path.v[i][1];
      }
      centerPoint[0] /= pathLength;
      centerPoint[1] /= pathLength;
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      var vX;
      var vY;
      var oX;
      var oY;
      var iX;
      var iY;
      for (i = 0; i < pathLength; i += 1) {
        vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
        vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
        oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
        oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
        iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
        iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
      }
      return clonedPath;
    };
    PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var amount = this.amount.v;
      if (amount !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    var TransformPropertyFactory = function () {
      var defaultVector = [0, 0];
      function applyToMatrix(mat) {
        var _mdf = this._mdf;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || _mdf;
        if (this.a) {
          mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
        }
        if (this.s) {
          mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
        }
        if (this.sk) {
          mat.skewFromAxis(-this.sk.v, this.sa.v);
        }
        if (this.r) {
          mat.rotate(-this.r.v);
        } else {
          mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
        }
        if (this.data.p.s) {
          if (this.data.p.z) {
            mat.translate(this.px.v, this.py.v, -this.pz.v);
          } else {
            mat.translate(this.px.v, this.py.v, 0);
          }
        } else {
          mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
      }
      function processKeys(forceRender) {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        if (this._isDirty) {
          this.precalculateMatrix();
          this._isDirty = false;
        }
        this.iterateDynamicProperties();
        if (this._mdf || forceRender) {
          var frameRate;
          this.v.cloneFromProps(this.pre.props);
          if (this.appliedTransformations < 1) {
            this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }
          if (this.appliedTransformations < 2) {
            this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }
          if (this.sk && this.appliedTransformations < 3) {
            this.v.skewFromAxis(-this.sk.v, this.sa.v);
          }
          if (this.r && this.appliedTransformations < 4) {
            this.v.rotate(-this.r.v);
          } else if (!this.r && this.appliedTransformations < 4) {
            this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          }
          if (this.autoOriented) {
            var v1;
            var v2;
            frameRate = this.elem.globalData.frameRate;
            if (this.p && this.p.keyframes && this.p.getValueAtTime) {
              if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
              } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
              } else {
                v1 = this.p.pv;
                v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
              }
            } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
              v1 = [];
              v2 = [];
              var px = this.px;
              var py = this.py;
              if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
              } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
              } else {
                v1 = [px.pv, py.pv];
                v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
              }
            } else {
              v2 = defaultVector;
              v1 = v2;
            }
            this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
          }
          if (this.data.p && this.data.p.s) {
            if (this.data.p.z) {
              this.v.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              this.v.translate(this.px.v, this.py.v, 0);
            }
          } else {
            this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }
        this.frameId = this.elem.globalData.frameId;
      }
      function precalculateMatrix() {
        this.appliedTransformations = 0;
        this.pre.reset();
        if (!this.a.effectsSequence.length) {
          this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          this.appliedTransformations = 1;
        } else {
          return;
        }
        if (!this.s.effectsSequence.length) {
          this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          this.appliedTransformations = 2;
        } else {
          return;
        }
        if (this.sk) {
          if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
            this.pre.skewFromAxis(-this.sk.v, this.sa.v);
            this.appliedTransformations = 3;
          } else {
            return;
          }
        }
        if (this.r) {
          if (!this.r.effectsSequence.length) {
            this.pre.rotate(-this.r.v);
            this.appliedTransformations = 4;
          }
        } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
          this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          this.appliedTransformations = 4;
        }
      }
      function autoOrient() {//
        // var prevP = this.getValueAtTime();
      }
      function addDynamicProperty(prop) {
        this._addDynamicProperty(prop);
        this.elem.addDynamicProperty(prop);
        this._isDirty = true;
      }
      function TransformProperty(elem, data, container) {
        this.elem = elem;
        this.frameId = -1;
        this.propType = 'transform';
        this.data = data;
        this.v = new Matrix(); // Precalculated matrix with non animated properties

        this.pre = new Matrix();
        this.appliedTransformations = 0;
        this.initDynamicPropertyContainer(container || elem);
        if (data.p && data.p.s) {
          this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
          this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
          if (data.p.z) {
            this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
          }
        } else {
          this.p = PropertyFactory.getProp(elem, data.p || {
            k: [0, 0, 0]
          }, 1, 0, this);
        }
        if (data.rx) {
          this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
          this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
          this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
          if (data.or.k[0].ti) {
            var i;
            var len = data.or.k.length;
            for (i = 0; i < len; i += 1) {
              data.or.k[i].to = null;
              data.or.k[i].ti = null;
            }
          }
          this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180

          this.or.sh = true;
        } else {
          this.r = PropertyFactory.getProp(elem, data.r || {
            k: 0
          }, 0, degToRads, this);
        }
        if (data.sk) {
          this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
          this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
        }
        this.a = PropertyFactory.getProp(elem, data.a || {
          k: [0, 0, 0]
        }, 1, 0, this);
        this.s = PropertyFactory.getProp(elem, data.s || {
          k: [100, 100, 100]
        }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.

        if (data.o) {
          this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
        } else {
          this.o = {
            _mdf: false,
            v: 1
          };
        }
        this._isDirty = true;
        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }
      }
      TransformProperty.prototype = {
        applyToMatrix: applyToMatrix,
        getValue: processKeys,
        precalculateMatrix: precalculateMatrix,
        autoOrient: autoOrient
      };
      extendPrototype([DynamicPropertyContainer], TransformProperty);
      TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
      TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
      function getTransformProperty(elem, data, container) {
        return new TransformProperty(elem, data, container);
      }
      return {
        getTransformProperty: getTransformProperty
      };
    }();
    function RepeaterModifier() {}
    extendPrototype([ShapeModifier], RepeaterModifier);
    RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
      this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
      this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
      this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
      this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
      this.data = data;
      if (!this.dynamicProperties.length) {
        this.getValue(true);
      }
      this._isAnimated = !!this.dynamicProperties.length;
      this.pMatrix = new Matrix();
      this.rMatrix = new Matrix();
      this.sMatrix = new Matrix();
      this.tMatrix = new Matrix();
      this.matrix = new Matrix();
    };
    RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
      var dir = inv ? -1 : 1;
      var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
      var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
      pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
      rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
      rMatrix.rotate(-transform.r.v * dir * perc);
      rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
      sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
      sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
      sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
    };
    RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
      this.elem = elem;
      this.arr = arr;
      this.pos = pos;
      this.elemsData = elemsData;
      this._currentCopies = 0;
      this._elements = [];
      this._groups = [];
      this.frameId = -1;
      this.initDynamicPropertyContainer(elem);
      this.initModifierProperties(elem, arr[pos]);
      while (pos > 0) {
        pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);

        this._elements.unshift(arr[pos]);
      }
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.getValue(true);
      }
    };
    RepeaterModifier.prototype.resetElements = function (elements) {
      var i;
      var len = elements.length;
      for (i = 0; i < len; i += 1) {
        elements[i]._processed = false;
        if (elements[i].ty === 'gr') {
          this.resetElements(elements[i].it);
        }
      }
    };
    RepeaterModifier.prototype.cloneElements = function (elements) {
      var newElements = JSON.parse(JSON.stringify(elements));
      this.resetElements(newElements);
      return newElements;
    };
    RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
      var i;
      var len = elements.length;
      for (i = 0; i < len; i += 1) {
        elements[i]._render = renderFlag;
        if (elements[i].ty === 'gr') {
          this.changeGroupRender(elements[i].it, renderFlag);
        }
      }
    };
    RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
      var items;
      var itemsTransform;
      var i;
      var dir;
      var cont;
      var hasReloaded = false;
      if (this._mdf || _isFirstFrame) {
        var copies = Math.ceil(this.c.v);
        if (this._groups.length < copies) {
          while (this._groups.length < copies) {
            var group = {
              it: this.cloneElements(this._elements),
              ty: 'gr'
            };
            group.it.push({
              a: {
                a: 0,
                ix: 1,
                k: [0, 0]
              },
              nm: 'Transform',
              o: {
                a: 0,
                ix: 7,
                k: 100
              },
              p: {
                a: 0,
                ix: 2,
                k: [0, 0]
              },
              r: {
                a: 1,
                ix: 6,
                k: [{
                  s: 0,
                  e: 0,
                  t: 0
                }, {
                  s: 0,
                  e: 0,
                  t: 1
                }]
              },
              s: {
                a: 0,
                ix: 3,
                k: [100, 100]
              },
              sa: {
                a: 0,
                ix: 5,
                k: 0
              },
              sk: {
                a: 0,
                ix: 4,
                k: 0
              },
              ty: 'tr'
            });
            this.arr.splice(0, 0, group);
            this._groups.splice(0, 0, group);
            this._currentCopies += 1;
          }
          this.elem.reloadShapes();
          hasReloaded = true;
        }
        cont = 0;
        var renderFlag;
        for (i = 0; i <= this._groups.length - 1; i += 1) {
          renderFlag = cont < copies;
          this._groups[i]._render = renderFlag;
          this.changeGroupRender(this._groups[i].it, renderFlag);
          if (!renderFlag) {
            var elems = this.elemsData[i].it;
            var transformData = elems[elems.length - 1];
            if (transformData.transform.op.v !== 0) {
              transformData.transform.op._mdf = true;
              transformData.transform.op.v = 0;
            } else {
              transformData.transform.op._mdf = false;
            }
          }
          cont += 1;
        }
        this._currentCopies = copies; /// /

        var offset = this.o.v;
        var offsetModulo = offset % 1;
        var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
        var pProps = this.pMatrix.props;
        var rProps = this.rMatrix.props;
        var sProps = this.sMatrix.props;
        this.pMatrix.reset();
        this.rMatrix.reset();
        this.sMatrix.reset();
        this.tMatrix.reset();
        this.matrix.reset();
        var iteration = 0;
        if (offset > 0) {
          while (iteration < roundOffset) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
            iteration += 1;
          }
          if (offsetModulo) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
            iteration += offsetModulo;
          }
        } else if (offset < 0) {
          while (iteration > roundOffset) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
            iteration -= 1;
          }
          if (offsetModulo) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
            iteration -= offsetModulo;
          }
        }
        i = this.data.m === 1 ? 0 : this._currentCopies - 1;
        dir = this.data.m === 1 ? 1 : -1;
        cont = this._currentCopies;
        var j;
        var jLen;
        while (cont) {
          items = this.elemsData[i].it;
          itemsTransform = items[items.length - 1].transform.mProps.v.props;
          jLen = itemsTransform.length;
          items[items.length - 1].transform.mProps._mdf = true;
          items[items.length - 1].transform.op._mdf = true;
          items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));
          if (iteration !== 0) {
            if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
            }
            this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
            this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
            this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
            for (j = 0; j < jLen; j += 1) {
              itemsTransform[j] = this.matrix.props[j];
            }
            this.matrix.reset();
          } else {
            this.matrix.reset();
            for (j = 0; j < jLen; j += 1) {
              itemsTransform[j] = this.matrix.props[j];
            }
          }
          iteration += 1;
          cont -= 1;
          i += dir;
        }
      } else {
        cont = this._currentCopies;
        i = 0;
        dir = 1;
        while (cont) {
          items = this.elemsData[i].it;
          itemsTransform = items[items.length - 1].transform.mProps.v.props;
          items[items.length - 1].transform.mProps._mdf = false;
          items[items.length - 1].transform.op._mdf = false;
          cont -= 1;
          i += dir;
        }
      }
      return hasReloaded;
    };
    RepeaterModifier.prototype.addShape = function () {};
    function RoundCornersModifier() {}
    extendPrototype([ShapeModifier], RoundCornersModifier);
    RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
      this._isAnimated = !!this.rd.effectsSequence.length;
    };
    RoundCornersModifier.prototype.processPath = function (path, round) {
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      var i;
      var len = path._length;
      var currentV;
      var currentI;
      var currentO;
      var closerV;
      var distance;
      var newPosPerc;
      var index = 0;
      var vX;
      var vY;
      var oX;
      var oY;
      var iX;
      var iY;
      for (i = 0; i < len; i += 1) {
        currentV = path.v[i];
        currentO = path.o[i];
        currentI = path.i[i];
        if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
          if ((i === 0 || i === len - 1) && !path.c) {
            clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
            /* clonedPath.v[index] = currentV;
                    clonedPath.o[index] = currentO;
                    clonedPath.i[index] = currentI; */

            index += 1;
          } else {
            if (i === 0) {
              closerV = path.v[len - 1];
            } else {
              closerV = path.v[i - 1];
            }
            distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
            newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
            iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
            vX = iX;
            iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
            vY = iY;
            oX = vX - (vX - currentV[0]) * roundCorner;
            oY = vY - (vY - currentV[1]) * roundCorner;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
            index += 1;
            if (i === len - 1) {
              closerV = path.v[0];
            } else {
              closerV = path.v[i + 1];
            }
            distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
            newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
            oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
            vX = oX;
            oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
            vY = oY;
            iX = vX - (vX - currentV[0]) * roundCorner;
            iY = vY - (vY - currentV[1]) * roundCorner;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
            index += 1;
          }
        } else {
          clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
          index += 1;
        }
      }
      return clonedPath;
    };
    RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var rd = this.rd.v;
      if (rd !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    function floatEqual(a, b) {
      return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));
    }
    function floatZero(f) {
      return Math.abs(f) <= 0.00001;
    }
    function lerp(p0, p1, amount) {
      return p0 * (1 - amount) + p1 * amount;
    }
    function lerpPoint(p0, p1, amount) {
      return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
    }
    function quadRoots(a, b, c) {
      // no root
      if (a === 0) return [];
      var s = b * b - 4 * a * c; // Complex roots

      if (s < 0) return [];
      var singleRoot = -b / (2 * a); // 1 root

      if (s === 0) return [singleRoot];
      var delta = Math.sqrt(s) / (2 * a); // 2 roots

      return [singleRoot - delta, singleRoot + delta];
    }
    function polynomialCoefficients(p0, p1, p2, p3) {
      return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
    }
    function singlePoint(p) {
      return new PolynomialBezier(p, p, p, p, false);
    }
    function PolynomialBezier(p0, p1, p2, p3, linearize) {
      if (linearize && pointEqual(p0, p1)) {
        p1 = lerpPoint(p0, p3, 1 / 3);
      }
      if (linearize && pointEqual(p2, p3)) {
        p2 = lerpPoint(p0, p3, 2 / 3);
      }
      var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
      var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
      this.a = [coeffx[0], coeffy[0]];
      this.b = [coeffx[1], coeffy[1]];
      this.c = [coeffx[2], coeffy[2]];
      this.d = [coeffx[3], coeffy[3]];
      this.points = [p0, p1, p2, p3];
    }
    PolynomialBezier.prototype.point = function (t) {
      return [((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0], ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]];
    };
    PolynomialBezier.prototype.derivative = function (t) {
      return [(3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0], (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]];
    };
    PolynomialBezier.prototype.tangentAngle = function (t) {
      var p = this.derivative(t);
      return Math.atan2(p[1], p[0]);
    };
    PolynomialBezier.prototype.normalAngle = function (t) {
      var p = this.derivative(t);
      return Math.atan2(p[0], p[1]);
    };
    PolynomialBezier.prototype.inflectionPoints = function () {
      var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
      if (floatZero(denom)) return [];
      var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
      var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
      if (square < 0) return [];
      var root = Math.sqrt(square);
      if (floatZero(root)) {
        if (root > 0 && root < 1) return [tcusp];
        return [];
      }
      return [tcusp - root, tcusp + root].filter(function (r) {
        return r > 0 && r < 1;
      });
    };
    PolynomialBezier.prototype.split = function (t) {
      if (t <= 0) return [singlePoint(this.points[0]), this];
      if (t >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
      var p10 = lerpPoint(this.points[0], this.points[1], t);
      var p11 = lerpPoint(this.points[1], this.points[2], t);
      var p12 = lerpPoint(this.points[2], this.points[3], t);
      var p20 = lerpPoint(p10, p11, t);
      var p21 = lerpPoint(p11, p12, t);
      var p3 = lerpPoint(p20, p21, t);
      return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
    };
    function extrema(bez, comp) {
      var min = bez.points[0][comp];
      var max = bez.points[bez.points.length - 1][comp];
      if (min > max) {
        var e = max;
        max = min;
        min = e;
      } // Derivative roots to find min/max

      var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);
      for (var i = 0; i < f.length; i += 1) {
        if (f[i] > 0 && f[i] < 1) {
          var val = bez.point(f[i])[comp];
          if (val < min) min = val;else if (val > max) max = val;
        }
      }
      return {
        min: min,
        max: max
      };
    }
    PolynomialBezier.prototype.bounds = function () {
      return {
        x: extrema(this, 0),
        y: extrema(this, 1)
      };
    };
    PolynomialBezier.prototype.boundingBox = function () {
      var bounds = this.bounds();
      return {
        left: bounds.x.min,
        right: bounds.x.max,
        top: bounds.y.min,
        bottom: bounds.y.max,
        width: bounds.x.max - bounds.x.min,
        height: bounds.y.max - bounds.y.min,
        cx: (bounds.x.max + bounds.x.min) / 2,
        cy: (bounds.y.max + bounds.y.min) / 2
      };
    };
    function intersectData(bez, t1, t2) {
      var box = bez.boundingBox();
      return {
        cx: box.cx,
        cy: box.cy,
        width: box.width,
        height: box.height,
        bez: bez,
        t: (t1 + t2) / 2,
        t1: t1,
        t2: t2
      };
    }
    function splitData(data) {
      var split = data.bez.split(0.5);
      return [intersectData(split[0], data.t1, data.t), intersectData(split[1], data.t, data.t2)];
    }
    function boxIntersect(b1, b2) {
      return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
    }
    function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
      if (!boxIntersect(d1, d2)) return;
      if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
        intersections.push([d1.t, d2.t]);
        return;
      }
      var d1s = splitData(d1);
      var d2s = splitData(d2);
      intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
      intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
      intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
      intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
    }
    PolynomialBezier.prototype.intersections = function (other, tolerance, maxRecursion) {
      if (tolerance === undefined) tolerance = 2;
      if (maxRecursion === undefined) maxRecursion = 7;
      var intersections = [];
      intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
      return intersections;
    };
    PolynomialBezier.shapeSegment = function (shapePath, index) {
      var nextIndex = (index + 1) % shapePath.length();
      return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
    };
    PolynomialBezier.shapeSegmentInverted = function (shapePath, index) {
      var nextIndex = (index + 1) % shapePath.length();
      return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);
    };
    function crossProduct(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }
    function lineIntersection(start1, end1, start2, end2) {
      var v1 = [start1[0], start1[1], 1];
      var v2 = [end1[0], end1[1], 1];
      var v3 = [start2[0], start2[1], 1];
      var v4 = [end2[0], end2[1], 1];
      var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
      if (floatZero(r[2])) return null;
      return [r[0] / r[2], r[1] / r[2]];
    }
    function polarOffset(p, angle, length) {
      return [p[0] + Math.cos(angle) * length, p[1] - Math.sin(angle) * length];
    }
    function pointDistance(p1, p2) {
      return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
    }
    function pointEqual(p1, p2) {
      return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
    }
    function ZigZagModifier() {}
    extendPrototype([ShapeModifier], ZigZagModifier);
    ZigZagModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);
      this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);
      this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);
      this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
    };
    function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
      var angO = angle - Math.PI / 2;
      var angI = angle + Math.PI / 2;
      var px = point[0] + Math.cos(angle) * direction * amplitude;
      var py = point[1] - Math.sin(angle) * direction * amplitude;
      outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
    }
    function getPerpendicularVector(pt1, pt2) {
      var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
      var rot = -Math.PI * 0.5;
      var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
      return rotatedVector;
    }
    function getProjectingAngle(path, cur) {
      var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;
      var nextIndex = (cur + 1) % path.length();
      var prevPoint = path.v[prevIndex];
      var nextPoint = path.v[nextIndex];
      var pVector = getPerpendicularVector(prevPoint, nextPoint);
      return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
    }
    function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {
      var angle = getProjectingAngle(path, cur);
      var point = path.v[cur % path._length];
      var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];
      var nextPoint = path.v[(cur + 1) % path._length];
      var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
      var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
      setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2));
    }
    function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
      for (var i = 0; i < frequency; i += 1) {
        var t = (i + 1) / (frequency + 1);
        var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
        var angle = segment.normalAngle(t);
        var point = segment.point(t);
        setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2));
        direction = -direction;
      }
      return direction;
    }
    ZigZagModifier.prototype.processPath = function (path, amplitude, frequency, pointType) {
      var count = path._length;
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      if (!path.c) {
        count -= 1;
      }
      if (count === 0) return clonedPath;
      var direction = -1;
      var segment = PolynomialBezier.shapeSegment(path, 0);
      zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);
      for (var i = 0; i < count; i += 1) {
        direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
        if (i === count - 1 && !path.c) {
          segment = null;
        } else {
          segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);
        }
        zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);
      }
      return clonedPath;
    };
    ZigZagModifier.prototype.processShapes = function (_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var amplitude = this.amplitude.v;
      var frequency = Math.max(0, Math.round(this.frequency.v));
      var pointType = this.pointsType.v;
      if (amplitude !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    function linearOffset(p1, p2, amount) {
      var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
      return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
    }
    function offsetSegment(segment, amount) {
      var p0;
      var p1a;
      var p1b;
      var p2b;
      var p2a;
      var p3;
      var e;
      e = linearOffset(segment.points[0], segment.points[1], amount);
      p0 = e[0];
      p1a = e[1];
      e = linearOffset(segment.points[1], segment.points[2], amount);
      p1b = e[0];
      p2b = e[1];
      e = linearOffset(segment.points[2], segment.points[3], amount);
      p2a = e[0];
      p3 = e[1];
      var p1 = lineIntersection(p0, p1a, p1b, p2b);
      if (p1 === null) p1 = p1a;
      var p2 = lineIntersection(p2a, p3, p1b, p2b);
      if (p2 === null) p2 = p2a;
      return new PolynomialBezier(p0, p1, p2, p3);
    }
    function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
      var p0 = seg1.points[3];
      var p1 = seg2.points[0]; // Bevel

      if (lineJoin === 3) return p0; // Connected, they don't need a joint

      if (pointEqual(p0, p1)) return p0; // Round

      if (lineJoin === 2) {
        var angleOut = -seg1.tangentAngle(1);
        var angleIn = -seg2.tangentAngle(0) + Math.PI;
        var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
        var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
        var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
        outputBezier.setXYAt(tan[0], tan[1], 'o', outputBezier.length() - 1);
        tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
        outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
        return p1;
      } // Miter

      var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
      var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
      var intersection = lineIntersection(t0, p0, p1, t1);
      if (intersection && pointDistance(intersection, p0) < miterLimit) {
        outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
        return intersection;
      }
      return p0;
    }
    function getIntersection(a, b) {
      var intersect = a.intersections(b);
      if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();
      if (intersect.length) return intersect[0];
      return null;
    }
    function pruneSegmentIntersection(a, b) {
      var outa = a.slice();
      var outb = b.slice();
      var intersect = getIntersection(a[a.length - 1], b[0]);
      if (intersect) {
        outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];
        outb[0] = b[0].split(intersect[1])[1];
      }
      if (a.length > 1 && b.length > 1) {
        intersect = getIntersection(a[0], b[b.length - 1]);
        if (intersect) {
          return [[a[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
        }
      }
      return [outa, outb];
    }
    function pruneIntersections(segments) {
      var e;
      for (var i = 1; i < segments.length; i += 1) {
        e = pruneSegmentIntersection(segments[i - 1], segments[i]);
        segments[i - 1] = e[0];
        segments[i] = e[1];
      }
      if (segments.length > 1) {
        e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
        segments[segments.length - 1] = e[0];
        segments[0] = e[1];
      }
      return segments;
    }
    function offsetSegmentSplit(segment, amount) {
      /*
        We split each bezier segment into smaller pieces based
        on inflection points, this ensures the control point
        polygon is convex.
          (A cubic bezier can have none, one, or two inflection points)
      */
      var flex = segment.inflectionPoints();
      var left;
      var right;
      var split;
      var mid;
      if (flex.length === 0) {
        return [offsetSegment(segment, amount)];
      }
      if (flex.length === 1 || floatEqual(flex[1], 1)) {
        split = segment.split(flex[0]);
        left = split[0];
        right = split[1];
        return [offsetSegment(left, amount), offsetSegment(right, amount)];
      }
      split = segment.split(flex[0]);
      left = split[0];
      var t = (flex[1] - flex[0]) / (1 - flex[0]);
      split = split[1].split(t);
      mid = split[0];
      right = split[1];
      return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
    }
    function OffsetPathModifier() {}
    extendPrototype([ShapeModifier], OffsetPathModifier);
    OffsetPathModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
      this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);
      this.lineJoin = data.lj;
      this._isAnimated = this.amount.effectsSequence.length !== 0;
    };
    OffsetPathModifier.prototype.processPath = function (inputBezier, amount, lineJoin, miterLimit) {
      var outputBezier = shapePool.newElement();
      outputBezier.c = inputBezier.c;
      var count = inputBezier.length();
      if (!inputBezier.c) {
        count -= 1;
      }
      var i;
      var j;
      var segment;
      var multiSegments = [];
      for (i = 0; i < count; i += 1) {
        segment = PolynomialBezier.shapeSegment(inputBezier, i);
        multiSegments.push(offsetSegmentSplit(segment, amount));
      }
      if (!inputBezier.c) {
        for (i = count - 1; i >= 0; i -= 1) {
          segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);
          multiSegments.push(offsetSegmentSplit(segment, amount));
        }
      }
      multiSegments = pruneIntersections(multiSegments); // Add bezier segments to the output and apply line joints

      var lastPoint = null;
      var lastSeg = null;
      for (i = 0; i < multiSegments.length; i += 1) {
        var multiSegment = multiSegments[i];
        if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
        lastSeg = multiSegment[multiSegment.length - 1];
        for (j = 0; j < multiSegment.length; j += 1) {
          segment = multiSegment[j];
          if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
            outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], 'o', outputBezier.length() - 1);
          } else {
            outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
          }
          outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
          lastPoint = segment.points[3];
        }
      }
      if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
      return outputBezier;
    };
    OffsetPathModifier.prototype.processShapes = function (_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var amount = this.amount.v;
      var miterLimit = this.miterLimit.v;
      var lineJoin = this.lineJoin;
      if (amount !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    function getFontProperties(fontData) {
      var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];
      var fWeight = 'normal';
      var fStyle = 'normal';
      var len = styles.length;
      var styleName;
      for (var i = 0; i < len; i += 1) {
        styleName = styles[i].toLowerCase();
        switch (styleName) {
          case 'italic':
            fStyle = 'italic';
            break;
          case 'bold':
            fWeight = '700';
            break;
          case 'black':
            fWeight = '900';
            break;
          case 'medium':
            fWeight = '500';
            break;
          case 'regular':
          case 'normal':
            fWeight = '400';
            break;
          case 'light':
          case 'thin':
            fWeight = '200';
            break;
        }
      }
      return {
        style: fStyle,
        weight: fontData.fWeight || fWeight
      };
    }
    var FontManager = function () {
      var maxWaitingTime = 5000;
      var emptyChar = {
        w: 0,
        size: 0,
        shapes: [],
        data: {
          shapes: []
        }
      };
      var combinedCharacters = []; // Hindi characters

      combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
      var BLACK_FLAG_CODE_POINT = 127988;
      var CANCEL_TAG_CODE_POINT = 917631;
      var A_TAG_CODE_POINT = 917601;
      var Z_TAG_CODE_POINT = 917626;
      var VARIATION_SELECTOR_16_CODE_POINT = 65039;
      var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
      var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
      var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
      var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff'];
      function trimFontOptions(font) {
        var familyArray = font.split(',');
        var i;
        var len = familyArray.length;
        var enabledFamilies = [];
        for (i = 0; i < len; i += 1) {
          if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
            enabledFamilies.push(familyArray[i]);
          }
        }
        return enabledFamilies.join(',');
      }
      function setUpNode(font, family) {
        var parentNode = createTag('span'); // Node is invisible to screen readers.

        parentNode.setAttribute('aria-hidden', true);
        parentNode.style.fontFamily = family;
        var node = createTag('span'); // Characters that vary significantly among different fonts

        node.innerText = 'giItT1WQy@!-/#'; // Visible - so we can measure it - but not on the screen

        parentNode.style.position = 'absolute';
        parentNode.style.left = '-10000px';
        parentNode.style.top = '-10000px'; // Large font size makes even subtle changes obvious

        parentNode.style.fontSize = '300px'; // Reset any font properties

        parentNode.style.fontVariant = 'normal';
        parentNode.style.fontStyle = 'normal';
        parentNode.style.fontWeight = 'normal';
        parentNode.style.letterSpacing = '0';
        parentNode.appendChild(node);
        document.body.appendChild(parentNode); // Remember width with no applied web font

        var width = node.offsetWidth;
        node.style.fontFamily = trimFontOptions(font) + ', ' + family;
        return {
          node: node,
          w: width,
          parent: parentNode
        };
      }
      function checkLoadedFonts() {
        var i;
        var len = this.fonts.length;
        var node;
        var w;
        var loadedCount = len;
        for (i = 0; i < len; i += 1) {
          if (this.fonts[i].loaded) {
            loadedCount -= 1;
          } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
            this.fonts[i].loaded = true;
          } else {
            node = this.fonts[i].monoCase.node;
            w = this.fonts[i].monoCase.w;
            if (node.offsetWidth !== w) {
              loadedCount -= 1;
              this.fonts[i].loaded = true;
            } else {
              node = this.fonts[i].sansCase.node;
              w = this.fonts[i].sansCase.w;
              if (node.offsetWidth !== w) {
                loadedCount -= 1;
                this.fonts[i].loaded = true;
              }
            }
            if (this.fonts[i].loaded) {
              this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
              this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
            }
          }
        }
        if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
          setTimeout(this.checkLoadedFontsBinded, 20);
        } else {
          setTimeout(this.setIsLoadedBinded, 10);
        }
      }
      function createHelper(fontData, def) {
        var engine = document.body && def ? 'svg' : 'canvas';
        var helper;
        var fontProps = getFontProperties(fontData);
        if (engine === 'svg') {
          var tHelper = createNS('text');
          tHelper.style.fontSize = '100px'; // tHelper.style.fontFamily = fontData.fFamily;

          tHelper.setAttribute('font-family', fontData.fFamily);
          tHelper.setAttribute('font-style', fontProps.style);
          tHelper.setAttribute('font-weight', fontProps.weight);
          tHelper.textContent = '1';
          if (fontData.fClass) {
            tHelper.style.fontFamily = 'inherit';
            tHelper.setAttribute('class', fontData.fClass);
          } else {
            tHelper.style.fontFamily = fontData.fFamily;
          }
          def.appendChild(tHelper);
          helper = tHelper;
        } else {
          var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');
          tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;
          helper = tCanvasHelper;
        }
        function measure(text) {
          if (engine === 'svg') {
            helper.textContent = text;
            return helper.getComputedTextLength();
          }
          return helper.measureText(text).width;
        }
        return {
          measureText: measure
        };
      }
      function addFonts(fontData, defs) {
        if (!fontData) {
          this.isLoaded = true;
          return;
        }
        if (this.chars) {
          this.isLoaded = true;
          this.fonts = fontData.list;
          return;
        }
        if (!document.body) {
          this.isLoaded = true;
          fontData.list.forEach(function (data) {
            data.helper = createHelper(data);
            data.cache = {};
          });
          this.fonts = fontData.list;
          return;
        }
        var fontArr = fontData.list;
        var i;
        var len = fontArr.length;
        var _pendingFonts = len;
        for (i = 0; i < len; i += 1) {
          var shouldLoadFont = true;
          var loadedSelector;
          var j;
          fontArr[i].loaded = false;
          fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
          fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
          if (!fontArr[i].fPath) {
            fontArr[i].loaded = true;
            _pendingFonts -= 1;
          } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
            loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');
            if (loadedSelector.length > 0) {
              shouldLoadFont = false;
            }
            if (shouldLoadFont) {
              var s = createTag('style');
              s.setAttribute('f-forigin', fontArr[i].fOrigin);
              s.setAttribute('f-origin', fontArr[i].origin);
              s.setAttribute('f-family', fontArr[i].fFamily);
              s.type = 'text/css';
              s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
              defs.appendChild(s);
            }
          } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
            loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
            for (j = 0; j < loadedSelector.length; j += 1) {
              if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
                // Font is already loaded
                shouldLoadFont = false;
              }
            }
            if (shouldLoadFont) {
              var l = createTag('link');
              l.setAttribute('f-forigin', fontArr[i].fOrigin);
              l.setAttribute('f-origin', fontArr[i].origin);
              l.type = 'text/css';
              l.rel = 'stylesheet';
              l.href = fontArr[i].fPath;
              document.body.appendChild(l);
            }
          } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
            loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
            for (j = 0; j < loadedSelector.length; j += 1) {
              if (fontArr[i].fPath === loadedSelector[j].src) {
                // Font is already loaded
                shouldLoadFont = false;
              }
            }
            if (shouldLoadFont) {
              var sc = createTag('link');
              sc.setAttribute('f-forigin', fontArr[i].fOrigin);
              sc.setAttribute('f-origin', fontArr[i].origin);
              sc.setAttribute('rel', 'stylesheet');
              sc.setAttribute('href', fontArr[i].fPath);
              defs.appendChild(sc);
            }
          }
          fontArr[i].helper = createHelper(fontArr[i], defs);
          fontArr[i].cache = {};
          this.fonts.push(fontArr[i]);
        }
        if (_pendingFonts === 0) {
          this.isLoaded = true;
        } else {
          // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
          // Adding this timeout seems to fix it
          setTimeout(this.checkLoadedFonts.bind(this), 100);
        }
      }
      function addChars(chars) {
        if (!chars) {
          return;
        }
        if (!this.chars) {
          this.chars = [];
        }
        var i;
        var len = chars.length;
        var j;
        var jLen = this.chars.length;
        var found;
        for (i = 0; i < len; i += 1) {
          j = 0;
          found = false;
          while (j < jLen) {
            if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
              found = true;
            }
            j += 1;
          }
          if (!found) {
            this.chars.push(chars[i]);
            jLen += 1;
          }
        }
      }
      function getCharData(_char, style, font) {
        var i = 0;
        var len = this.chars.length;
        while (i < len) {
          if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
            return this.chars[i];
          }
          i += 1;
        }
        if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console
        && !this._warned) {
          this._warned = true;
          console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console
        }
        return emptyChar;
      }
      function measureText(_char2, fontName, size) {
        var fontData = this.getFontByName(fontName); // Using the char instead of char.charCodeAt(0)
        // to avoid collisions between equal chars

        var index = _char2;
        if (!fontData.cache[index]) {
          var tHelper = fontData.helper;
          if (_char2 === ' ') {
            var doubleSize = tHelper.measureText('|' + _char2 + '|');
            var singleSize = tHelper.measureText('||');
            fontData.cache[index] = (doubleSize - singleSize) / 100;
          } else {
            fontData.cache[index] = tHelper.measureText(_char2) / 100;
          }
        }
        return fontData.cache[index] * size;
      }
      function getFontByName(name) {
        var i = 0;
        var len = this.fonts.length;
        while (i < len) {
          if (this.fonts[i].fName === name) {
            return this.fonts[i];
          }
          i += 1;
        }
        return this.fonts[0];
      }
      function getCodePoint(string) {
        var codePoint = 0;
        var first = string.charCodeAt(0);
        if (first >= 0xD800 && first <= 0xDBFF) {
          var second = string.charCodeAt(1);
          if (second >= 0xDC00 && second <= 0xDFFF) {
            codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
          }
        }
        return codePoint;
      } // Skin tone modifiers

      function isModifier(firstCharCode, secondCharCode) {
        var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
        return surrogateModifiers.indexOf(sum) !== -1;
      }
      function isZeroWidthJoiner(charCode) {
        return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
      } // This codepoint may change the appearance of the preceding character.
      // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered
      // as a colorful image as compared to a monochrome text variant.

      function isVariationSelector(charCode) {
        return charCode === VARIATION_SELECTOR_16_CODE_POINT;
      } // The regional indicator symbols are a set of 26 alphabetic Unicode
      /// characters (A–Z) intended to be used to encode ISO 3166-1 alpha-2
      // two-letter country codes in a way that allows optional special treatment.

      function isRegionalCode(string) {
        var codePoint = getCodePoint(string);
        if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
          return true;
        }
        return false;
      } // Some Emoji implementations represent combinations of
      // two “regional indicator” letters as a single flag symbol.

      function isFlagEmoji(string) {
        return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
      }
      function isCombinedCharacter(_char3) {
        return combinedCharacters.indexOf(_char3) !== -1;
      } // Regional flags start with a BLACK_FLAG_CODE_POINT
      // folowed by 5 chars in the TAG range
      // and end with a CANCEL_TAG_CODE_POINT

      function isRegionalFlag(text, index) {
        var codePoint = getCodePoint(text.substr(index, 2));
        if (codePoint !== BLACK_FLAG_CODE_POINT) {
          return false;
        }
        var count = 0;
        index += 2;
        while (count < 5) {
          codePoint = getCodePoint(text.substr(index, 2));
          if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
            return false;
          }
          count += 1;
          index += 2;
        }
        return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;
      }
      function setIsLoaded() {
        this.isLoaded = true;
      }
      var Font = function Font() {
        this.fonts = [];
        this.chars = null;
        this.typekitLoaded = 0;
        this.isLoaded = false;
        this._warned = false;
        this.initTime = Date.now();
        this.setIsLoadedBinded = this.setIsLoaded.bind(this);
        this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
      };
      Font.isModifier = isModifier;
      Font.isZeroWidthJoiner = isZeroWidthJoiner;
      Font.isFlagEmoji = isFlagEmoji;
      Font.isRegionalCode = isRegionalCode;
      Font.isCombinedCharacter = isCombinedCharacter;
      Font.isRegionalFlag = isRegionalFlag;
      Font.isVariationSelector = isVariationSelector;
      Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
      var fontPrototype = {
        addChars: addChars,
        addFonts: addFonts,
        getCharData: getCharData,
        getFontByName: getFontByName,
        measureText: measureText,
        checkLoadedFonts: checkLoadedFonts,
        setIsLoaded: setIsLoaded
      };
      Font.prototype = fontPrototype;
      return Font;
    }();
    function SlotManager(animationData) {
      this.animationData = animationData;
    }
    SlotManager.prototype.getProp = function (data) {
      if (this.animationData.slots && this.animationData.slots[data.sid]) {
        return Object.assign(data, this.animationData.slots[data.sid].p);
      }
      return data;
    };
    function slotFactory(animationData) {
      return new SlotManager(animationData);
    }
    function RenderableElement() {}
    RenderableElement.prototype = {
      initRenderable: function initRenderable() {
        // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
        this.isInRange = false; // layer's display state

        this.hidden = false; // If layer's transparency equals 0, it can be hidden

        this.isTransparent = false; // list of animated components

        this.renderableComponents = [];
      },
      addRenderableComponent: function addRenderableComponent(component) {
        if (this.renderableComponents.indexOf(component) === -1) {
          this.renderableComponents.push(component);
        }
      },
      removeRenderableComponent: function removeRenderableComponent(component) {
        if (this.renderableComponents.indexOf(component) !== -1) {
          this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
        }
      },
      prepareRenderableFrame: function prepareRenderableFrame(num) {
        this.checkLayerLimits(num);
      },
      checkTransparency: function checkTransparency() {
        if (this.finalTransform.mProp.o.v <= 0) {
          if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
            this.isTransparent = true;
            this.hide();
          }
        } else if (this.isTransparent) {
          this.isTransparent = false;
          this.show();
        }
      },
      /**
         * @function
         * Initializes frame related properties.
         *
         * @param {number} num
         * current frame number in Layer's time
         *
         */
      checkLayerLimits: function checkLayerLimits(num) {
        if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
          if (this.isInRange !== true) {
            this.globalData._mdf = true;
            this._mdf = true;
            this.isInRange = true;
            this.show();
          }
        } else if (this.isInRange !== false) {
          this.globalData._mdf = true;
          this.isInRange = false;
          this.hide();
        }
      },
      renderRenderable: function renderRenderable() {
        var i;
        var len = this.renderableComponents.length;
        for (i = 0; i < len; i += 1) {
          this.renderableComponents[i].renderFrame(this._isFirstFrame);
        }
        /* this.maskManager.renderFrame(this.finalTransform.mat);
            this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
      },
      sourceRectAtTime: function sourceRectAtTime() {
        return {
          top: 0,
          left: 0,
          width: 100,
          height: 100
        };
      },
      getLayerSize: function getLayerSize() {
        if (this.data.ty === 5) {
          return {
            w: this.data.textData.width,
            h: this.data.textData.height
          };
        }
        return {
          w: this.data.width,
          h: this.data.height
        };
      }
    };
    var getBlendMode = function () {
      var blendModeEnums = {
        0: 'source-over',
        1: 'multiply',
        2: 'screen',
        3: 'overlay',
        4: 'darken',
        5: 'lighten',
        6: 'color-dodge',
        7: 'color-burn',
        8: 'hard-light',
        9: 'soft-light',
        10: 'difference',
        11: 'exclusion',
        12: 'hue',
        13: 'saturation',
        14: 'color',
        15: 'luminosity'
      };
      return function (mode) {
        return blendModeEnums[mode] || '';
      };
    }();
    function SliderEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function AngleEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function ColorEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
    }
    function PointEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
    }
    function LayerIndexEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function MaskIndexEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function CheckboxEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function NoValueEffect() {
      this.p = {};
    }
    function EffectsManager(data, element) {
      var effects = data.ef || [];
      this.effectElements = [];
      var i;
      var len = effects.length;
      var effectItem;
      for (i = 0; i < len; i += 1) {
        effectItem = new GroupEffect(effects[i], element);
        this.effectElements.push(effectItem);
      }
    }
    function GroupEffect(data, element) {
      this.init(data, element);
    }
    extendPrototype([DynamicPropertyContainer], GroupEffect);
    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
    GroupEffect.prototype.init = function (data, element) {
      this.data = data;
      this.effectElements = [];
      this.initDynamicPropertyContainer(element);
      var i;
      var len = this.data.ef.length;
      var eff;
      var effects = this.data.ef;
      for (i = 0; i < len; i += 1) {
        eff = null;
        switch (effects[i].ty) {
          case 0:
            eff = new SliderEffect(effects[i], element, this);
            break;
          case 1:
            eff = new AngleEffect(effects[i], element, this);
            break;
          case 2:
            eff = new ColorEffect(effects[i], element, this);
            break;
          case 3:
            eff = new PointEffect(effects[i], element, this);
            break;
          case 4:
          case 7:
            eff = new CheckboxEffect(effects[i], element, this);
            break;
          case 10:
            eff = new LayerIndexEffect(effects[i], element, this);
            break;
          case 11:
            eff = new MaskIndexEffect(effects[i], element, this);
            break;
          case 5:
            eff = new EffectsManager(effects[i], element, this);
            break;
          // case 6:

          default:
            eff = new NoValueEffect(effects[i], element, this);
            break;
        }
        if (eff) {
          this.effectElements.push(eff);
        }
      }
    };
    function BaseElement() {}
    BaseElement.prototype = {
      checkMasks: function checkMasks() {
        if (!this.data.hasMask) {
          return false;
        }
        var i = 0;
        var len = this.data.masksProperties.length;
        while (i < len) {
          if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {
            return true;
          }
          i += 1;
        }
        return false;
      },
      initExpressions: function initExpressions() {
        var expressionsInterfaces = getExpressionInterfaces();
        if (!expressionsInterfaces) {
          return;
        }
        var LayerExpressionInterface = expressionsInterfaces('layer');
        var EffectsExpressionInterface = expressionsInterfaces('effects');
        var ShapeExpressionInterface = expressionsInterfaces('shape');
        var TextExpressionInterface = expressionsInterfaces('text');
        var CompExpressionInterface = expressionsInterfaces('comp');
        this.layerInterface = LayerExpressionInterface(this);
        if (this.data.hasMask && this.maskManager) {
          this.layerInterface.registerMaskInterface(this.maskManager);
        }
        var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
        this.layerInterface.registerEffectsInterface(effectsInterface);
        if (this.data.ty === 0 || this.data.xt) {
          this.compInterface = CompExpressionInterface(this);
        } else if (this.data.ty === 4) {
          this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
          this.layerInterface.content = this.layerInterface.shapeInterface;
        } else if (this.data.ty === 5) {
          this.layerInterface.textInterface = TextExpressionInterface(this);
          this.layerInterface.text = this.layerInterface.textInterface;
        }
      },
      setBlendMode: function setBlendMode() {
        var blendModeValue = getBlendMode(this.data.bm);
        var elem = this.baseElement || this.layerElement;
        elem.style['mix-blend-mode'] = blendModeValue;
      },
      initBaseData: function initBaseData(data, globalData, comp) {
        this.globalData = globalData;
        this.comp = comp;
        this.data = data;
        this.layerId = createElementID(); // Stretch factor for old animations missing this property.

        if (!this.data.sr) {
          this.data.sr = 1;
        } // effects manager

        this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
      },
      getType: function getType() {
        return this.type;
      },
      sourceRectAtTime: function sourceRectAtTime() {}
    };

    /**
     * @file
     * Handles element's layer frame update.
     * Checks layer in point and out point
     *
     */
    function FrameElement() {}
    FrameElement.prototype = {
      /**
         * @function
         * Initializes frame related properties.
         *
         */
      initFrame: function initFrame() {
        // set to true when inpoint is rendered
        this._isFirstFrame = false; // list of animated properties

        this.dynamicProperties = []; // If layer has been modified in current tick this will be true

        this._mdf = false;
      },
      /**
         * @function
         * Calculates all dynamic values
         *
         * @param {number} num
         * current frame number in Layer's time
         * @param {boolean} isVisible
         * if layers is currently in range
         *
         */
      prepareProperties: function prepareProperties(num, isVisible) {
        var i;
        var len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {
            this.dynamicProperties[i].getValue();
            if (this.dynamicProperties[i]._mdf) {
              this.globalData._mdf = true;
              this._mdf = true;
            }
          }
        }
      },
      addDynamicProperty: function addDynamicProperty(prop) {
        if (this.dynamicProperties.indexOf(prop) === -1) {
          this.dynamicProperties.push(prop);
        }
      }
    };
    function FootageElement(data, globalData, comp) {
      this.initFrame();
      this.initRenderable();
      this.assetData = globalData.getAssetData(data.refId);
      this.footageData = globalData.imageLoader.getAsset(this.assetData);
      this.initBaseData(data, globalData, comp);
    }
    FootageElement.prototype.prepareFrame = function () {};
    extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
    FootageElement.prototype.getBaseElement = function () {
      return null;
    };
    FootageElement.prototype.renderFrame = function () {};
    FootageElement.prototype.destroy = function () {};
    FootageElement.prototype.initExpressions = function () {
      var expressionsInterfaces = getExpressionInterfaces();
      if (!expressionsInterfaces) {
        return;
      }
      var FootageInterface = expressionsInterfaces('footage');
      this.layerInterface = FootageInterface(this);
    };
    FootageElement.prototype.getFootageData = function () {
      return this.footageData;
    };
    function AudioElement(data, globalData, comp) {
      this.initFrame();
      this.initRenderable();
      this.assetData = globalData.getAssetData(data.refId);
      this.initBaseData(data, globalData, comp);
      this._isPlaying = false;
      this._canPlay = false;
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      this.audio = this.globalData.audioController.createAudio(assetPath);
      this._currentTime = 0;
      this.globalData.audioController.addAudio(this);
      this._volumeMultiplier = 1;
      this._volume = 1;
      this._previousVolume = null;
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
        _placeholder: true
      };
      this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
        k: [100]
      }, 1, 0.01, this);
    }
    AudioElement.prototype.prepareFrame = function (num) {
      this.prepareRenderableFrame(num, true);
      this.prepareProperties(num, true);
      if (!this.tm._placeholder) {
        var timeRemapped = this.tm.v;
        this._currentTime = timeRemapped;
      } else {
        this._currentTime = num / this.data.sr;
      }
      this._volume = this.lv.v[0];
      var totalVolume = this._volume * this._volumeMultiplier;
      if (this._previousVolume !== totalVolume) {
        this._previousVolume = totalVolume;
        this.audio.volume(totalVolume);
      }
    };
    extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
    AudioElement.prototype.renderFrame = function () {
      if (this.isInRange && this._canPlay) {
        if (!this._isPlaying) {
          this.audio.play();
          this.audio.seek(this._currentTime / this.globalData.frameRate);
          this._isPlaying = true;
        } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
          this.audio.seek(this._currentTime / this.globalData.frameRate);
        }
      }
    };
    AudioElement.prototype.show = function () {// this.audio.play()
    };
    AudioElement.prototype.hide = function () {
      this.audio.pause();
      this._isPlaying = false;
    };
    AudioElement.prototype.pause = function () {
      this.audio.pause();
      this._isPlaying = false;
      this._canPlay = false;
    };
    AudioElement.prototype.resume = function () {
      this._canPlay = true;
    };
    AudioElement.prototype.setRate = function (rateValue) {
      this.audio.rate(rateValue);
    };
    AudioElement.prototype.volume = function (volumeValue) {
      this._volumeMultiplier = volumeValue;
      this._previousVolume = volumeValue * this._volume;
      this.audio.volume(this._previousVolume);
    };
    AudioElement.prototype.getBaseElement = function () {
      return null;
    };
    AudioElement.prototype.destroy = function () {};
    AudioElement.prototype.sourceRectAtTime = function () {};
    AudioElement.prototype.initExpressions = function () {};
    function BaseRenderer() {}
    BaseRenderer.prototype.checkLayers = function (num) {
      var i;
      var len = this.layers.length;
      var data;
      this.completeLayers = true;
      for (i = len - 1; i >= 0; i -= 1) {
        if (!this.elements[i]) {
          data = this.layers[i];
          if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {
            this.buildItem(i);
          }
        }
        this.completeLayers = this.elements[i] ? this.completeLayers : false;
      }
      this.checkPendingElements();
    };
    BaseRenderer.prototype.createItem = function (layer) {
      switch (layer.ty) {
        case 2:
          return this.createImage(layer);
        case 0:
          return this.createComp(layer);
        case 1:
          return this.createSolid(layer);
        case 3:
          return this.createNull(layer);
        case 4:
          return this.createShape(layer);
        case 5:
          return this.createText(layer);
        case 6:
          return this.createAudio(layer);
        case 13:
          return this.createCamera(layer);
        case 15:
          return this.createFootage(layer);
        default:
          return this.createNull(layer);
      }
    };
    BaseRenderer.prototype.createCamera = function () {
      throw new Error('You\'re using a 3d camera. Try the html renderer.');
    };
    BaseRenderer.prototype.createAudio = function (data) {
      return new AudioElement(data, this.globalData, this);
    };
    BaseRenderer.prototype.createFootage = function (data) {
      return new FootageElement(data, this.globalData, this);
    };
    BaseRenderer.prototype.buildAllItems = function () {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        this.buildItem(i);
      }
      this.checkPendingElements();
    };
    BaseRenderer.prototype.includeLayers = function (newLayers) {
      this.completeLayers = false;
      var i;
      var len = newLayers.length;
      var j;
      var jLen = this.layers.length;
      for (i = 0; i < len; i += 1) {
        j = 0;
        while (j < jLen) {
          if (this.layers[j].id === newLayers[i].id) {
            this.layers[j] = newLayers[i];
            break;
          }
          j += 1;
        }
      }
    };
    BaseRenderer.prototype.setProjectInterface = function (pInterface) {
      this.globalData.projectInterface = pInterface;
    };
    BaseRenderer.prototype.initItems = function () {
      if (!this.globalData.progressiveLoad) {
        this.buildAllItems();
      }
    };
    BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
      var elements = this.elements;
      var layers = this.layers;
      var i = 0;
      var len = layers.length;
      while (i < len) {
        if (layers[i].ind == parentName) {
          // eslint-disable-line eqeqeq
          if (!elements[i] || elements[i] === true) {
            this.buildItem(i);
            this.addPendingElement(element);
          } else {
            hierarchy.push(elements[i]);
            elements[i].setAsParent();
            if (layers[i].parent !== undefined) {
              this.buildElementParenting(element, layers[i].parent, hierarchy);
            } else {
              element.setHierarchy(hierarchy);
            }
          }
        }
        i += 1;
      }
    };
    BaseRenderer.prototype.addPendingElement = function (element) {
      this.pendingElements.push(element);
    };
    BaseRenderer.prototype.searchExtraCompositions = function (assets) {
      var i;
      var len = assets.length;
      for (i = 0; i < len; i += 1) {
        if (assets[i].xt) {
          var comp = this.createComp(assets[i]);
          comp.initExpressions();
          this.globalData.projectInterface.registerComposition(comp);
        }
      }
    };
    BaseRenderer.prototype.getElementById = function (ind) {
      var i;
      var len = this.elements.length;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i].data.ind === ind) {
          return this.elements[i];
        }
      }
      return null;
    };
    BaseRenderer.prototype.getElementByPath = function (path) {
      var pathValue = path.shift();
      var element;
      if (typeof pathValue === 'number') {
        element = this.elements[pathValue];
      } else {
        var i;
        var len = this.elements.length;
        for (i = 0; i < len; i += 1) {
          if (this.elements[i].data.nm === pathValue) {
            element = this.elements[i];
            break;
          }
        }
      }
      if (path.length === 0) {
        return element;
      }
      return element.getElementByPath(path);
    };
    BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
      this.globalData.fontManager = new FontManager();
      this.globalData.slotManager = slotFactory(animData);
      this.globalData.fontManager.addChars(animData.chars);
      this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
      this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
      this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
      this.globalData.imageLoader = this.animationItem.imagePreloader;
      this.globalData.audioController = this.animationItem.audioController;
      this.globalData.frameId = 0;
      this.globalData.frameRate = animData.fr;
      this.globalData.nm = animData.nm;
      this.globalData.compSize = {
        w: animData.w,
        h: animData.h
      };
    };
    var effectTypes = {
      TRANSFORM_EFFECT: 'transformEFfect'
    };
    function TransformElement() {}
    TransformElement.prototype = {
      initTransform: function initTransform() {
        var mat = new Matrix();
        this.finalTransform = {
          mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
            o: 0
          },
          _matMdf: false,
          _localMatMdf: false,
          _opMdf: false,
          mat: mat,
          localMat: mat,
          localOpacity: 1
        };
        if (this.data.ao) {
          this.finalTransform.mProp.autoOriented = true;
        } // TODO: check TYPE 11: Guided elements
      },
      renderTransform: function renderTransform() {
        this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
        this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
        if (this.hierarchy) {
          var mat;
          var finalMat = this.finalTransform.mat;
          var i = 0;
          var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.

          if (!this.finalTransform._matMdf) {
            while (i < len) {
              if (this.hierarchy[i].finalTransform.mProp._mdf) {
                this.finalTransform._matMdf = true;
                break;
              }
              i += 1;
            }
          }
          if (this.finalTransform._matMdf) {
            mat = this.finalTransform.mProp.v.props;
            finalMat.cloneFromProps(mat);
            for (i = 0; i < len; i += 1) {
              finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);
            }
          }
        }
        if (this.finalTransform._matMdf) {
          this.finalTransform._localMatMdf = this.finalTransform._matMdf;
        }
        if (this.finalTransform._opMdf) {
          this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
        }
      },
      renderLocalTransform: function renderLocalTransform() {
        if (this.localTransforms) {
          var i = 0;
          var len = this.localTransforms.length;
          this.finalTransform._localMatMdf = this.finalTransform._matMdf;
          if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
            while (i < len) {
              if (this.localTransforms[i]._mdf) {
                this.finalTransform._localMatMdf = true;
              }
              if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {
                this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                this.finalTransform._opMdf = true;
              }
              i += 1;
            }
          }
          if (this.finalTransform._localMatMdf) {
            var localMat = this.finalTransform.localMat;
            this.localTransforms[0].matrix.clone(localMat);
            for (i = 1; i < len; i += 1) {
              var lmat = this.localTransforms[i].matrix;
              localMat.multiply(lmat);
            }
            localMat.multiply(this.finalTransform.mat);
          }
          if (this.finalTransform._opMdf) {
            var localOp = this.finalTransform.localOpacity;
            for (i = 0; i < len; i += 1) {
              localOp *= this.localTransforms[i].opacity * 0.01;
            }
            this.finalTransform.localOpacity = localOp;
          }
        }
      },
      searchEffectTransforms: function searchEffectTransforms() {
        if (this.renderableEffectsManager) {
          var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
          if (transformEffects.length) {
            this.localTransforms = [];
            this.finalTransform.localMat = new Matrix();
            var i = 0;
            var len = transformEffects.length;
            for (i = 0; i < len; i += 1) {
              this.localTransforms.push(transformEffects[i]);
            }
          }
        }
      },
      globalToLocal: function globalToLocal(pt) {
        var transforms = [];
        transforms.push(this.finalTransform);
        var flag = true;
        var comp = this.comp;
        while (flag) {
          if (comp.finalTransform) {
            if (comp.data.hasMask) {
              transforms.splice(0, 0, comp.finalTransform);
            }
            comp = comp.comp;
          } else {
            flag = false;
          }
        }
        var i;
        var len = transforms.length;
        var ptNew;
        for (i = 0; i < len; i += 1) {
          ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);

          pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
        }
        return pt;
      },
      mHelper: new Matrix()
    };
    function MaskElement(data, element, globalData) {
      this.data = data;
      this.element = element;
      this.globalData = globalData;
      this.storedData = [];
      this.masksProperties = this.data.masksProperties || [];
      this.maskElement = null;
      var defs = this.globalData.defs;
      var i;
      var len = this.masksProperties ? this.masksProperties.length : 0;
      this.viewData = createSizedArray(len);
      this.solidPath = '';
      var path;
      var properties = this.masksProperties;
      var count = 0;
      var currentMasks = [];
      var j;
      var jLen;
      var layerId = createElementID();
      var rect;
      var expansor;
      var feMorph;
      var x;
      var maskType = 'clipPath';
      var maskRef = 'clip-path';
      for (i = 0; i < len; i += 1) {
        if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
          maskType = 'mask';
          maskRef = 'mask';
        }
        if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
          rect = createNS('rect');
          rect.setAttribute('fill', '#ffffff');
          rect.setAttribute('width', this.element.comp.data.w || 0);
          rect.setAttribute('height', this.element.comp.data.h || 0);
          currentMasks.push(rect);
        } else {
          rect = null;
        }
        path = createNS('path');
        if (properties[i].mode === 'n') {
          // TODO move this to a factory or to a constructor
          this.viewData[i] = {
            op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
            elem: path,
            lastPath: ''
          };
          defs.appendChild(path);
        } else {
          count += 1;
          path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
          path.setAttribute('clip-rule', 'nonzero');
          var filterID;
          if (properties[i].x.k !== 0) {
            maskType = 'mask';
            maskRef = 'mask';
            x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
            filterID = createElementID();
            expansor = createNS('filter');
            expansor.setAttribute('id', filterID);
            feMorph = createNS('feMorphology');
            feMorph.setAttribute('operator', 'erode');
            feMorph.setAttribute('in', 'SourceGraphic');
            feMorph.setAttribute('radius', '0');
            expansor.appendChild(feMorph);
            defs.appendChild(expansor);
            path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
          } else {
            feMorph = null;
            x = null;
          } // TODO move this to a factory or to a constructor

          this.storedData[i] = {
            elem: path,
            x: x,
            expan: feMorph,
            lastPath: '',
            lastOperator: '',
            filterId: filterID,
            lastRadius: 0
          };
          if (properties[i].mode === 'i') {
            jLen = currentMasks.length;
            var g = createNS('g');
            for (j = 0; j < jLen; j += 1) {
              g.appendChild(currentMasks[j]);
            }
            var mask = createNS('mask');
            mask.setAttribute('mask-type', 'alpha');
            mask.setAttribute('id', layerId + '_' + count);
            mask.appendChild(path);
            defs.appendChild(mask);
            g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');
            currentMasks.length = 0;
            currentMasks.push(g);
          } else {
            currentMasks.push(path);
          }
          if (properties[i].inv && !this.solidPath) {
            this.solidPath = this.createLayerSolidPath();
          } // TODO move this to a factory or to a constructor

          this.viewData[i] = {
            elem: path,
            lastPath: '',
            op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
            invRect: rect
          };
          if (!this.viewData[i].prop.k) {
            this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
          }
        }
      }
      this.maskElement = createNS(maskType);
      len = currentMasks.length;
      for (i = 0; i < len; i += 1) {
        this.maskElement.appendChild(currentMasks[i]);
      }
      if (count > 0) {
        this.maskElement.setAttribute('id', layerId);
        this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');
        defs.appendChild(this.maskElement);
      }
      if (this.viewData.length) {
        this.element.addRenderableComponent(this);
      }
    }
    MaskElement.prototype.getMaskProperty = function (pos) {
      return this.viewData[pos].prop;
    };
    MaskElement.prototype.renderFrame = function (isFirstFrame) {
      var finalMat = this.element.finalTransform.mat;
      var i;
      var len = this.masksProperties.length;
      for (i = 0; i < len; i += 1) {
        if (this.viewData[i].prop._mdf || isFirstFrame) {
          this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
        }
        if (this.viewData[i].op._mdf || isFirstFrame) {
          this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
        }
        if (this.masksProperties[i].mode !== 'n') {
          if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
            this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
          }
          if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
            var feMorph = this.storedData[i].expan;
            if (this.storedData[i].x.v < 0) {
              if (this.storedData[i].lastOperator !== 'erode') {
                this.storedData[i].lastOperator = 'erode';
                this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');
              }
              feMorph.setAttribute('radius', -this.storedData[i].x.v);
            } else {
              if (this.storedData[i].lastOperator !== 'dilate') {
                this.storedData[i].lastOperator = 'dilate';
                this.storedData[i].elem.setAttribute('filter', null);
              }
              this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
            }
          }
        }
      }
    };
    MaskElement.prototype.getMaskelement = function () {
      return this.maskElement;
    };
    MaskElement.prototype.createLayerSolidPath = function () {
      var path = 'M0,0 ';
      path += ' h' + this.globalData.compSize.w;
      path += ' v' + this.globalData.compSize.h;
      path += ' h-' + this.globalData.compSize.w;
      path += ' v-' + this.globalData.compSize.h + ' ';
      return path;
    };
    MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
      var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
      var i;
      var len;
      len = pathNodes._length;
      for (i = 1; i < len; i += 1) {
        // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
        pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
      } // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];

      if (pathNodes.c && len > 1) {
        pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
      } // pathNodes.__renderedString = pathString;

      if (viewData.lastPath !== pathString) {
        var pathShapeValue = '';
        if (viewData.elem) {
          if (pathNodes.c) {
            pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
          }
          viewData.elem.setAttribute('d', pathShapeValue);
        }
        viewData.lastPath = pathString;
      }
    };
    MaskElement.prototype.destroy = function () {
      this.element = null;
      this.globalData = null;
      this.maskElement = null;
      this.data = null;
      this.masksProperties = null;
    };
    var filtersFactory = function () {
      var ob = {};
      ob.createFilter = createFilter;
      ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
      function createFilter(filId, skipCoordinates) {
        var fil = createNS('filter');
        fil.setAttribute('id', filId);
        if (skipCoordinates !== true) {
          fil.setAttribute('filterUnits', 'objectBoundingBox');
          fil.setAttribute('x', '0%');
          fil.setAttribute('y', '0%');
          fil.setAttribute('width', '100%');
          fil.setAttribute('height', '100%');
        }
        return fil;
      }
      function createAlphaToLuminanceFilter() {
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type', 'matrix');
        feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
        feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
        return feColorMatrix;
      }
      return ob;
    }();
    var featureSupport = function () {
      var ob = {
        maskType: true,
        svgLumaHidden: true,
        offscreenCanvas: typeof OffscreenCanvas !== 'undefined'
      };
      if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
        ob.maskType = false;
      }
      if (/firefox/i.test(navigator.userAgent)) {
        ob.svgLumaHidden = false;
      }
      return ob;
    }();
    var registeredEffects$1 = {};
    var idPrefix = 'filter_result_';
    function SVGEffects(elem) {
      var i;
      var source = 'SourceGraphic';
      var len = elem.data.ef ? elem.data.ef.length : 0;
      var filId = createElementID();
      var fil = filtersFactory.createFilter(filId, true);
      var count = 0;
      this.filters = [];
      var filterManager;
      for (i = 0; i < len; i += 1) {
        filterManager = null;
        var type = elem.data.ef[i].ty;
        if (registeredEffects$1[type]) {
          var Effect = registeredEffects$1[type].effect;
          filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);
          source = idPrefix + count;
          if (registeredEffects$1[type].countsAsEffect) {
            count += 1;
          }
        }
        if (filterManager) {
          this.filters.push(filterManager);
        }
      }
      if (count) {
        elem.globalData.defs.appendChild(fil);
        elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
      }
      if (this.filters.length) {
        elem.addRenderableComponent(this);
      }
    }
    SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
      var i;
      var len = this.filters.length;
      for (i = 0; i < len; i += 1) {
        this.filters[i].renderFrame(_isFirstFrame);
      }
    };
    SVGEffects.prototype.getEffects = function (type) {
      var i;
      var len = this.filters.length;
      var effects = [];
      for (i = 0; i < len; i += 1) {
        if (this.filters[i].type === type) {
          effects.push(this.filters[i]);
        }
      }
      return effects;
    };
    function registerEffect$1(id, effect, countsAsEffect) {
      registeredEffects$1[id] = {
        effect: effect,
        countsAsEffect: countsAsEffect
      };
    }
    function SVGBaseElement() {}
    SVGBaseElement.prototype = {
      initRendererElement: function initRendererElement() {
        this.layerElement = createNS('g');
      },
      createContainerElements: function createContainerElements() {
        this.matteElement = createNS('g');
        this.transformedElement = this.layerElement;
        this.maskedElement = this.layerElement;
        this._sizeChanged = false;
        var layerElementParent = null; // If this layer acts as a mask for the following layer

        if (this.data.td) {
          this.matteMasks = {};
          var gg = createNS('g');
          gg.setAttribute('id', this.layerId);
          gg.appendChild(this.layerElement);
          layerElementParent = gg;
          this.globalData.defs.appendChild(gg);
        } else if (this.data.tt) {
          this.matteElement.appendChild(this.layerElement);
          layerElementParent = this.matteElement;
          this.baseElement = this.matteElement;
        } else {
          this.baseElement = this.layerElement;
        }
        if (this.data.ln) {
          this.layerElement.setAttribute('id', this.data.ln);
        }
        if (this.data.cl) {
          this.layerElement.setAttribute('class', this.data.cl);
        } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped

        if (this.data.ty === 0 && !this.data.hd) {
          var cp = createNS('clipPath');
          var pt = createNS('path');
          pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
          var clipId = createElementID();
          cp.setAttribute('id', clipId);
          cp.appendChild(pt);
          this.globalData.defs.appendChild(cp);
          if (this.checkMasks()) {
            var cpGroup = createNS('g');
            cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
            cpGroup.appendChild(this.layerElement);
            this.transformedElement = cpGroup;
            if (layerElementParent) {
              layerElementParent.appendChild(this.transformedElement);
            } else {
              this.baseElement = this.transformedElement;
            }
          } else {
            this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
          }
        }
        if (this.data.bm !== 0) {
          this.setBlendMode();
        }
      },
      renderElement: function renderElement() {
        if (this.finalTransform._localMatMdf) {
          this.transformedElement.setAttribute('transform', this.finalTransform.localMat.to2dCSS());
        }
        if (this.finalTransform._opMdf) {
          this.transformedElement.setAttribute('opacity', this.finalTransform.localOpacity);
        }
      },
      destroyBaseElement: function destroyBaseElement() {
        this.layerElement = null;
        this.matteElement = null;
        this.maskManager.destroy();
      },
      getBaseElement: function getBaseElement() {
        if (this.data.hd) {
          return null;
        }
        return this.baseElement;
      },
      createRenderableComponents: function createRenderableComponents() {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
        this.renderableEffectsManager = new SVGEffects(this);
        this.searchEffectTransforms();
      },
      getMatte: function getMatte(matteType) {
        // This should not be a common case. But for backward compatibility, we'll create the matte object.
        // It solves animations that have two consecutive layers marked as matte masks.
        // Which is an undefined behavior in AE.
        if (!this.matteMasks) {
          this.matteMasks = {};
        }
        if (!this.matteMasks[matteType]) {
          var id = this.layerId + '_' + matteType;
          var filId;
          var fil;
          var useElement;
          var gg;
          if (matteType === 1 || matteType === 3) {
            var masker = createNS('mask');
            masker.setAttribute('id', id);
            masker.setAttribute('mask-type', matteType === 3 ? 'luminance' : 'alpha');
            useElement = createNS('use');
            useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
            masker.appendChild(useElement);
            this.globalData.defs.appendChild(masker);
            if (!featureSupport.maskType && matteType === 1) {
              masker.setAttribute('mask-type', 'luminance');
              filId = createElementID();
              fil = filtersFactory.createFilter(filId);
              this.globalData.defs.appendChild(fil);
              fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
              gg = createNS('g');
              gg.appendChild(useElement);
              masker.appendChild(gg);
              gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
            }
          } else if (matteType === 2) {
            var maskGroup = createNS('mask');
            maskGroup.setAttribute('id', id);
            maskGroup.setAttribute('mask-type', 'alpha');
            var maskGrouper = createNS('g');
            maskGroup.appendChild(maskGrouper);
            filId = createElementID();
            fil = filtersFactory.createFilter(filId); /// /

            var feCTr = createNS('feComponentTransfer');
            feCTr.setAttribute('in', 'SourceGraphic');
            fil.appendChild(feCTr);
            var feFunc = createNS('feFuncA');
            feFunc.setAttribute('type', 'table');
            feFunc.setAttribute('tableValues', '1.0 0.0');
            feCTr.appendChild(feFunc); /// /

            this.globalData.defs.appendChild(fil);
            var alphaRect = createNS('rect');
            alphaRect.setAttribute('width', this.comp.data.w);
            alphaRect.setAttribute('height', this.comp.data.h);
            alphaRect.setAttribute('x', '0');
            alphaRect.setAttribute('y', '0');
            alphaRect.setAttribute('fill', '#ffffff');
            alphaRect.setAttribute('opacity', '0');
            maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
            maskGrouper.appendChild(alphaRect);
            useElement = createNS('use');
            useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);
            maskGrouper.appendChild(useElement);
            if (!featureSupport.maskType) {
              maskGroup.setAttribute('mask-type', 'luminance');
              fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
              gg = createNS('g');
              maskGrouper.appendChild(alphaRect);
              gg.appendChild(this.layerElement);
              maskGrouper.appendChild(gg);
            }
            this.globalData.defs.appendChild(maskGroup);
          }
          this.matteMasks[matteType] = id;
        }
        return this.matteMasks[matteType];
      },
      setMatte: function setMatte(id) {
        if (!this.matteElement) {
          return;
        }
        this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
      }
    };

    /**
     * @file
     * Handles AE's layer parenting property.
     *
     */
    function HierarchyElement() {}
    HierarchyElement.prototype = {
      /**
         * @function
         * Initializes hierarchy properties
         *
         */
      initHierarchy: function initHierarchy() {
        // element's parent list
        this.hierarchy = []; // if element is parent of another layer _isParent will be true

        this._isParent = false;
        this.checkParenting();
      },
      /**
         * @function
         * Sets layer's hierarchy.
         * @param {array} hierarch
         * layer's parent list
         *
         */
      setHierarchy: function setHierarchy(hierarchy) {
        this.hierarchy = hierarchy;
      },
      /**
         * @function
         * Sets layer as parent.
         *
         */
      setAsParent: function setAsParent() {
        this._isParent = true;
      },
      /**
         * @function
         * Searches layer's parenting chain
         *
         */
      checkParenting: function checkParenting() {
        if (this.data.parent !== undefined) {
          this.comp.buildElementParenting(this, this.data.parent, []);
        }
      }
    };
    function RenderableDOMElement() {}
    (function () {
      var _prototype = {
        initElement: function initElement(data, globalData, comp) {
          this.initFrame();
          this.initBaseData(data, globalData, comp);
          this.initTransform(data, globalData, comp);
          this.initHierarchy();
          this.initRenderable();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          this.createContent();
          this.hide();
        },
        hide: function hide() {
          // console.log('HIDE', this);
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            var elem = this.baseElement || this.layerElement;
            elem.style.display = 'none';
            this.hidden = true;
          }
        },
        show: function show() {
          // console.log('SHOW', this);
          if (this.isInRange && !this.isTransparent) {
            if (!this.data.hd) {
              var elem = this.baseElement || this.layerElement;
              elem.style.display = 'block';
            }
            this.hidden = false;
            this._isFirstFrame = true;
          }
        },
        renderFrame: function renderFrame() {
          // If it is exported as hidden (data.hd === true) no need to render
          // If it is not visible no need to render
          if (this.data.hd || this.hidden) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderLocalTransform();
          this.renderElement();
          this.renderInnerContent();
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        renderInnerContent: function renderInnerContent() {},
        prepareFrame: function prepareFrame(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
          this.checkTransparency();
        },
        destroy: function destroy() {
          this.innerElem = null;
          this.destroyBaseElement();
        }
      };
      extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
    })();
    function IImageElement(data, globalData, comp) {
      this.assetData = globalData.getAssetData(data.refId);
      if (this.assetData && this.assetData.sid) {
        this.assetData = globalData.slotManager.getProp(this.assetData);
      }
      this.initElement(data, globalData, comp);
      this.sourceRect = {
        top: 0,
        left: 0,
        width: this.assetData.w,
        height: this.assetData.h
      };
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
    IImageElement.prototype.createContent = function () {
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      this.innerElem = createNS('image');
      this.innerElem.setAttribute('width', this.assetData.w + 'px');
      this.innerElem.setAttribute('height', this.assetData.h + 'px');
      this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
      this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
      this.layerElement.appendChild(this.innerElem);
    };
    IImageElement.prototype.sourceRectAtTime = function () {
      return this.sourceRect;
    };
    function ProcessedElement(element, position) {
      this.elem = element;
      this.pos = position;
    }
    function IShapeElement() {}
    IShapeElement.prototype = {
      addShapeToModifiers: function addShapeToModifiers(data) {
        var i;
        var len = this.shapeModifiers.length;
        for (i = 0; i < len; i += 1) {
          this.shapeModifiers[i].addShape(data);
        }
      },
      isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
        var i = 0;
        var len = this.shapeModifiers.length;
        while (i < len) {
          if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
            return true;
          }
        }
        return false;
      },
      renderModifiers: function renderModifiers() {
        if (!this.shapeModifiers.length) {
          return;
        }
        var i;
        var len = this.shapes.length;
        for (i = 0; i < len; i += 1) {
          this.shapes[i].sh.reset();
        }
        len = this.shapeModifiers.length;
        var shouldBreakProcess;
        for (i = len - 1; i >= 0; i -= 1) {
          shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice
          // TODO: find a better solution for this

          if (shouldBreakProcess) {
            break;
          }
        }
      },
      searchProcessedElement: function searchProcessedElement(elem) {
        var elements = this.processedElements;
        var i = 0;
        var len = elements.length;
        while (i < len) {
          if (elements[i].elem === elem) {
            return elements[i].pos;
          }
          i += 1;
        }
        return 0;
      },
      addProcessedElement: function addProcessedElement(elem, pos) {
        var elements = this.processedElements;
        var i = elements.length;
        while (i) {
          i -= 1;
          if (elements[i].elem === elem) {
            elements[i].pos = pos;
            return;
          }
        }
        elements.push(new ProcessedElement(elem, pos));
      },
      prepareFrame: function prepareFrame(num) {
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
      }
    };
    var lineCapEnum = {
      1: 'butt',
      2: 'round',
      3: 'square'
    };
    var lineJoinEnum = {
      1: 'miter',
      2: 'round',
      3: 'bevel'
    };
    function SVGShapeData(transformers, level, shape) {
      this.caches = [];
      this.styles = [];
      this.transformers = transformers;
      this.lStr = '';
      this.sh = shape;
      this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.
      // For now, since shapes add up with other shapes. They have to be calculated every time.
      // One way of finding out is checking if all styles associated to this shape depend only of this shape

      this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated

      var i = 0;
      var len = transformers.length;
      while (i < len) {
        if (transformers[i].mProps.dynamicProperties.length) {
          this._isAnimated = true;
          break;
        }
        i += 1;
      }
    }
    SVGShapeData.prototype.setAsAnimated = function () {
      this._isAnimated = true;
    };
    function SVGStyleData(data, level) {
      this.data = data;
      this.type = data.ty;
      this.d = '';
      this.lvl = level;
      this._mdf = false;
      this.closed = data.hd === true;
      this.pElem = createNS('path');
      this.msElem = null;
    }
    SVGStyleData.prototype.reset = function () {
      this.d = '';
      this._mdf = false;
    };
    function DashProperty(elem, data, renderer, container) {
      this.elem = elem;
      this.frameId = -1;
      this.dataProps = createSizedArray(data.length);
      this.renderer = renderer;
      this.k = false;
      this.dashStr = '';
      this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
      this.dashoffset = createTypedArray('float32', 1);
      this.initDynamicPropertyContainer(container);
      var i;
      var len = data.length || 0;
      var prop;
      for (i = 0; i < len; i += 1) {
        prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
        this.k = prop.k || this.k;
        this.dataProps[i] = {
          n: data[i].n,
          p: prop
        };
      }
      if (!this.k) {
        this.getValue(true);
      }
      this._isAnimated = this.k;
    }
    DashProperty.prototype.getValue = function (forceRender) {
      if (this.elem.globalData.frameId === this.frameId && !forceRender) {
        return;
      }
      this.frameId = this.elem.globalData.frameId;
      this.iterateDynamicProperties();
      this._mdf = this._mdf || forceRender;
      if (this._mdf) {
        var i = 0;
        var len = this.dataProps.length;
        if (this.renderer === 'svg') {
          this.dashStr = '';
        }
        for (i = 0; i < len; i += 1) {
          if (this.dataProps[i].n !== 'o') {
            if (this.renderer === 'svg') {
              this.dashStr += ' ' + this.dataProps[i].p.v;
            } else {
              this.dashArray[i] = this.dataProps[i].p.v;
            }
          } else {
            this.dashoffset[0] = this.dataProps[i].p.v;
          }
        }
      }
    };
    extendPrototype([DynamicPropertyContainer], DashProperty);
    function SVGStrokeStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
      this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
      this.d = new DashProperty(elem, data.d || {}, 'svg', this);
      this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
      this.style = styleOb;
      this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
    function SVGFillStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
      this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
      this.style = styleOb;
    }
    extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
    function SVGNoStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.style = styleOb;
    }
    extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
    function GradientProperty(elem, data, container) {
      this.data = data;
      this.c = createTypedArray('uint8c', data.p * 4);
      var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
      this.o = createTypedArray('float32', cLength);
      this._cmdf = false;
      this._omdf = false;
      this._collapsable = this.checkCollapsable();
      this._hasOpacity = cLength;
      this.initDynamicPropertyContainer(container);
      this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
      this.k = this.prop.k;
      this.getValue(true);
    }
    GradientProperty.prototype.comparePoints = function (values, points) {
      var i = 0;
      var len = this.o.length / 2;
      var diff;
      while (i < len) {
        diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
        if (diff > 0.01) {
          return false;
        }
        i += 1;
      }
      return true;
    };
    GradientProperty.prototype.checkCollapsable = function () {
      if (this.o.length / 2 !== this.c.length / 4) {
        return false;
      }
      if (this.data.k.k[0].s) {
        var i = 0;
        var len = this.data.k.k.length;
        while (i < len) {
          if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
            return false;
          }
          i += 1;
        }
      } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
        return false;
      }
      return true;
    };
    GradientProperty.prototype.getValue = function (forceRender) {
      this.prop.getValue();
      this._mdf = false;
      this._cmdf = false;
      this._omdf = false;
      if (this.prop._mdf || forceRender) {
        var i;
        var len = this.data.p * 4;
        var mult;
        var val;
        for (i = 0; i < len; i += 1) {
          mult = i % 4 === 0 ? 100 : 255;
          val = Math.round(this.prop.v[i] * mult);
          if (this.c[i] !== val) {
            this.c[i] = val;
            this._cmdf = !forceRender;
          }
        }
        if (this.o.length) {
          len = this.prop.v.length;
          for (i = this.data.p * 4; i < len; i += 1) {
            mult = i % 2 === 0 ? 100 : 1;
            val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
            if (this.o[i - this.data.p * 4] !== val) {
              this.o[i - this.data.p * 4] = val;
              this._omdf = !forceRender;
            }
          }
        }
        this._mdf = !forceRender;
      }
    };
    extendPrototype([DynamicPropertyContainer], GradientProperty);
    function SVGGradientFillStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.initGradientData(elem, data, styleOb);
    }
    SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
      this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
      this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
      this.h = PropertyFactory.getProp(elem, data.h || {
        k: 0
      }, 0, 0.01, this);
      this.a = PropertyFactory.getProp(elem, data.a || {
        k: 0
      }, 0, degToRads, this);
      this.g = new GradientProperty(elem, data.g, this);
      this.style = styleOb;
      this.stops = [];
      this.setGradientData(styleOb.pElem, data);
      this.setGradientOpacity(data, styleOb);
      this._isAnimated = !!this._isAnimated;
    };
    SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
      var gradientId = createElementID();
      var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
      gfill.setAttribute('id', gradientId);
      gfill.setAttribute('spreadMethod', 'pad');
      gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
      var stops = [];
      var stop;
      var j;
      var jLen;
      jLen = data.g.p * 4;
      for (j = 0; j < jLen; j += 4) {
        stop = createNS('stop');
        gfill.appendChild(stop);
        stops.push(stop);
      }
      pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');
      this.gf = gfill;
      this.cst = stops;
    };
    SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
      if (this.g._hasOpacity && !this.g._collapsable) {
        var stop;
        var j;
        var jLen;
        var mask = createNS('mask');
        var maskElement = createNS('path');
        mask.appendChild(maskElement);
        var opacityId = createElementID();
        var maskId = createElementID();
        mask.setAttribute('id', maskId);
        var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
        opFill.setAttribute('id', opacityId);
        opFill.setAttribute('spreadMethod', 'pad');
        opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
        jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
        var stops = this.stops;
        for (j = data.g.p * 4; j < jLen; j += 2) {
          stop = createNS('stop');
          stop.setAttribute('stop-color', 'rgb(255,255,255)');
          opFill.appendChild(stop);
          stops.push(stop);
        }
        maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');
        if (data.ty === 'gs') {
          maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
          maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
          if (data.lj === 1) {
            maskElement.setAttribute('stroke-miterlimit', data.ml);
          }
        }
        this.of = opFill;
        this.ms = mask;
        this.ost = stops;
        this.maskId = maskId;
        styleOb.msElem = maskElement;
      }
    };
    extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
    function SVGGradientStrokeStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
      this.d = new DashProperty(elem, data.d || {}, 'svg', this);
      this.initGradientData(elem, data, styleOb);
      this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
    function ShapeGroupData() {
      this.it = [];
      this.prevViewData = [];
      this.gr = createNS('g');
    }
    function SVGTransformData(mProps, op, container) {
      this.transform = {
        mProps: mProps,
        op: op,
        container: container
      };
      this.elements = [];
      this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }
    var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
      if (length === 0) {
        return '';
      }
      var _o = pathNodes.o;
      var _i = pathNodes.i;
      var _v = pathNodes.v;
      var i;
      var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
      for (i = 1; i < length; i += 1) {
        shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
      }
      if (closed && length) {
        shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        shapeString += 'z';
      }
      return shapeString;
    };
    var SVGElementsRenderer = function () {
      var _identityMatrix = new Matrix();
      var _matrixHelper = new Matrix();
      var ob = {
        createRenderFunction: createRenderFunction
      };
      function createRenderFunction(data) {
        switch (data.ty) {
          case 'fl':
            return renderFill;
          case 'gf':
            return renderGradient;
          case 'gs':
            return renderGradientStroke;
          case 'st':
            return renderStroke;
          case 'sh':
          case 'el':
          case 'rc':
          case 'sr':
            return renderPath;
          case 'tr':
            return renderContentTransform;
          case 'no':
            return renderNoop;
          default:
            return null;
        }
      }
      function renderContentTransform(styleData, itemData, isFirstFrame) {
        if (isFirstFrame || itemData.transform.op._mdf) {
          itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
        }
        if (isFirstFrame || itemData.transform.mProps._mdf) {
          itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
        }
      }
      function renderNoop() {}
      function renderPath(styleData, itemData, isFirstFrame) {
        var j;
        var jLen;
        var pathStringTransformed;
        var redraw;
        var pathNodes;
        var l;
        var lLen = itemData.styles.length;
        var lvl = itemData.lvl;
        var paths;
        var mat;
        var iterations;
        var k;
        for (l = 0; l < lLen; l += 1) {
          redraw = itemData.sh._mdf || isFirstFrame;
          if (itemData.styles[l].lvl < lvl) {
            mat = _matrixHelper.reset();
            iterations = lvl - itemData.styles[l].lvl;
            k = itemData.transformers.length - 1;
            while (!redraw && iterations > 0) {
              redraw = itemData.transformers[k].mProps._mdf || redraw;
              iterations -= 1;
              k -= 1;
            }
            if (redraw) {
              iterations = lvl - itemData.styles[l].lvl;
              k = itemData.transformers.length - 1;
              while (iterations > 0) {
                mat.multiply(itemData.transformers[k].mProps.v);
                iterations -= 1;
                k -= 1;
              }
            }
          } else {
            mat = _identityMatrix;
          }
          paths = itemData.sh.paths;
          jLen = paths._length;
          if (redraw) {
            pathStringTransformed = '';
            for (j = 0; j < jLen; j += 1) {
              pathNodes = paths.shapes[j];
              if (pathNodes && pathNodes._length) {
                pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
              }
            }
            itemData.caches[l] = pathStringTransformed;
          } else {
            pathStringTransformed = itemData.caches[l];
          }
          itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
          itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
        }
      }
      function renderFill(styleData, itemData, isFirstFrame) {
        var styleElem = itemData.style;
        if (itemData.c._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
        }
        if (itemData.o._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
        }
      }
      function renderGradientStroke(styleData, itemData, isFirstFrame) {
        renderGradient(styleData, itemData, isFirstFrame);
        renderStroke(styleData, itemData, isFirstFrame);
      }
      function renderGradient(styleData, itemData, isFirstFrame) {
        var gfill = itemData.gf;
        var hasOpacity = itemData.g._hasOpacity;
        var pt1 = itemData.s.v;
        var pt2 = itemData.e.v;
        if (itemData.o._mdf || isFirstFrame) {
          var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
          itemData.style.pElem.setAttribute(attr, itemData.o.v);
        }
        if (itemData.s._mdf || isFirstFrame) {
          var attr1 = styleData.t === 1 ? 'x1' : 'cx';
          var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
          gfill.setAttribute(attr1, pt1[0]);
          gfill.setAttribute(attr2, pt1[1]);
          if (hasOpacity && !itemData.g._collapsable) {
            itemData.of.setAttribute(attr1, pt1[0]);
            itemData.of.setAttribute(attr2, pt1[1]);
          }
        }
        var stops;
        var i;
        var len;
        var stop;
        if (itemData.g._cmdf || isFirstFrame) {
          stops = itemData.cst;
          var cValues = itemData.g.c;
          len = stops.length;
          for (i = 0; i < len; i += 1) {
            stop = stops[i];
            stop.setAttribute('offset', cValues[i * 4] + '%');
            stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
          }
        }
        if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
          var oValues = itemData.g.o;
          if (itemData.g._collapsable) {
            stops = itemData.cst;
          } else {
            stops = itemData.ost;
          }
          len = stops.length;
          for (i = 0; i < len; i += 1) {
            stop = stops[i];
            if (!itemData.g._collapsable) {
              stop.setAttribute('offset', oValues[i * 2] + '%');
            }
            stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
          }
        }
        if (styleData.t === 1) {
          if (itemData.e._mdf || isFirstFrame) {
            gfill.setAttribute('x2', pt2[0]);
            gfill.setAttribute('y2', pt2[1]);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute('x2', pt2[0]);
              itemData.of.setAttribute('y2', pt2[1]);
            }
          }
        } else {
          var rad;
          if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            gfill.setAttribute('r', rad);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute('r', rad);
            }
          }
          if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
            if (!rad) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            }
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
            var percent = itemData.h.v;
            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }
            var dist = rad * percent;
            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            gfill.setAttribute('fx', x);
            gfill.setAttribute('fy', y);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute('fx', x);
              itemData.of.setAttribute('fy', y);
            }
          } // gfill.setAttribute('fy','200');
        }
      }
      function renderStroke(styleData, itemData, isFirstFrame) {
        var styleElem = itemData.style;
        var d = itemData.d;
        if (d && (d._mdf || isFirstFrame) && d.dashStr) {
          styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
          styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
        }
        if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
          styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
        }
        if (itemData.o._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
        }
        if (itemData.w._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
          if (styleElem.msElem) {
            styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
          }
        }
      }
      return ob;
    }();
    function SVGShapeElement(data, globalData, comp) {
      // List of drawable elements
      this.shapes = []; // Full shape data

      this.shapesData = data.shapes; // List of styles that will be applied to shapes

      this.stylesList = []; // List of modifiers that will be applied to shapes

      this.shapeModifiers = []; // List of items in shape tree

      this.itemsData = []; // List of items in previous shape tree

      this.processedElements = []; // List of animated components

      this.animatedContents = [];
      this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
      // List of elements that have been created

      this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
    SVGShapeElement.prototype.initSecondaryElement = function () {};
    SVGShapeElement.prototype.identityMatrix = new Matrix();
    SVGShapeElement.prototype.buildExpressionInterface = function () {};
    SVGShapeElement.prototype.createContent = function () {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
      this.filterUniqueShapes();
    };
    /*
    This method searches for multiple shapes that affect a single element and one of them is animated
    */

    SVGShapeElement.prototype.filterUniqueShapes = function () {
      var i;
      var len = this.shapes.length;
      var shape;
      var j;
      var jLen = this.stylesList.length;
      var style;
      var tempShapes = [];
      var areAnimated = false;
      for (j = 0; j < jLen; j += 1) {
        style = this.stylesList[j];
        areAnimated = false;
        tempShapes.length = 0;
        for (i = 0; i < len; i += 1) {
          shape = this.shapes[i];
          if (shape.styles.indexOf(style) !== -1) {
            tempShapes.push(shape);
            areAnimated = shape._isAnimated || areAnimated;
          }
        }
        if (tempShapes.length > 1 && areAnimated) {
          this.setShapesAsAnimated(tempShapes);
        }
      }
    };
    SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
      var i;
      var len = shapes.length;
      for (i = 0; i < len; i += 1) {
        shapes[i].setAsAnimated();
      }
    };
    SVGShapeElement.prototype.createStyleElement = function (data, level) {
      // TODO: prevent drawing of hidden styles
      var elementData;
      var styleOb = new SVGStyleData(data, level);
      var pathElement = styleOb.pElem;
      if (data.ty === 'st') {
        elementData = new SVGStrokeStyleData(this, data, styleOb);
      } else if (data.ty === 'fl') {
        elementData = new SVGFillStyleData(this, data, styleOb);
      } else if (data.ty === 'gf' || data.ty === 'gs') {
        var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
        elementData = new GradientConstructor(this, data, styleOb);
        this.globalData.defs.appendChild(elementData.gf);
        if (elementData.maskId) {
          this.globalData.defs.appendChild(elementData.ms);
          this.globalData.defs.appendChild(elementData.of);
          pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');
        }
      } else if (data.ty === 'no') {
        elementData = new SVGNoStyleData(this, data, styleOb);
      }
      if (data.ty === 'st' || data.ty === 'gs') {
        pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
        pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
        pathElement.setAttribute('fill-opacity', '0');
        if (data.lj === 1) {
          pathElement.setAttribute('stroke-miterlimit', data.ml);
        }
      }
      if (data.r === 2) {
        pathElement.setAttribute('fill-rule', 'evenodd');
      }
      if (data.ln) {
        pathElement.setAttribute('id', data.ln);
      }
      if (data.cl) {
        pathElement.setAttribute('class', data.cl);
      }
      if (data.bm) {
        pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
      }
      this.stylesList.push(styleOb);
      this.addToAnimatedContents(data, elementData);
      return elementData;
    };
    SVGShapeElement.prototype.createGroupElement = function (data) {
      var elementData = new ShapeGroupData();
      if (data.ln) {
        elementData.gr.setAttribute('id', data.ln);
      }
      if (data.cl) {
        elementData.gr.setAttribute('class', data.cl);
      }
      if (data.bm) {
        elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
      }
      return elementData;
    };
    SVGShapeElement.prototype.createTransformElement = function (data, container) {
      var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
      var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
      this.addToAnimatedContents(data, elementData);
      return elementData;
    };
    SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
      var ty = 4;
      if (data.ty === 'rc') {
        ty = 5;
      } else if (data.ty === 'el') {
        ty = 6;
      } else if (data.ty === 'sr') {
        ty = 7;
      }
      var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
      var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
      this.shapes.push(elementData);
      this.addShapeToModifiers(elementData);
      this.addToAnimatedContents(data, elementData);
      return elementData;
    };
    SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
      var i = 0;
      var len = this.animatedContents.length;
      while (i < len) {
        if (this.animatedContents[i].element === element) {
          return;
        }
        i += 1;
      }
      this.animatedContents.push({
        fn: SVGElementsRenderer.createRenderFunction(data),
        element: element,
        data: data
      });
    };
    SVGShapeElement.prototype.setElementStyles = function (elementData) {
      var arr = elementData.styles;
      var j;
      var jLen = this.stylesList.length;
      for (j = 0; j < jLen; j += 1) {
        if (!this.stylesList[j].closed) {
          arr.push(this.stylesList[j]);
        }
      }
    };
    SVGShapeElement.prototype.reloadShapes = function () {
      this._isFirstFrame = true;
      var i;
      var len = this.itemsData.length;
      for (i = 0; i < len; i += 1) {
        this.prevViewData[i] = this.itemsData[i];
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
      this.filterUniqueShapes();
      len = this.dynamicProperties.length;
      for (i = 0; i < len; i += 1) {
        this.dynamicProperties[i].getValue();
      }
      this.renderModifiers();
    };
    SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
      var ownTransformers = [].concat(transformers);
      var i;
      var len = arr.length - 1;
      var j;
      var jLen;
      var ownStyles = [];
      var ownModifiers = [];
      var currentTransform;
      var modifier;
      var processedPos;
      for (i = len; i >= 0; i -= 1) {
        processedPos = this.searchProcessedElement(arr[i]);
        if (!processedPos) {
          arr[i]._render = render;
        } else {
          itemsData[i] = prevViewData[processedPos - 1];
        }
        if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {
          if (!processedPos) {
            itemsData[i] = this.createStyleElement(arr[i], level);
          } else {
            itemsData[i].style.closed = false;
          }
          if (arr[i]._render) {
            if (itemsData[i].style.pElem.parentNode !== container) {
              container.appendChild(itemsData[i].style.pElem);
            }
          }
          ownStyles.push(itemsData[i].style);
        } else if (arr[i].ty === 'gr') {
          if (!processedPos) {
            itemsData[i] = this.createGroupElement(arr[i]);
          } else {
            jLen = itemsData[i].it.length;
            for (j = 0; j < jLen; j += 1) {
              itemsData[i].prevViewData[j] = itemsData[i].it[j];
            }
          }
          this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
          if (arr[i]._render) {
            if (itemsData[i].gr.parentNode !== container) {
              container.appendChild(itemsData[i].gr);
            }
          }
        } else if (arr[i].ty === 'tr') {
          if (!processedPos) {
            itemsData[i] = this.createTransformElement(arr[i], container);
          }
          currentTransform = itemsData[i].transform;
          ownTransformers.push(currentTransform);
        } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
          if (!processedPos) {
            itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
          }
          this.setElementStyles(itemsData[i]);
        } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            modifier.init(this, arr[i]);
            itemsData[i] = modifier;
            this.shapeModifiers.push(modifier);
          } else {
            modifier = itemsData[i];
            modifier.closed = false;
          }
          ownModifiers.push(modifier);
        } else if (arr[i].ty === 'rp') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            itemsData[i] = modifier;
            modifier.init(this, arr, i, itemsData);
            this.shapeModifiers.push(modifier);
            render = false;
          } else {
            modifier = itemsData[i];
            modifier.closed = true;
          }
          ownModifiers.push(modifier);
        }
        this.addProcessedElement(arr[i], i + 1);
      }
      len = ownStyles.length;
      for (i = 0; i < len; i += 1) {
        ownStyles[i].closed = true;
      }
      len = ownModifiers.length;
      for (i = 0; i < len; i += 1) {
        ownModifiers[i].closed = true;
      }
    };
    SVGShapeElement.prototype.renderInnerContent = function () {
      this.renderModifiers();
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        this.stylesList[i].reset();
      }
      this.renderShape();
      for (i = 0; i < len; i += 1) {
        if (this.stylesList[i]._mdf || this._isFirstFrame) {
          if (this.stylesList[i].msElem) {
            this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers

            this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
          }
          this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
        }
      }
    };
    SVGShapeElement.prototype.renderShape = function () {
      var i;
      var len = this.animatedContents.length;
      var animatedContent;
      for (i = 0; i < len; i += 1) {
        animatedContent = this.animatedContents[i];
        if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
          animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
        }
      }
    };
    SVGShapeElement.prototype.destroy = function () {
      this.destroyBaseElement();
      this.shapesData = null;
      this.itemsData = null;
    };
    function LetterProps(o, sw, sc, fc, m, p) {
      this.o = o;
      this.sw = sw;
      this.sc = sc;
      this.fc = fc;
      this.m = m;
      this.p = p;
      this._mdf = {
        o: true,
        sw: !!sw,
        sc: !!sc,
        fc: !!fc,
        m: true,
        p: true
      };
    }
    LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
      this._mdf.o = false;
      this._mdf.sw = false;
      this._mdf.sc = false;
      this._mdf.fc = false;
      this._mdf.m = false;
      this._mdf.p = false;
      var updated = false;
      if (this.o !== o) {
        this.o = o;
        this._mdf.o = true;
        updated = true;
      }
      if (this.sw !== sw) {
        this.sw = sw;
        this._mdf.sw = true;
        updated = true;
      }
      if (this.sc !== sc) {
        this.sc = sc;
        this._mdf.sc = true;
        updated = true;
      }
      if (this.fc !== fc) {
        this.fc = fc;
        this._mdf.fc = true;
        updated = true;
      }
      if (this.m !== m) {
        this.m = m;
        this._mdf.m = true;
        updated = true;
      }
      if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
        this.p = p;
        this._mdf.p = true;
        updated = true;
      }
      return updated;
    };
    function TextProperty(elem, data) {
      this._frameId = initialDefaultFrame;
      this.pv = '';
      this.v = '';
      this.kf = false;
      this._isFirstFrame = true;
      this._mdf = false;
      if (data.d && data.d.sid) {
        data.d = elem.globalData.slotManager.getProp(data.d);
      }
      this.data = data;
      this.elem = elem;
      this.comp = this.elem.comp;
      this.keysIndex = 0;
      this.canResize = false;
      this.minimumFontSize = 1;
      this.effectsSequence = [];
      this.currentData = {
        ascent: 0,
        boxWidth: this.defaultBoxWidth,
        f: '',
        fStyle: '',
        fWeight: '',
        fc: '',
        j: '',
        justifyOffset: '',
        l: [],
        lh: 0,
        lineWidths: [],
        ls: '',
        of: '',
        s: '',
        sc: '',
        sw: 0,
        t: 0,
        tr: 0,
        sz: 0,
        ps: null,
        fillColorAnim: false,
        strokeColorAnim: false,
        strokeWidthAnim: false,
        yOffset: 0,
        finalSize: 0,
        finalText: [],
        finalLineHeight: 0,
        __complete: false
      };
      this.copyData(this.currentData, this.data.d.k[0].s);
      if (!this.searchProperty()) {
        this.completeTextData(this.currentData);
      }
    }
    TextProperty.prototype.defaultBoxWidth = [0, 0];
    TextProperty.prototype.copyData = function (obj, data) {
      for (var s in data) {
        if (Object.prototype.hasOwnProperty.call(data, s)) {
          obj[s] = data[s];
        }
      }
      return obj;
    };
    TextProperty.prototype.setCurrentData = function (data) {
      if (!data.__complete) {
        this.completeTextData(data);
      }
      this.currentData = data;
      this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
      this._mdf = true;
    };
    TextProperty.prototype.searchProperty = function () {
      return this.searchKeyframes();
    };
    TextProperty.prototype.searchKeyframes = function () {
      this.kf = this.data.d.k.length > 1;
      if (this.kf) {
        this.addEffect(this.getKeyframeValue.bind(this));
      }
      return this.kf;
    };
    TextProperty.prototype.addEffect = function (effectFunction) {
      this.effectsSequence.push(effectFunction);
      this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.getValue = function (_finalValue) {
      if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
        return;
      }
      this.currentData.t = this.data.d.k[this.keysIndex].s.t;
      var currentValue = this.currentData;
      var currentIndex = this.keysIndex;
      if (this.lock) {
        this.setCurrentData(this.currentData);
        return;
      }
      this.lock = true;
      this._mdf = false;
      var i;
      var len = this.effectsSequence.length;
      var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
      for (i = 0; i < len; i += 1) {
        // Checking if index changed to prevent creating a new object every time the expression updates.
        if (currentIndex !== this.keysIndex) {
          finalValue = this.effectsSequence[i](finalValue, finalValue.t);
        } else {
          finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
        }
      }
      if (currentValue !== finalValue) {
        this.setCurrentData(finalValue);
      }
      this.v = this.currentData;
      this.pv = this.v;
      this.lock = false;
      this.frameId = this.elem.globalData.frameId;
    };
    TextProperty.prototype.getKeyframeValue = function () {
      var textKeys = this.data.d.k;
      var frameNum = this.elem.comp.renderedFrame;
      var i = 0;
      var len = textKeys.length;
      while (i <= len - 1) {
        if (i === len - 1 || textKeys[i + 1].t > frameNum) {
          break;
        }
        i += 1;
      }
      if (this.keysIndex !== i) {
        this.keysIndex = i;
      }
      return this.data.d.k[this.keysIndex].s;
    };
    TextProperty.prototype.buildFinalText = function (text) {
      var charactersArray = [];
      var i = 0;
      var len = text.length;
      var charCode;
      var secondCharCode;
      var shouldCombine = false;
      var shouldCombineNext = false;
      var currentChars = '';
      while (i < len) {
        shouldCombine = shouldCombineNext;
        shouldCombineNext = false;
        charCode = text.charCodeAt(i);
        currentChars = text.charAt(i);
        if (FontManager.isCombinedCharacter(charCode)) {
          shouldCombine = true; // It's a potential surrogate pair (this is the High surrogate)
        } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          if (FontManager.isRegionalFlag(text, i)) {
            currentChars = text.substr(i, 14);
          } else {
            secondCharCode = text.charCodeAt(i + 1); // It's a surrogate pair (this is the Low surrogate)

            if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
              if (FontManager.isModifier(charCode, secondCharCode)) {
                currentChars = text.substr(i, 2);
                shouldCombine = true;
              } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {
                currentChars = text.substr(i, 4);
              } else {
                currentChars = text.substr(i, 2);
              }
            }
          }
        } else if (charCode > 0xDBFF) {
          secondCharCode = text.charCodeAt(i + 1);
          if (FontManager.isVariationSelector(charCode)) {
            shouldCombine = true;
          }
        } else if (FontManager.isZeroWidthJoiner(charCode)) {
          shouldCombine = true;
          shouldCombineNext = true;
        }
        if (shouldCombine) {
          charactersArray[charactersArray.length - 1] += currentChars;
          shouldCombine = false;
        } else {
          charactersArray.push(currentChars);
        }
        i += currentChars.length;
      }
      return charactersArray;
    };
    TextProperty.prototype.completeTextData = function (documentData) {
      documentData.__complete = true;
      var fontManager = this.elem.globalData.fontManager;
      var data = this.data;
      var letters = [];
      var i;
      var len;
      var newLineFlag;
      var index = 0;
      var val;
      var anchorGrouping = data.m.g;
      var currentSize = 0;
      var currentPos = 0;
      var currentLine = 0;
      var lineWidths = [];
      var lineWidth = 0;
      var maxLineWidth = 0;
      var j;
      var jLen;
      var fontData = fontManager.getFontByName(documentData.f);
      var charData;
      var cLength = 0;
      var fontProps = getFontProperties(fontData);
      documentData.fWeight = fontProps.weight;
      documentData.fStyle = fontProps.style;
      documentData.finalSize = documentData.s;
      documentData.finalText = this.buildFinalText(documentData.t);
      len = documentData.finalText.length;
      documentData.finalLineHeight = documentData.lh;
      var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
      var charCode;
      if (documentData.sz) {
        var flag = true;
        var boxWidth = documentData.sz[0];
        var boxHeight = documentData.sz[1];
        var currentHeight;
        var finalText;
        while (flag) {
          finalText = this.buildFinalText(documentData.t);
          currentHeight = 0;
          lineWidth = 0;
          len = finalText.length;
          trackingOffset = documentData.tr / 1000 * documentData.finalSize;
          var lastSpaceIndex = -1;
          for (i = 0; i < len; i += 1) {
            charCode = finalText[i].charCodeAt(0);
            newLineFlag = false;
            if (finalText[i] === ' ') {
              lastSpaceIndex = i;
            } else if (charCode === 13 || charCode === 3) {
              lineWidth = 0;
              newLineFlag = true;
              currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
            }
            if (fontManager.chars) {
              charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
              cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
            } else {
              // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
              cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
            }
            if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
              if (lastSpaceIndex === -1) {
                len += 1;
              } else {
                i = lastSpaceIndex;
              }
              currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r'); // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);

              lastSpaceIndex = -1;
              lineWidth = 0;
            } else {
              lineWidth += cLength;
              lineWidth += trackingOffset;
            }
          }
          currentHeight += fontData.ascent * documentData.finalSize / 100;
          if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
            documentData.finalSize -= 1;
            documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
          } else {
            documentData.finalText = finalText;
            len = documentData.finalText.length;
            flag = false;
          }
        }
      }
      lineWidth = -trackingOffset;
      cLength = 0;
      var uncollapsedSpaces = 0;
      var currentChar;
      for (i = 0; i < len; i += 1) {
        newLineFlag = false;
        currentChar = documentData.finalText[i];
        charCode = currentChar.charCodeAt(0);
        if (charCode === 13 || charCode === 3) {
          uncollapsedSpaces = 0;
          lineWidths.push(lineWidth);
          maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
          lineWidth = -2 * trackingOffset;
          val = '';
          newLineFlag = true;
          currentLine += 1;
        } else {
          val = currentChar;
        }
        if (fontManager.chars) {
          charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
          cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
        } else {
          // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
          // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
          cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
        } //

        if (currentChar === ' ') {
          uncollapsedSpaces += cLength + trackingOffset;
        } else {
          lineWidth += cLength + trackingOffset + uncollapsedSpaces;
          uncollapsedSpaces = 0;
        }
        letters.push({
          l: cLength,
          an: cLength,
          add: currentSize,
          n: newLineFlag,
          anIndexes: [],
          val: val,
          line: currentLine,
          animatorJustifyOffset: 0
        });
        if (anchorGrouping == 2) {
          // eslint-disable-line eqeqeq
          currentSize += cLength;
          if (val === '' || val === ' ' || i === len - 1) {
            if (val === '' || val === ' ') {
              currentSize -= cLength;
            }
            while (currentPos <= i) {
              letters[currentPos].an = currentSize;
              letters[currentPos].ind = index;
              letters[currentPos].extra = cLength;
              currentPos += 1;
            }
            index += 1;
            currentSize = 0;
          }
        } else if (anchorGrouping == 3) {
          // eslint-disable-line eqeqeq
          currentSize += cLength;
          if (val === '' || i === len - 1) {
            if (val === '') {
              currentSize -= cLength;
            }
            while (currentPos <= i) {
              letters[currentPos].an = currentSize;
              letters[currentPos].ind = index;
              letters[currentPos].extra = cLength;
              currentPos += 1;
            }
            currentSize = 0;
            index += 1;
          }
        } else {
          letters[index].ind = index;
          letters[index].extra = 0;
          index += 1;
        }
      }
      documentData.l = letters;
      maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
      lineWidths.push(lineWidth);
      if (documentData.sz) {
        documentData.boxWidth = documentData.sz[0];
        documentData.justifyOffset = 0;
      } else {
        documentData.boxWidth = maxLineWidth;
        switch (documentData.j) {
          case 1:
            documentData.justifyOffset = -documentData.boxWidth;
            break;
          case 2:
            documentData.justifyOffset = -documentData.boxWidth / 2;
            break;
          default:
            documentData.justifyOffset = 0;
        }
      }
      documentData.lineWidths = lineWidths;
      var animators = data.a;
      var animatorData;
      var letterData;
      jLen = animators.length;
      var based;
      var ind;
      var indexes = [];
      for (j = 0; j < jLen; j += 1) {
        animatorData = animators[j];
        if (animatorData.a.sc) {
          documentData.strokeColorAnim = true;
        }
        if (animatorData.a.sw) {
          documentData.strokeWidthAnim = true;
        }
        if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
          documentData.fillColorAnim = true;
        }
        ind = 0;
        based = animatorData.s.b;
        for (i = 0; i < len; i += 1) {
          letterData = letters[i];
          letterData.anIndexes[j] = ind;
          if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
            // eslint-disable-line eqeqeq
            if (animatorData.s.rn === 1) {
              indexes.push(ind);
            }
            ind += 1;
          }
        }
        data.a[j].s.totalChars = ind;
        var currentInd = -1;
        var newInd;
        if (animatorData.s.rn === 1) {
          for (i = 0; i < len; i += 1) {
            letterData = letters[i];
            if (currentInd != letterData.anIndexes[j]) {
              // eslint-disable-line eqeqeq
              currentInd = letterData.anIndexes[j];
              newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
            }
            letterData.anIndexes[j] = newInd;
          }
        }
      }
      documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
      documentData.ls = documentData.ls || 0;
      documentData.ascent = fontData.ascent * documentData.finalSize / 100;
    };
    TextProperty.prototype.updateDocumentData = function (newData, index) {
      index = index === undefined ? this.keysIndex : index;
      var dData = this.copyData({}, this.data.d.k[index].s);
      dData = this.copyData(dData, newData);
      this.data.d.k[index].s = dData;
      this.recalculate(index);
      this.setCurrentData(dData);
      this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.recalculate = function (index) {
      var dData = this.data.d.k[index].s;
      dData.__complete = false;
      this.keysIndex = 0;
      this._isFirstFrame = true;
      this.getValue(dData);
    };
    TextProperty.prototype.canResizeFont = function (_canResize) {
      this.canResize = _canResize;
      this.recalculate(this.keysIndex);
      this.elem.addDynamicProperty(this);
    };
    TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
      this.minimumFontSize = Math.floor(_fontValue) || 1;
      this.recalculate(this.keysIndex);
      this.elem.addDynamicProperty(this);
    };
    var TextSelectorProp = function () {
      var max = Math.max;
      var min = Math.min;
      var floor = Math.floor;
      function TextSelectorPropFactory(elem, data) {
        this._currentTextLength = -1;
        this.k = false;
        this.data = data;
        this.elem = elem;
        this.comp = elem.comp;
        this.finalS = 0;
        this.finalE = 0;
        this.initDynamicPropertyContainer(elem);
        this.s = PropertyFactory.getProp(elem, data.s || {
          k: 0
        }, 0, 0, this);
        if ('e' in data) {
          this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
        } else {
          this.e = {
            v: 100
          };
        }
        this.o = PropertyFactory.getProp(elem, data.o || {
          k: 0
        }, 0, 0, this);
        this.xe = PropertyFactory.getProp(elem, data.xe || {
          k: 0
        }, 0, 0, this);
        this.ne = PropertyFactory.getProp(elem, data.ne || {
          k: 0
        }, 0, 0, this);
        this.sm = PropertyFactory.getProp(elem, data.sm || {
          k: 100
        }, 0, 0, this);
        this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
        if (!this.dynamicProperties.length) {
          this.getValue();
        }
      }
      TextSelectorPropFactory.prototype = {
        getMult: function getMult(ind) {
          if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
            this.getValue();
          }
          var x1 = 0;
          var y1 = 0;
          var x2 = 1;
          var y2 = 1;
          if (this.ne.v > 0) {
            x1 = this.ne.v / 100.0;
          } else {
            y1 = -this.ne.v / 100.0;
          }
          if (this.xe.v > 0) {
            x2 = 1.0 - this.xe.v / 100.0;
          } else {
            y2 = 1.0 + this.xe.v / 100.0;
          }
          var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
          var mult = 0;
          var s = this.finalS;
          var e = this.finalE;
          var type = this.data.sh;
          if (type === 2) {
            if (e === s) {
              mult = ind >= e ? 1 : 0;
            } else {
              mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
            }
            mult = easer(mult);
          } else if (type === 3) {
            if (e === s) {
              mult = ind >= e ? 0 : 1;
            } else {
              mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
            }
            mult = easer(mult);
          } else if (type === 4) {
            if (e === s) {
              mult = 0;
            } else {
              mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
              if (mult < 0.5) {
                mult *= 2;
              } else {
                mult = 1 - 2 * (mult - 0.5);
              }
            }
            mult = easer(mult);
          } else if (type === 5) {
            if (e === s) {
              mult = 0;
            } else {
              var tot = e - s;
              /* ind += 0.5;
                        mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */

              ind = min(max(0, ind + 0.5 - s), e - s);
              var x = -tot / 2 + ind;
              var a = tot / 2;
              mult = Math.sqrt(1 - x * x / (a * a));
            }
            mult = easer(mult);
          } else if (type === 6) {
            if (e === s) {
              mult = 0;
            } else {
              ind = min(max(0, ind + 0.5 - s), e - s);
              mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line
            }
            mult = easer(mult);
          } else {
            if (ind >= floor(s)) {
              if (ind - s < 0) {
                mult = max(0, min(min(e, 1) - (s - ind), 1));
              } else {
                mult = max(0, min(e - ind, 1));
              }
            }
            mult = easer(mult);
          } // Smoothness implementation.
          // The smoothness represents a reduced range of the original [0; 1] range.
          // if smoothness is 25%, the new range will be [0.375; 0.625]
          // Steps are:
          // - find the lower value of the new range (threshold)
          // - if multiplier is smaller than that value, floor it to 0
          // - if it is larger,
          //     - subtract the threshold
          //     - divide it by the smoothness (this will return the range to [0; 1])
          // Note: If it doesn't work on some scenarios, consider applying it before the easer.

          if (this.sm.v !== 100) {
            var smoothness = this.sm.v * 0.01;
            if (smoothness === 0) {
              smoothness = 0.00000001;
            }
            var threshold = 0.5 - smoothness * 0.5;
            if (mult < threshold) {
              mult = 0;
            } else {
              mult = (mult - threshold) / smoothness;
              if (mult > 1) {
                mult = 1;
              }
            }
          }
          return mult * this.a.v;
        },
        getValue: function getValue(newCharsFlag) {
          this.iterateDynamicProperties();
          this._mdf = newCharsFlag || this._mdf;
          this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
          if (newCharsFlag && this.data.r === 2) {
            this.e.v = this._currentTextLength;
          }
          var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
          var o = this.o.v / divisor;
          var s = this.s.v / divisor + o;
          var e = this.e.v / divisor + o;
          if (s > e) {
            var _s = s;
            s = e;
            e = _s;
          }
          this.finalS = s;
          this.finalE = e;
        }
      };
      extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
      function getTextSelectorProp(elem, data, arr) {
        return new TextSelectorPropFactory(elem, data, arr);
      }
      return {
        getTextSelectorProp: getTextSelectorProp
      };
    }();
    function TextAnimatorDataProperty(elem, animatorProps, container) {
      var defaultData = {
        propType: false
      };
      var getProp = PropertyFactory.getProp;
      var textAnimatorAnimatables = animatorProps.a;
      this.a = {
        r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
        rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
        ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
        sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
        sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
        s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
        a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
        o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
        p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
        sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
        sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
        fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
        fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
        fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
        fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
        t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
      };
      this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
      this.s.t = animatorProps.s.t;
    }
    function TextAnimatorProperty(textData, renderType, elem) {
      this._isFirstFrame = true;
      this._hasMaskedPath = false;
      this._frameId = -1;
      this._textData = textData;
      this._renderType = renderType;
      this._elem = elem;
      this._animatorsData = createSizedArray(this._textData.a.length);
      this._pathData = {};
      this._moreOptions = {
        alignment: {}
      };
      this.renderedLetters = [];
      this.lettersChangedFlag = false;
      this.initDynamicPropertyContainer(elem);
    }
    TextAnimatorProperty.prototype.searchProperties = function () {
      var i;
      var len = this._textData.a.length;
      var animatorProps;
      var getProp = PropertyFactory.getProp;
      for (i = 0; i < len; i += 1) {
        animatorProps = this._textData.a[i];
        this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
      }
      if (this._textData.p && 'm' in this._textData.p) {
        this._pathData = {
          a: getProp(this._elem, this._textData.p.a, 0, 0, this),
          f: getProp(this._elem, this._textData.p.f, 0, 0, this),
          l: getProp(this._elem, this._textData.p.l, 0, 0, this),
          r: getProp(this._elem, this._textData.p.r, 0, 0, this),
          p: getProp(this._elem, this._textData.p.p, 0, 0, this),
          m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
        };
        this._hasMaskedPath = true;
      } else {
        this._hasMaskedPath = false;
      }
      this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
    };
    TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
      this.lettersChangedFlag = lettersChangedFlag;
      if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
        return;
      }
      this._isFirstFrame = false;
      var alignment = this._moreOptions.alignment.v;
      var animators = this._animatorsData;
      var textData = this._textData;
      var matrixHelper = this.mHelper;
      var renderType = this._renderType;
      var renderedLettersCount = this.renderedLetters.length;
      var xPos;
      var yPos;
      var i;
      var len;
      var letters = documentData.l;
      var pathInfo;
      var currentLength;
      var currentPoint;
      var segmentLength;
      var flag;
      var pointInd;
      var segmentInd;
      var prevPoint;
      var points;
      var segments;
      var partialLength;
      var totalLength;
      var perc;
      var tanAngle;
      var mask;
      if (this._hasMaskedPath) {
        mask = this._pathData.m;
        if (!this._pathData.n || this._pathData._mdf) {
          var paths = mask.v;
          if (this._pathData.r.v) {
            paths = paths.reverse();
          } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi

          pathInfo = {
            tLength: 0,
            segments: []
          };
          len = paths._length - 1;
          var bezierData;
          totalLength = 0;
          for (i = 0; i < len; i += 1) {
            bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
            pathInfo.tLength += bezierData.segmentLength;
            pathInfo.segments.push(bezierData);
            totalLength += bezierData.segmentLength;
          }
          i = len;
          if (mask.v.c) {
            bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
            pathInfo.tLength += bezierData.segmentLength;
            pathInfo.segments.push(bezierData);
            totalLength += bezierData.segmentLength;
          }
          this._pathData.pi = pathInfo;
        }
        pathInfo = this._pathData.pi;
        currentLength = this._pathData.f.v;
        segmentInd = 0;
        pointInd = 1;
        segmentLength = 0;
        flag = true;
        segments = pathInfo.segments;
        if (currentLength < 0 && mask.v.c) {
          if (pathInfo.tLength < Math.abs(currentLength)) {
            currentLength = -Math.abs(currentLength) % pathInfo.tLength;
          }
          segmentInd = segments.length - 1;
          points = segments[segmentInd].points;
          pointInd = points.length - 1;
          while (currentLength < 0) {
            currentLength += points[pointInd].partialLength;
            pointInd -= 1;
            if (pointInd < 0) {
              segmentInd -= 1;
              points = segments[segmentInd].points;
              pointInd = points.length - 1;
            }
          }
        }
        points = segments[segmentInd].points;
        prevPoint = points[pointInd - 1];
        currentPoint = points[pointInd];
        partialLength = currentPoint.partialLength;
      }
      len = letters.length;
      xPos = 0;
      yPos = 0;
      var yOff = documentData.finalSize * 1.2 * 0.714;
      var firstLine = true;
      var animatorProps;
      var animatorSelector;
      var j;
      var jLen;
      var letterValue;
      jLen = animators.length;
      var mult;
      var ind = -1;
      var offf;
      var xPathPos;
      var yPathPos;
      var initPathPos = currentLength;
      var initSegmentInd = segmentInd;
      var initPointInd = pointInd;
      var currentLine = -1;
      var elemOpacity;
      var sc;
      var sw;
      var fc;
      var k;
      var letterSw;
      var letterSc;
      var letterFc;
      var letterM = '';
      var letterP = this.defaultPropsArray;
      var letterO; //

      if (documentData.j === 2 || documentData.j === 1) {
        var animatorJustifyOffset = 0;
        var animatorFirstCharOffset = 0;
        var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
        var lastIndex = 0;
        var isNewLine = true;
        for (i = 0; i < len; i += 1) {
          if (letters[i].n) {
            if (animatorJustifyOffset) {
              animatorJustifyOffset += animatorFirstCharOffset;
            }
            while (lastIndex < i) {
              letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
              lastIndex += 1;
            }
            animatorJustifyOffset = 0;
            isNewLine = true;
          } else {
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.t.propType) {
                if (isNewLine && documentData.j === 2) {
                  animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                }
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                } else {
                  animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                }
              }
            }
            isNewLine = false;
          }
        }
        if (animatorJustifyOffset) {
          animatorJustifyOffset += animatorFirstCharOffset;
        }
        while (lastIndex < i) {
          letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
          lastIndex += 1;
        }
      } //

      for (i = 0; i < len; i += 1) {
        matrixHelper.reset();
        elemOpacity = 1;
        if (letters[i].n) {
          xPos = 0;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          currentLength = initPathPos;
          firstLine = false;
          if (this._hasMaskedPath) {
            segmentInd = initSegmentInd;
            pointInd = initPointInd;
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
            segmentLength = 0;
          }
          letterM = '';
          letterFc = '';
          letterSw = '';
          letterO = '';
          letterP = this.defaultPropsArray;
        } else {
          if (this._hasMaskedPath) {
            if (currentLine !== letters[i].line) {
              switch (documentData.j) {
                case 1:
                  currentLength += totalLength - documentData.lineWidths[letters[i].line];
                  break;
                case 2:
                  currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                  break;
              }
              currentLine = letters[i].line;
            }
            if (ind !== letters[i].ind) {
              if (letters[ind]) {
                currentLength += letters[ind].extra;
              }
              currentLength += letters[i].an / 2;
              ind = letters[i].ind;
            }
            currentLength += alignment[0] * letters[i].an * 0.005;
            var animatorOffset = 0;
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.p.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorOffset += animatorProps.p.v[0] * mult[0];
                } else {
                  animatorOffset += animatorProps.p.v[0] * mult;
                }
              }
              if (animatorProps.a.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorOffset += animatorProps.a.v[0] * mult[0];
                } else {
                  animatorOffset += animatorProps.a.v[0] * mult;
                }
              }
            }
            flag = true; // Force alignment only works with a single line for now

            if (this._pathData.a.v) {
              currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
              currentLength += this._pathData.f.v;
            }
            while (flag) {
              if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);
                flag = false;
              } else if (points) {
                segmentLength += currentPoint.partialLength;
                pointInd += 1;
                if (pointInd >= points.length) {
                  pointInd = 0;
                  segmentInd += 1;
                  if (!segments[segmentInd]) {
                    if (mask.v.c) {
                      pointInd = 0;
                      segmentInd = 0;
                      points = segments[segmentInd].points;
                    } else {
                      segmentLength -= currentPoint.partialLength;
                      points = null;
                    }
                  } else {
                    points = segments[segmentInd].points;
                  }
                }
                if (points) {
                  prevPoint = currentPoint;
                  currentPoint = points[pointInd];
                  partialLength = currentPoint.partialLength;
                }
              }
            }
            offf = letters[i].an / 2 - letters[i].add;
            matrixHelper.translate(-offf, 0, 0);
          } else {
            offf = letters[i].an / 2 - letters[i].add;
            matrixHelper.translate(-offf, 0, 0); // Grouping alignment

            matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.t.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"

              if (xPos !== 0 || documentData.j !== 0) {
                if (this._hasMaskedPath) {
                  if (mult.length) {
                    currentLength += animatorProps.t.v * mult[0];
                  } else {
                    currentLength += animatorProps.t.v * mult;
                  }
                } else if (mult.length) {
                  xPos += animatorProps.t.v * mult[0];
                } else {
                  xPos += animatorProps.t.v * mult;
                }
              }
            }
          }
          if (documentData.strokeWidthAnim) {
            sw = documentData.sw || 0;
          }
          if (documentData.strokeColorAnim) {
            if (documentData.sc) {
              sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
            } else {
              sc = [0, 0, 0];
            }
          }
          if (documentData.fillColorAnim && documentData.fc) {
            fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.a.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (mult.length) {
                matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
              } else {
                matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.s.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (mult.length) {
                matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
              } else {
                matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (animatorProps.sk.propType) {
              if (mult.length) {
                matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
              } else {
                matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
              }
            }
            if (animatorProps.r.propType) {
              if (mult.length) {
                matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
              } else {
                matrixHelper.rotateZ(-animatorProps.r.v * mult);
              }
            }
            if (animatorProps.ry.propType) {
              if (mult.length) {
                matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
              } else {
                matrixHelper.rotateY(animatorProps.ry.v * mult);
              }
            }
            if (animatorProps.rx.propType) {
              if (mult.length) {
                matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
              } else {
                matrixHelper.rotateX(animatorProps.rx.v * mult);
              }
            }
            if (animatorProps.o.propType) {
              if (mult.length) {
                elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
              } else {
                elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
              }
            }
            if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
              if (mult.length) {
                sw += animatorProps.sw.v * mult[0];
              } else {
                sw += animatorProps.sw.v * mult;
              }
            }
            if (documentData.strokeColorAnim && animatorProps.sc.propType) {
              for (k = 0; k < 3; k += 1) {
                if (mult.length) {
                  sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                } else {
                  sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                }
              }
            }
            if (documentData.fillColorAnim && documentData.fc) {
              if (animatorProps.fc.propType) {
                for (k = 0; k < 3; k += 1) {
                  if (mult.length) {
                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                  } else {
                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                  }
                }
              }
              if (animatorProps.fh.propType) {
                if (mult.length) {
                  fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                } else {
                  fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                }
              }
              if (animatorProps.fs.propType) {
                if (mult.length) {
                  fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                } else {
                  fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                }
              }
              if (animatorProps.fb.propType) {
                if (mult.length) {
                  fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                } else {
                  fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                }
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.p.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (this._hasMaskedPath) {
                if (mult.length) {
                  matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                } else {
                  matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              } else if (mult.length) {
                matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
              } else {
                matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
              }
            }
          }
          if (documentData.strokeWidthAnim) {
            letterSw = sw < 0 ? 0 : sw;
          }
          if (documentData.strokeColorAnim) {
            letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
          }
          if (documentData.fillColorAnim && documentData.fc) {
            letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
          }
          if (this._hasMaskedPath) {
            matrixHelper.translate(0, -documentData.ls);
            matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
            if (this._pathData.p.v) {
              tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
              var rot = Math.atan(tanAngle) * 180 / Math.PI;
              if (currentPoint.point[0] < prevPoint.point[0]) {
                rot += 180;
              }
              matrixHelper.rotate(-rot * Math.PI / 180);
            }
            matrixHelper.translate(xPathPos, yPathPos, 0);
            currentLength -= alignment[0] * letters[i].an * 0.005;
            if (letters[i + 1] && ind !== letters[i + 1].ind) {
              currentLength += letters[i].an / 2;
              currentLength += documentData.tr * 0.001 * documentData.finalSize;
            }
          } else {
            matrixHelper.translate(xPos, yPos, 0);
            if (documentData.ps) {
              // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
              matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
            }
            switch (documentData.j) {
              case 1:
                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                break;
              case 2:
                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                break;
            }
            matrixHelper.translate(0, -documentData.ls);
            matrixHelper.translate(offf, 0, 0);
            matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);
            xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;
          }
          if (renderType === 'html') {
            letterM = matrixHelper.toCSS();
          } else if (renderType === 'svg') {
            letterM = matrixHelper.to2dCSS();
          } else {
            letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
          }
          letterO = elemOpacity;
        }
        if (renderedLettersCount <= i) {
          letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
          this.renderedLetters.push(letterValue);
          renderedLettersCount += 1;
          this.lettersChangedFlag = true;
        } else {
          letterValue = this.renderedLetters[i];
          this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
        }
      }
    };
    TextAnimatorProperty.prototype.getValue = function () {
      if (this._elem.globalData.frameId === this._frameId) {
        return;
      }
      this._frameId = this._elem.globalData.frameId;
      this.iterateDynamicProperties();
    };
    TextAnimatorProperty.prototype.mHelper = new Matrix();
    TextAnimatorProperty.prototype.defaultPropsArray = [];
    extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
    function ITextElement() {}
    ITextElement.prototype.initElement = function (data, globalData, comp) {
      this.lettersChangedFlag = true;
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
      this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
      this.initTransform(data, globalData, comp);
      this.initHierarchy();
      this.initRenderable();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      this.createContent();
      this.hide();
      this.textAnimator.searchProperties(this.dynamicProperties);
    };
    ITextElement.prototype.prepareFrame = function (num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
    };
    ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
      var j;
      var jLen = shapes.length;
      var pathNodes;
      var shapeStr = '';
      for (j = 0; j < jLen; j += 1) {
        if (shapes[j].ty === 'sh') {
          pathNodes = shapes[j].ks.k;
          shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
        }
      }
      return shapeStr;
    };
    ITextElement.prototype.updateDocumentData = function (newData, index) {
      this.textProperty.updateDocumentData(newData, index);
    };
    ITextElement.prototype.canResizeFont = function (_canResize) {
      this.textProperty.canResizeFont(_canResize);
    };
    ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
      this.textProperty.setMinimumFontSize(_fontSize);
    };
    ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
      if (documentData.ps) {
        matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
      }
      matrixHelper.translate(0, -documentData.ls, 0);
      switch (documentData.j) {
        case 1:
          matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
          break;
        case 2:
          matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
          break;
      }
      matrixHelper.translate(xPos, yPos, 0);
    };
    ITextElement.prototype.buildColor = function (colorData) {
      return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
    };
    ITextElement.prototype.emptyProp = new LetterProps();
    ITextElement.prototype.destroy = function () {};
    ITextElement.prototype.validateText = function () {
      if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
        this.buildNewText();
        this.textProperty._isFirstFrame = false;
        this.textProperty._mdf = false;
      }
    };
    var emptyShapeData = {
      shapes: []
    };
    function SVGTextLottieElement(data, globalData, comp) {
      this.textSpans = [];
      this.renderType = 'svg';
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
    SVGTextLottieElement.prototype.createContent = function () {
      if (this.data.singleShape && !this.globalData.fontManager.chars) {
        this.textContainer = createNS('text');
      }
    };
    SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
      var i = 0;
      var len = textArray.length;
      var textContents = [];
      var currentTextContent = '';
      while (i < len) {
        if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
          textContents.push(currentTextContent);
          currentTextContent = '';
        } else {
          currentTextContent += textArray[i];
        }
        i += 1;
      }
      textContents.push(currentTextContent);
      return textContents;
    };
    SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {
      // data should probably be cloned to apply scale separately to each instance of a text on different layers
      // but since text internal content gets only rendered once and then it's never rerendered,
      // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.
      // Avoiding cloning is preferred since cloning each character shape data is expensive
      if (data.shapes && data.shapes.length) {
        var shape = data.shapes[0];
        if (shape.it) {
          var shapeItem = shape.it[shape.it.length - 1];
          if (shapeItem.s) {
            shapeItem.s.k[0] = scale;
            shapeItem.s.k[1] = scale;
          }
        }
      }
      return data;
    };
    SVGTextLottieElement.prototype.buildNewText = function () {
      this.addDynamicProperty(this);
      var i;
      var len;
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
      if (documentData.fc) {
        this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
      } else {
        this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
      }
      if (documentData.sc) {
        this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
        this.layerElement.setAttribute('stroke-width', documentData.sw);
      }
      this.layerElement.setAttribute('font-size', documentData.finalSize);
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      if (fontData.fClass) {
        this.layerElement.setAttribute('class', fontData.fClass);
      } else {
        this.layerElement.setAttribute('font-family', fontData.fFamily);
        var fWeight = documentData.fWeight;
        var fStyle = documentData.fStyle;
        this.layerElement.setAttribute('font-style', fStyle);
        this.layerElement.setAttribute('font-weight', fWeight);
      }
      this.layerElement.setAttribute('aria-label', documentData.t);
      var letters = documentData.l || [];
      var usesGlyphs = !!this.globalData.fontManager.chars;
      len = letters.length;
      var tSpan;
      var matrixHelper = this.mHelper;
      var shapeStr = '';
      var singleShape = this.data.singleShape;
      var xPos = 0;
      var yPos = 0;
      var firstLine = true;
      var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
      if (singleShape && !usesGlyphs && !documentData.sz) {
        var tElement = this.textContainer;
        var justify = 'start';
        switch (documentData.j) {
          case 1:
            justify = 'end';
            break;
          case 2:
            justify = 'middle';
            break;
          default:
            justify = 'start';
            break;
        }
        tElement.setAttribute('text-anchor', justify);
        tElement.setAttribute('letter-spacing', trackingOffset);
        var textContent = this.buildTextContents(documentData.finalText);
        len = textContent.length;
        yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
        for (i = 0; i < len; i += 1) {
          tSpan = this.textSpans[i].span || createNS('tspan');
          tSpan.textContent = textContent[i];
          tSpan.setAttribute('x', 0);
          tSpan.setAttribute('y', yPos);
          tSpan.style.display = 'inherit';
          tElement.appendChild(tSpan);
          if (!this.textSpans[i]) {
            this.textSpans[i] = {
              span: null,
              glyph: null
            };
          }
          this.textSpans[i].span = tSpan;
          yPos += documentData.finalLineHeight;
        }
        this.layerElement.appendChild(tElement);
      } else {
        var cachedSpansLength = this.textSpans.length;
        var charData;
        for (i = 0; i < len; i += 1) {
          if (!this.textSpans[i]) {
            this.textSpans[i] = {
              span: null,
              childSpan: null,
              glyph: null
            };
          }
          if (!usesGlyphs || !singleShape || i === 0) {
            tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');
            if (cachedSpansLength <= i) {
              tSpan.setAttribute('stroke-linecap', 'butt');
              tSpan.setAttribute('stroke-linejoin', 'round');
              tSpan.setAttribute('stroke-miterlimit', '4');
              this.textSpans[i].span = tSpan;
              if (usesGlyphs) {
                var childSpan = createNS('g');
                tSpan.appendChild(childSpan);
                this.textSpans[i].childSpan = childSpan;
              }
              this.textSpans[i].span = tSpan;
              this.layerElement.appendChild(tSpan);
            }
            tSpan.style.display = 'inherit';
          }
          matrixHelper.reset();
          if (singleShape) {
            if (letters[i].n) {
              xPos = -trackingOffset;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              firstLine = false;
            }
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
            xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;

            xPos += trackingOffset;
          }
          if (usesGlyphs) {
            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            var glyphElement; // t === 1 means the character has been replaced with an animated shaped

            if (charData.t === 1) {
              glyphElement = new SVGCompElement(charData.data, this.globalData, this);
            } else {
              var data = emptyShapeData;
              if (charData.data && charData.data.shapes) {
                data = this.buildShapeData(charData.data, documentData.finalSize);
              }
              glyphElement = new SVGShapeElement(data, this.globalData, this);
            }
            if (this.textSpans[i].glyph) {
              var glyph = this.textSpans[i].glyph;
              this.textSpans[i].childSpan.removeChild(glyph.layerElement);
              glyph.destroy();
            }
            this.textSpans[i].glyph = glyphElement;
            glyphElement._debug = true;
            glyphElement.prepareFrame(0);
            glyphElement.renderFrame();
            this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale
            // this might have issues with strokes and might need a different solution

            if (charData.t === 1) {
              this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');
            }
          } else {
            if (singleShape) {
              tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
            }
            tSpan.textContent = letters[i].val;
            tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
          } //
        }
        if (singleShape && tSpan) {
          tSpan.setAttribute('d', shapeStr);
        }
      }
      while (i < this.textSpans.length) {
        this.textSpans[i].span.style.display = 'none';
        i += 1;
      }
      this._sizeChanged = true;
    };
    SVGTextLottieElement.prototype.sourceRectAtTime = function () {
      this.prepareFrame(this.comp.renderedFrame - this.data.st);
      this.renderInnerContent();
      if (this._sizeChanged) {
        this._sizeChanged = false;
        var textBox = this.layerElement.getBBox();
        this.bbox = {
          top: textBox.y,
          left: textBox.x,
          width: textBox.width,
          height: textBox.height
        };
      }
      return this.bbox;
    };
    SVGTextLottieElement.prototype.getValue = function () {
      var i;
      var len = this.textSpans.length;
      var glyphElement;
      this.renderedFrame = this.comp.renderedFrame;
      for (i = 0; i < len; i += 1) {
        glyphElement = this.textSpans[i].glyph;
        if (glyphElement) {
          glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
          if (glyphElement._mdf) {
            this._mdf = true;
          }
        }
      }
    };
    SVGTextLottieElement.prototype.renderInnerContent = function () {
      this.validateText();
      if (!this.data.singleShape || this._mdf) {
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
          this._sizeChanged = true;
          var i;
          var len;
          var renderedLetters = this.textAnimator.renderedLetters;
          var letters = this.textProperty.currentData.l;
          len = letters.length;
          var renderedLetter;
          var textSpan;
          var glyphElement;
          for (i = 0; i < len; i += 1) {
            if (!letters[i].n) {
              renderedLetter = renderedLetters[i];
              textSpan = this.textSpans[i].span;
              glyphElement = this.textSpans[i].glyph;
              if (glyphElement) {
                glyphElement.renderFrame();
              }
              if (renderedLetter._mdf.m) {
                textSpan.setAttribute('transform', renderedLetter.m);
              }
              if (renderedLetter._mdf.o) {
                textSpan.setAttribute('opacity', renderedLetter.o);
              }
              if (renderedLetter._mdf.sw) {
                textSpan.setAttribute('stroke-width', renderedLetter.sw);
              }
              if (renderedLetter._mdf.sc) {
                textSpan.setAttribute('stroke', renderedLetter.sc);
              }
              if (renderedLetter._mdf.fc) {
                textSpan.setAttribute('fill', renderedLetter.fc);
              }
            }
          }
        }
      }
    };
    function ISolidElement(data, globalData, comp) {
      this.initElement(data, globalData, comp);
    }
    extendPrototype([IImageElement], ISolidElement);
    ISolidElement.prototype.createContent = function () {
      var rect = createNS('rect'); /// /rect.style.width = this.data.sw;
      /// /rect.style.height = this.data.sh;
      /// /rect.style.fill = this.data.sc;

      rect.setAttribute('width', this.data.sw);
      rect.setAttribute('height', this.data.sh);
      rect.setAttribute('fill', this.data.sc);
      this.layerElement.appendChild(rect);
    };
    function NullElement(data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initFrame();
      this.initTransform(data, globalData, comp);
      this.initHierarchy();
    }
    NullElement.prototype.prepareFrame = function (num) {
      this.prepareProperties(num, true);
    };
    NullElement.prototype.renderFrame = function () {};
    NullElement.prototype.getBaseElement = function () {
      return null;
    };
    NullElement.prototype.destroy = function () {};
    NullElement.prototype.sourceRectAtTime = function () {};
    NullElement.prototype.hide = function () {};
    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
    function SVGRendererBase() {}
    extendPrototype([BaseRenderer], SVGRendererBase);
    SVGRendererBase.prototype.createNull = function (data) {
      return new NullElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createShape = function (data) {
      return new SVGShapeElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createText = function (data) {
      return new SVGTextLottieElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createImage = function (data) {
      return new IImageElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.createSolid = function (data) {
      return new ISolidElement(data, this.globalData, this);
    };
    SVGRendererBase.prototype.configAnimation = function (animData) {
      this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      this.svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
      if (this.renderConfig.viewBoxSize) {
        this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
      } else {
        this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
      }
      if (!this.renderConfig.viewBoxOnly) {
        this.svgElement.setAttribute('width', animData.w);
        this.svgElement.setAttribute('height', animData.h);
        this.svgElement.style.width = '100%';
        this.svgElement.style.height = '100%';
        this.svgElement.style.transform = 'translate3d(0,0,0)';
        this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
      }
      if (this.renderConfig.width) {
        this.svgElement.setAttribute('width', this.renderConfig.width);
      }
      if (this.renderConfig.height) {
        this.svgElement.setAttribute('height', this.renderConfig.height);
      }
      if (this.renderConfig.className) {
        this.svgElement.setAttribute('class', this.renderConfig.className);
      }
      if (this.renderConfig.id) {
        this.svgElement.setAttribute('id', this.renderConfig.id);
      }
      if (this.renderConfig.focusable !== undefined) {
        this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
      }
      this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';
      // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";

      this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation

      var defs = this.globalData.defs;
      this.setupGlobalData(animData, defs);
      this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
      this.data = animData;
      var maskElement = createNS('clipPath');
      var rect = createNS('rect');
      rect.setAttribute('width', animData.w);
      rect.setAttribute('height', animData.h);
      rect.setAttribute('x', 0);
      rect.setAttribute('y', 0);
      var maskId = createElementID();
      maskElement.setAttribute('id', maskId);
      maskElement.appendChild(rect);
      this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');
      defs.appendChild(maskElement);
      this.layers = animData.layers;
      this.elements = createSizedArray(animData.layers.length);
    };
    SVGRendererBase.prototype.destroy = function () {
      if (this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = '';
      }
      this.layerElement = null;
      this.globalData.defs = null;
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i] && this.elements[i].destroy) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.destroyed = true;
      this.animationItem = null;
    };
    SVGRendererBase.prototype.updateContainerSize = function () {};
    SVGRendererBase.prototype.findIndexByInd = function (ind) {
      var i = 0;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.layers[i].ind === ind) {
          return i;
        }
      }
      return -1;
    };
    SVGRendererBase.prototype.buildItem = function (pos) {
      var elements = this.elements;
      if (elements[pos] || this.layers[pos].ty === 99) {
        return;
      }
      elements[pos] = true;
      var element = this.createItem(this.layers[pos]);
      elements[pos] = element;
      if (getExpressionsPlugin()) {
        if (this.layers[pos].ty === 0) {
          this.globalData.projectInterface.registerComposition(element);
        }
        element.initExpressions();
      }
      this.appendElementInPos(element, pos);
      if (this.layers[pos].tt) {
        var elementIndex = 'tp' in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
        if (elementIndex === -1) {
          return;
        }
        if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
          this.buildItem(elementIndex);
          this.addPendingElement(element);
        } else {
          var matteElement = elements[elementIndex];
          var matteMask = matteElement.getMatte(this.layers[pos].tt);
          element.setMatte(matteMask);
        }
      }
    };
    SVGRendererBase.prototype.checkPendingElements = function () {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
        if (element.data.tt) {
          var i = 0;
          var len = this.elements.length;
          while (i < len) {
            if (this.elements[i] === element) {
              var elementIndex = 'tp' in element.data ? this.findIndexByInd(element.data.tp) : i - 1;
              var matteElement = this.elements[elementIndex];
              var matteMask = matteElement.getMatte(this.layers[i].tt);
              element.setMatte(matteMask);
              break;
            }
            i += 1;
          }
        }
      }
    };
    SVGRendererBase.prototype.renderFrame = function (num) {
      if (this.renderedFrame === num || this.destroyed) {
        return;
      }
      if (num === null) {
        num = this.renderedFrame;
      } else {
        this.renderedFrame = num;
      } // console.log('-------');
      // console.log('FRAME ',num);

      this.globalData.frameNum = num;
      this.globalData.frameId += 1;
      this.globalData.projectInterface.currentFrame = num;
      this.globalData._mdf = false;
      var i;
      var len = this.layers.length;
      if (!this.completeLayers) {
        this.checkLayers(num);
      }
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(num - this.layers[i].st);
        }
      }
      if (this.globalData._mdf) {
        for (i = 0; i < len; i += 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
      }
    };
    SVGRendererBase.prototype.appendElementInPos = function (element, pos) {
      var newElement = element.getBaseElement();
      if (!newElement) {
        return;
      }
      var i = 0;
      var nextElement;
      while (i < pos) {
        if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
          nextElement = this.elements[i].getBaseElement();
        }
        i += 1;
      }
      if (nextElement) {
        this.layerElement.insertBefore(newElement, nextElement);
      } else {
        this.layerElement.appendChild(newElement);
      }
    };
    SVGRendererBase.prototype.hide = function () {
      this.layerElement.style.display = 'none';
    };
    SVGRendererBase.prototype.show = function () {
      this.layerElement.style.display = 'block';
    };
    function ICompElement() {}
    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
    ICompElement.prototype.initElement = function (data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initTransform(data, globalData, comp);
      this.initRenderable();
      this.initHierarchy();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      if (this.data.xt || !globalData.progressiveLoad) {
        this.buildAllItems();
      }
      this.hide();
    };
    /* ICompElement.prototype.hide = function(){
        if(!this.hidden){
            this.hideElement();
            var i,len = this.elements.length;
            for( i = 0; i < len; i+=1 ){
                if(this.elements[i]){
                    this.elements[i].hide();
                }
            }
        }
    }; */

    ICompElement.prototype.prepareFrame = function (num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
      if (!this.isInRange && !this.data.xt) {
        return;
      }
      if (!this.tm._placeholder) {
        var timeRemapped = this.tm.v;
        if (timeRemapped === this.data.op) {
          timeRemapped = this.data.op - 1;
        }
        this.renderedFrame = timeRemapped;
      } else {
        this.renderedFrame = num / this.data.sr;
      }
      var i;
      var len = this.elements.length;
      if (!this.completeLayers) {
        this.checkLayers(this.renderedFrame);
      } // This iteration needs to be backwards because of how expressions connect between each other

      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
          if (this.elements[i]._mdf) {
            this._mdf = true;
          }
        }
      }
    };
    ICompElement.prototype.renderInnerContent = function () {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }
    };
    ICompElement.prototype.setElements = function (elems) {
      this.elements = elems;
    };
    ICompElement.prototype.getElements = function () {
      return this.elements;
    };
    ICompElement.prototype.destroyElements = function () {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
    };
    ICompElement.prototype.destroy = function () {
      this.destroyElements();
      this.destroyBaseElement();
    };
    function SVGCompElement(data, globalData, comp) {
      this.layers = data.layers;
      this.supports3d = true;
      this.completeLayers = false;
      this.pendingElements = [];
      this.elements = this.layers ? createSizedArray(this.layers.length) : [];
      this.initElement(data, globalData, comp);
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
        _placeholder: true
      };
    }
    extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
    SVGCompElement.prototype.createComp = function (data) {
      return new SVGCompElement(data, this.globalData, this);
    };
    function SVGRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.svgElement = createNS('svg');
      var ariaLabel = '';
      if (config && config.title) {
        var titleElement = createNS('title');
        var titleId = createElementID();
        titleElement.setAttribute('id', titleId);
        titleElement.textContent = config.title;
        this.svgElement.appendChild(titleElement);
        ariaLabel += titleId;
      }
      if (config && config.description) {
        var descElement = createNS('desc');
        var descId = createElementID();
        descElement.setAttribute('id', descId);
        descElement.textContent = config.description;
        this.svgElement.appendChild(descElement);
        ariaLabel += ' ' + descId;
      }
      if (ariaLabel) {
        this.svgElement.setAttribute('aria-labelledby', ariaLabel);
      }
      var defs = createNS('defs');
      this.svgElement.appendChild(defs);
      var maskElement = createNS('g');
      this.svgElement.appendChild(maskElement);
      this.layerElement = maskElement;
      this.renderConfig = {
        preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
        contentVisibility: config && config.contentVisibility || 'visible',
        progressiveLoad: config && config.progressiveLoad || false,
        hideOnTransparent: !(config && config.hideOnTransparent === false),
        viewBoxOnly: config && config.viewBoxOnly || false,
        viewBoxSize: config && config.viewBoxSize || false,
        className: config && config.className || '',
        id: config && config.id || '',
        focusable: config && config.focusable,
        filterSize: {
          width: config && config.filterSize && config.filterSize.width || '100%',
          height: config && config.filterSize && config.filterSize.height || '100%',
          x: config && config.filterSize && config.filterSize.x || '0%',
          y: config && config.filterSize && config.filterSize.y || '0%'
        },
        width: config && config.width,
        height: config && config.height,
        runExpressions: !config || config.runExpressions === undefined || config.runExpressions
      };
      this.globalData = {
        _mdf: false,
        frameNum: -1,
        defs: defs,
        renderConfig: this.renderConfig
      };
      this.elements = [];
      this.pendingElements = [];
      this.destroyed = false;
      this.rendererType = 'svg';
    }
    extendPrototype([SVGRendererBase], SVGRenderer);
    SVGRenderer.prototype.createComp = function (data) {
      return new SVGCompElement(data, this.globalData, this);
    };
    function ShapeTransformManager() {
      this.sequences = {};
      this.sequenceList = [];
      this.transform_key_count = 0;
    }
    ShapeTransformManager.prototype = {
      addTransformSequence: function addTransformSequence(transforms) {
        var i;
        var len = transforms.length;
        var key = '_';
        for (i = 0; i < len; i += 1) {
          key += transforms[i].transform.key + '_';
        }
        var sequence = this.sequences[key];
        if (!sequence) {
          sequence = {
            transforms: [].concat(transforms),
            finalTransform: new Matrix(),
            _mdf: false
          };
          this.sequences[key] = sequence;
          this.sequenceList.push(sequence);
        }
        return sequence;
      },
      processSequence: function processSequence(sequence, isFirstFrame) {
        var i = 0;
        var len = sequence.transforms.length;
        var _mdf = isFirstFrame;
        while (i < len && !isFirstFrame) {
          if (sequence.transforms[i].transform.mProps._mdf) {
            _mdf = true;
            break;
          }
          i += 1;
        }
        if (_mdf) {
          sequence.finalTransform.reset();
          for (i = len - 1; i >= 0; i -= 1) {
            sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);
          }
        }
        sequence._mdf = _mdf;
      },
      processSequences: function processSequences(isFirstFrame) {
        var i;
        var len = this.sequenceList.length;
        for (i = 0; i < len; i += 1) {
          this.processSequence(this.sequenceList[i], isFirstFrame);
        }
      },
      getNewKey: function getNewKey() {
        this.transform_key_count += 1;
        return '_' + this.transform_key_count;
      }
    };
    var lumaLoader = function lumaLoader() {
      var id = '__lottie_element_luma_buffer';
      var lumaBuffer = null;
      var lumaBufferCtx = null;
      var svg = null; // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.
      // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.
      // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.
      // Naming it solution 2 to mark the extra comment lines.

      /*
      var svgString = [
        '<svg xmlns="http://www.w3.org/2000/svg">',
        '<filter id="' + id + '">',
        '<feColorMatrix type="matrix" color-interpolation-filters="sRGB" values="',
        '0.3, 0.3, 0.3, 0, 0, ',
        '0.3, 0.3, 0.3, 0, 0, ',
        '0.3, 0.3, 0.3, 0, 0, ',
        '0.3, 0.3, 0.3, 0, 0',
        '"/>',
        '</filter>',
        '</svg>',
      ].join('');
      var blob = new Blob([svgString], { type: 'image/svg+xml' });
      var url = URL.createObjectURL(blob);
      */

      function createLumaSvgFilter() {
        var _svg = createNS('svg');
        var fil = createNS('filter');
        var matrix = createNS('feColorMatrix');
        fil.setAttribute('id', id);
        matrix.setAttribute('type', 'matrix');
        matrix.setAttribute('color-interpolation-filters', 'sRGB');
        matrix.setAttribute('values', '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');
        fil.appendChild(matrix);
        _svg.appendChild(fil);
        _svg.setAttribute('id', id + '_svg');
        if (featureSupport.svgLumaHidden) {
          _svg.style.display = 'none';
        }
        return _svg;
      }
      function loadLuma() {
        if (!lumaBuffer) {
          svg = createLumaSvgFilter();
          document.body.appendChild(svg);
          lumaBuffer = createTag('canvas');
          lumaBufferCtx = lumaBuffer.getContext('2d'); // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2

          lumaBufferCtx.filter = 'url(#' + id + ')';
          lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)';
          lumaBufferCtx.fillRect(0, 0, 1, 1);
        }
      }
      function getLuma(canvas) {
        if (!lumaBuffer) {
          loadLuma();
        }
        lumaBuffer.width = canvas.width;
        lumaBuffer.height = canvas.height; // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2

        lumaBufferCtx.filter = 'url(#' + id + ')';
        return lumaBuffer;
      }
      return {
        load: loadLuma,
        get: getLuma
      };
    };
    function createCanvas(width, height) {
      if (featureSupport.offscreenCanvas) {
        return new OffscreenCanvas(width, height);
      }
      var canvas = createTag('canvas');
      canvas.width = width;
      canvas.height = height;
      return canvas;
    }
    var assetLoader = function () {
      return {
        loadLumaCanvas: lumaLoader.load,
        getLumaCanvas: lumaLoader.get,
        createCanvas: createCanvas
      };
    }();
    var registeredEffects = {};
    function CVEffects(elem) {
      var i;
      var len = elem.data.ef ? elem.data.ef.length : 0;
      this.filters = [];
      var filterManager;
      for (i = 0; i < len; i += 1) {
        filterManager = null;
        var type = elem.data.ef[i].ty;
        if (registeredEffects[type]) {
          var Effect = registeredEffects[type].effect;
          filterManager = new Effect(elem.effectsManager.effectElements[i], elem);
        }
        if (filterManager) {
          this.filters.push(filterManager);
        }
      }
      if (this.filters.length) {
        elem.addRenderableComponent(this);
      }
    }
    CVEffects.prototype.renderFrame = function (_isFirstFrame) {
      var i;
      var len = this.filters.length;
      for (i = 0; i < len; i += 1) {
        this.filters[i].renderFrame(_isFirstFrame);
      }
    };
    CVEffects.prototype.getEffects = function (type) {
      var i;
      var len = this.filters.length;
      var effects = [];
      for (i = 0; i < len; i += 1) {
        if (this.filters[i].type === type) {
          effects.push(this.filters[i]);
        }
      }
      return effects;
    };
    function registerEffect(id, effect) {
      registeredEffects[id] = {
        effect: effect
      };
    }
    function CVMaskElement(data, element) {
      this.data = data;
      this.element = element;
      this.masksProperties = this.data.masksProperties || [];
      this.viewData = createSizedArray(this.masksProperties.length);
      var i;
      var len = this.masksProperties.length;
      var hasMasks = false;
      for (i = 0; i < len; i += 1) {
        if (this.masksProperties[i].mode !== 'n') {
          hasMasks = true;
        }
        this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
      }
      this.hasMasks = hasMasks;
      if (hasMasks) {
        this.element.addRenderableComponent(this);
      }
    }
    CVMaskElement.prototype.renderFrame = function () {
      if (!this.hasMasks) {
        return;
      }
      var transform = this.element.finalTransform.mat;
      var ctx = this.element.canvasContext;
      var i;
      var len = this.masksProperties.length;
      var pt;
      var pts;
      var data;
      ctx.beginPath();
      for (i = 0; i < len; i += 1) {
        if (this.masksProperties[i].mode !== 'n') {
          if (this.masksProperties[i].inv) {
            ctx.moveTo(0, 0);
            ctx.lineTo(this.element.globalData.compSize.w, 0);
            ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
            ctx.lineTo(0, this.element.globalData.compSize.h);
            ctx.lineTo(0, 0);
          }
          data = this.viewData[i].v;
          pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
          ctx.moveTo(pt[0], pt[1]);
          var j;
          var jLen = data._length;
          for (j = 1; j < jLen; j += 1) {
            pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
        }
      }
      this.element.globalData.renderer.save(true);
      ctx.clip();
    };
    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
    CVMaskElement.prototype.destroy = function () {
      this.element = null;
    };
    function CVBaseElement() {}
    var operationsMap = {
      1: 'source-in',
      2: 'source-out',
      3: 'source-in',
      4: 'source-out'
    };
    CVBaseElement.prototype = {
      createElements: function createElements() {},
      initRendererElement: function initRendererElement() {},
      createContainerElements: function createContainerElements() {
        // If the layer is masked we will use two buffers to store each different states of the drawing
        // This solution is not ideal for several reason. But unfortunately, because of the recursive
        // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.
        // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer
        // It might be challenging because the layer most likely is transformed in some way
        if (this.data.tt >= 1) {
          this.buffers = [];
          var canvasContext = this.globalData.canvasContext;
          var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
          this.buffers.push(bufferCanvas);
          var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
          this.buffers.push(bufferCanvas2);
          if (this.data.tt >= 3 && !document._isProxy) {
            assetLoader.loadLumaCanvas();
          }
        }
        this.canvasContext = this.globalData.canvasContext;
        this.transformCanvas = this.globalData.transformCanvas;
        this.renderableEffectsManager = new CVEffects(this);
        this.searchEffectTransforms();
      },
      createContent: function createContent() {},
      setBlendMode: function setBlendMode() {
        var globalData = this.globalData;
        if (globalData.blendMode !== this.data.bm) {
          globalData.blendMode = this.data.bm;
          var blendModeValue = getBlendMode(this.data.bm);
          globalData.canvasContext.globalCompositeOperation = blendModeValue;
        }
      },
      createRenderableComponents: function createRenderableComponents() {
        this.maskManager = new CVMaskElement(this.data, this);
        this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
      },
      hideElement: function hideElement() {
        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
          this.hidden = true;
        }
      },
      showElement: function showElement() {
        if (this.isInRange && !this.isTransparent) {
          this.hidden = false;
          this._isFirstFrame = true;
          this.maskManager._isFirstFrame = true;
        }
      },
      clearCanvas: function clearCanvas(canvasContext) {
        canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
      },
      prepareLayer: function prepareLayer() {
        if (this.data.tt >= 1) {
          var buffer = this.buffers[0];
          var bufferCtx = buffer.getContext('2d');
          this.clearCanvas(bufferCtx); // on the first buffer we store the current state of the global drawing

          bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // The next four lines are to clear the canvas
          // TODO: Check if there is a way to clear the canvas without resetting the transform

          this.currentTransform = this.canvasContext.getTransform();
          this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
          this.clearCanvas(this.canvasContext);
          this.canvasContext.setTransform(this.currentTransform);
        }
      },
      exitLayer: function exitLayer() {
        if (this.data.tt >= 1) {
          var buffer = this.buffers[1]; // On the second buffer we store the current state of the global drawing
          // that only contains the content of this layer
          // (if it is a composition, it also includes the nested layers)

          var bufferCtx = buffer.getContext('2d');
          this.clearCanvas(bufferCtx);
          bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // We clear the canvas again

          this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
          this.clearCanvas(this.canvasContext);
          this.canvasContext.setTransform(this.currentTransform); // We draw the mask

          var mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);
          mask.renderFrame(true); // We draw the second buffer (that contains the content of this layer)

          this.canvasContext.setTransform(1, 0, 0, 1, 0, 0); // If the mask is a Luma matte, we need to do two extra painting operations
          // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error

          if (this.data.tt >= 3 && !document._isProxy) {
            // We copy the painted mask to a buffer that has a color matrix filter applied to it
            // that applies the rgb values to the alpha channel
            var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
            var lumaBufferCtx = lumaBuffer.getContext('2d');
            lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
            this.clearCanvas(this.canvasContext); // we repaint the context with the mask applied to it

            this.canvasContext.drawImage(lumaBuffer, 0, 0);
          }
          this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
          this.canvasContext.drawImage(buffer, 0, 0); // We finally draw the first buffer (that contains the content of the global drawing)
          // We use destination-over to draw the global drawing below the current layer

          this.canvasContext.globalCompositeOperation = 'destination-over';
          this.canvasContext.drawImage(this.buffers[0], 0, 0);
          this.canvasContext.setTransform(this.currentTransform); // We reset the globalCompositeOperation to source-over, the standard type of operation

          this.canvasContext.globalCompositeOperation = 'source-over';
        }
      },
      renderFrame: function renderFrame(forceRender) {
        if (this.hidden || this.data.hd) {
          return;
        }
        if (this.data.td === 1 && !forceRender) {
          return;
        }
        this.renderTransform();
        this.renderRenderable();
        this.renderLocalTransform();
        this.setBlendMode();
        var forceRealStack = this.data.ty === 0;
        this.prepareLayer();
        this.globalData.renderer.save(forceRealStack);
        this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
        this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
        this.renderInnerContent();
        this.globalData.renderer.restore(forceRealStack);
        this.exitLayer();
        if (this.maskManager.hasMasks) {
          this.globalData.renderer.restore(true);
        }
        if (this._isFirstFrame) {
          this._isFirstFrame = false;
        }
      },
      destroy: function destroy() {
        this.canvasContext = null;
        this.data = null;
        this.globalData = null;
        this.maskManager.destroy();
      },
      mHelper: new Matrix()
    };
    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
    function CVShapeData(element, data, styles, transformsManager) {
      this.styledShapes = [];
      this.tr = [0, 0, 0, 0, 0, 0];
      var ty = 4;
      if (data.ty === 'rc') {
        ty = 5;
      } else if (data.ty === 'el') {
        ty = 6;
      } else if (data.ty === 'sr') {
        ty = 7;
      }
      this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
      var i;
      var len = styles.length;
      var styledShape;
      for (i = 0; i < len; i += 1) {
        if (!styles[i].closed) {
          styledShape = {
            transforms: transformsManager.addTransformSequence(styles[i].transforms),
            trNodes: []
          };
          this.styledShapes.push(styledShape);
          styles[i].elements.push(styledShape);
        }
      }
    }
    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
    function CVShapeElement(data, globalData, comp) {
      this.shapes = [];
      this.shapesData = data.shapes;
      this.stylesList = [];
      this.itemsData = [];
      this.prevViewData = [];
      this.shapeModifiers = [];
      this.processedElements = [];
      this.transformsManager = new ShapeTransformManager();
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
    CVShapeElement.prototype.transformHelper = {
      opacity: 1,
      _opMdf: false
    };
    CVShapeElement.prototype.dashResetter = [];
    CVShapeElement.prototype.createContent = function () {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
    };
    CVShapeElement.prototype.createStyleElement = function (data, transforms) {
      var styleElem = {
        data: data,
        type: data.ty,
        preTransforms: this.transformsManager.addTransformSequence(transforms),
        transforms: [],
        elements: [],
        closed: data.hd === true
      };
      var elementData = {};
      if (data.ty === 'fl' || data.ty === 'st') {
        elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
        if (!elementData.c.k) {
          styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
        }
      } else if (data.ty === 'gf' || data.ty === 'gs') {
        elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
        elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
        elementData.h = PropertyFactory.getProp(this, data.h || {
          k: 0
        }, 0, 0.01, this);
        elementData.a = PropertyFactory.getProp(this, data.a || {
          k: 0
        }, 0, degToRads, this);
        elementData.g = new GradientProperty(this, data.g, this);
      }
      elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
      if (data.ty === 'st' || data.ty === 'gs') {
        styleElem.lc = lineCapEnum[data.lc || 2];
        styleElem.lj = lineJoinEnum[data.lj || 2];
        if (data.lj == 1) {
          // eslint-disable-line eqeqeq
          styleElem.ml = data.ml;
        }
        elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
        if (!elementData.w.k) {
          styleElem.wi = elementData.w.v;
        }
        if (data.d) {
          var d = new DashProperty(this, data.d, 'canvas', this);
          elementData.d = d;
          if (!elementData.d.k) {
            styleElem.da = elementData.d.dashArray;
            styleElem["do"] = elementData.d.dashoffset[0];
          }
        }
      } else {
        styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
      }
      this.stylesList.push(styleElem);
      elementData.style = styleElem;
      return elementData;
    };
    CVShapeElement.prototype.createGroupElement = function () {
      var elementData = {
        it: [],
        prevViewData: []
      };
      return elementData;
    };
    CVShapeElement.prototype.createTransformElement = function (data) {
      var elementData = {
        transform: {
          opacity: 1,
          _opMdf: false,
          key: this.transformsManager.getNewKey(),
          op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
          mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
        }
      };
      return elementData;
    };
    CVShapeElement.prototype.createShapeElement = function (data) {
      var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
      this.shapes.push(elementData);
      this.addShapeToModifiers(elementData);
      return elementData;
    };
    CVShapeElement.prototype.reloadShapes = function () {
      this._isFirstFrame = true;
      var i;
      var len = this.itemsData.length;
      for (i = 0; i < len; i += 1) {
        this.prevViewData[i] = this.itemsData[i];
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      len = this.dynamicProperties.length;
      for (i = 0; i < len; i += 1) {
        this.dynamicProperties[i].getValue();
      }
      this.renderModifiers();
      this.transformsManager.processSequences(this._isFirstFrame);
    };
    CVShapeElement.prototype.addTransformToStyleList = function (transform) {
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        if (!this.stylesList[i].closed) {
          this.stylesList[i].transforms.push(transform);
        }
      }
    };
    CVShapeElement.prototype.removeTransformFromStyleList = function () {
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        if (!this.stylesList[i].closed) {
          this.stylesList[i].transforms.pop();
        }
      }
    };
    CVShapeElement.prototype.closeStyles = function (styles) {
      var i;
      var len = styles.length;
      for (i = 0; i < len; i += 1) {
        styles[i].closed = true;
      }
    };
    CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
      var i;
      var len = arr.length - 1;
      var j;
      var jLen;
      var ownStyles = [];
      var ownModifiers = [];
      var processedPos;
      var modifier;
      var currentTransform;
      var ownTransforms = [].concat(transforms);
      for (i = len; i >= 0; i -= 1) {
        processedPos = this.searchProcessedElement(arr[i]);
        if (!processedPos) {
          arr[i]._shouldRender = shouldRender;
        } else {
          itemsData[i] = prevViewData[processedPos - 1];
        }
        if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
          if (!processedPos) {
            itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
          } else {
            itemsData[i].style.closed = false;
          }
          ownStyles.push(itemsData[i].style);
        } else if (arr[i].ty === 'gr') {
          if (!processedPos) {
            itemsData[i] = this.createGroupElement(arr[i]);
          } else {
            jLen = itemsData[i].it.length;
            for (j = 0; j < jLen; j += 1) {
              itemsData[i].prevViewData[j] = itemsData[i].it[j];
            }
          }
          this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
        } else if (arr[i].ty === 'tr') {
          if (!processedPos) {
            currentTransform = this.createTransformElement(arr[i]);
            itemsData[i] = currentTransform;
          }
          ownTransforms.push(itemsData[i]);
          this.addTransformToStyleList(itemsData[i]);
        } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
          if (!processedPos) {
            itemsData[i] = this.createShapeElement(arr[i]);
          }
        } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            modifier.init(this, arr[i]);
            itemsData[i] = modifier;
            this.shapeModifiers.push(modifier);
          } else {
            modifier = itemsData[i];
            modifier.closed = false;
          }
          ownModifiers.push(modifier);
        } else if (arr[i].ty === 'rp') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            itemsData[i] = modifier;
            modifier.init(this, arr, i, itemsData);
            this.shapeModifiers.push(modifier);
            shouldRender = false;
          } else {
            modifier = itemsData[i];
            modifier.closed = true;
          }
          ownModifiers.push(modifier);
        }
        this.addProcessedElement(arr[i], i + 1);
      }
      this.removeTransformFromStyleList();
      this.closeStyles(ownStyles);
      len = ownModifiers.length;
      for (i = 0; i < len; i += 1) {
        ownModifiers[i].closed = true;
      }
    };
    CVShapeElement.prototype.renderInnerContent = function () {
      this.transformHelper.opacity = 1;
      this.transformHelper._opMdf = false;
      this.renderModifiers();
      this.transformsManager.processSequences(this._isFirstFrame);
      this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
    };
    CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
      if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
        groupTransform.opacity = parentTransform.opacity;
        groupTransform.opacity *= groupTransform.op.v;
        groupTransform._opMdf = true;
      }
    };
    CVShapeElement.prototype.drawLayer = function () {
      var i;
      var len = this.stylesList.length;
      var j;
      var jLen;
      var k;
      var kLen;
      var elems;
      var nodes;
      var renderer = this.globalData.renderer;
      var ctx = this.globalData.canvasContext;
      var type;
      var currentStyle;
      for (i = 0; i < len; i += 1) {
        currentStyle = this.stylesList[i];
        type = currentStyle.type; // Skipping style when
        // Stroke width equals 0
        // style should not be rendered (extra unused repeaters)
        // current opacity equals 0
        // global opacity equals 0

        if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
          renderer.save();
          elems = currentStyle.elements;
          if (type === 'st' || type === 'gs') {
            renderer.ctxStrokeStyle(type === 'st' ? currentStyle.co : currentStyle.grd); // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;

            renderer.ctxLineWidth(currentStyle.wi); // ctx.lineWidth = currentStyle.wi;

            renderer.ctxLineCap(currentStyle.lc); // ctx.lineCap = currentStyle.lc;

            renderer.ctxLineJoin(currentStyle.lj); // ctx.lineJoin = currentStyle.lj;

            renderer.ctxMiterLimit(currentStyle.ml || 0); // ctx.miterLimit = currentStyle.ml || 0;
          } else {
            renderer.ctxFillStyle(type === 'fl' ? currentStyle.co : currentStyle.grd); // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
          }
          renderer.ctxOpacity(currentStyle.coOp);
          if (type !== 'st' && type !== 'gs') {
            ctx.beginPath();
          }
          renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
          jLen = elems.length;
          for (j = 0; j < jLen; j += 1) {
            if (type === 'st' || type === 'gs') {
              ctx.beginPath();
              if (currentStyle.da) {
                ctx.setLineDash(currentStyle.da);
                ctx.lineDashOffset = currentStyle["do"];
              }
            }
            nodes = elems[j].trNodes;
            kLen = nodes.length;
            for (k = 0; k < kLen; k += 1) {
              if (nodes[k].t === 'm') {
                ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
              } else if (nodes[k].t === 'c') {
                ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
              } else {
                ctx.closePath();
              }
            }
            if (type === 'st' || type === 'gs') {
              // ctx.stroke();
              renderer.ctxStroke();
              if (currentStyle.da) {
                ctx.setLineDash(this.dashResetter);
              }
            }
          }
          if (type !== 'st' && type !== 'gs') {
            // ctx.fill(currentStyle.r);
            this.globalData.renderer.ctxFill(currentStyle.r);
          }
          renderer.restore();
        }
      }
    };
    CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
      var i;
      var len = items.length - 1;
      var groupTransform;
      groupTransform = parentTransform;
      for (i = len; i >= 0; i -= 1) {
        if (items[i].ty === 'tr') {
          groupTransform = data[i].transform;
          this.renderShapeTransform(parentTransform, groupTransform);
        } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
          this.renderPath(items[i], data[i]);
        } else if (items[i].ty === 'fl') {
          this.renderFill(items[i], data[i], groupTransform);
        } else if (items[i].ty === 'st') {
          this.renderStroke(items[i], data[i], groupTransform);
        } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
          this.renderGradientFill(items[i], data[i], groupTransform);
        } else if (items[i].ty === 'gr') {
          this.renderShape(groupTransform, items[i].it, data[i].it);
        } else ;
      }
      if (isMain) {
        this.drawLayer();
      }
    };
    CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
      if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
        var shapeNodes = styledShape.trNodes;
        var paths = shape.paths;
        var i;
        var len;
        var j;
        var jLen = paths._length;
        shapeNodes.length = 0;
        var groupTransformMat = styledShape.transforms.finalTransform;
        for (j = 0; j < jLen; j += 1) {
          var pathNodes = paths.shapes[j];
          if (pathNodes && pathNodes.v) {
            len = pathNodes._length;
            for (i = 1; i < len; i += 1) {
              if (i === 1) {
                shapeNodes.push({
                  t: 'm',
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                });
              }
              shapeNodes.push({
                t: 'c',
                pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
              });
            }
            if (len === 1) {
              shapeNodes.push({
                t: 'm',
                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
              });
            }
            if (pathNodes.c && len) {
              shapeNodes.push({
                t: 'c',
                pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
              });
              shapeNodes.push({
                t: 'z'
              });
            }
          }
        }
        styledShape.trNodes = shapeNodes;
      }
    };
    CVShapeElement.prototype.renderPath = function (pathData, itemData) {
      if (pathData.hd !== true && pathData._shouldRender) {
        var i;
        var len = itemData.styledShapes.length;
        for (i = 0; i < len; i += 1) {
          this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
        }
      }
    };
    CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      if (itemData.c._mdf || this._isFirstFrame) {
        styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
      }
      if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      }
    };
    CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      var grd;
      if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
        var ctx = this.globalData.canvasContext;
        var pt1 = itemData.s.v;
        var pt2 = itemData.e.v;
        if (styleData.t === 1) {
          grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
        } else {
          var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
          var percent = itemData.h.v;
          if (percent >= 1) {
            percent = 0.99;
          } else if (percent <= -1) {
            percent = -0.99;
          }
          var dist = rad * percent;
          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
          grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
        }
        var i;
        var len = styleData.g.p;
        var cValues = itemData.g.c;
        var opacity = 1;
        for (i = 0; i < len; i += 1) {
          if (itemData.g._hasOpacity && itemData.g._collapsable) {
            opacity = itemData.g.o[i * 2 + 1];
          }
          grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
        }
        styleElem.grd = grd;
      }
      styleElem.coOp = itemData.o.v * groupTransform.opacity;
    };
    CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      var d = itemData.d;
      if (d && (d._mdf || this._isFirstFrame)) {
        styleElem.da = d.dashArray;
        styleElem["do"] = d.dashoffset[0];
      }
      if (itemData.c._mdf || this._isFirstFrame) {
        styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
      }
      if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      }
      if (itemData.w._mdf || this._isFirstFrame) {
        styleElem.wi = itemData.w.v;
      }
    };
    CVShapeElement.prototype.destroy = function () {
      this.shapesData = null;
      this.globalData = null;
      this.canvasContext = null;
      this.stylesList.length = 0;
      this.itemsData.length = 0;
    };
    function CVTextElement(data, globalData, comp) {
      this.textSpans = [];
      this.yOffset = 0;
      this.fillColorAnim = false;
      this.strokeColorAnim = false;
      this.strokeWidthAnim = false;
      this.stroke = false;
      this.fill = false;
      this.justifyOffset = 0;
      this.currentRender = null;
      this.renderType = 'canvas';
      this.values = {
        fill: 'rgba(0,0,0,0)',
        stroke: 'rgba(0,0,0,0)',
        sWidth: 0,
        fValue: ''
      };
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
    CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');
    CVTextElement.prototype.buildNewText = function () {
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
      var hasFill = false;
      if (documentData.fc) {
        hasFill = true;
        this.values.fill = this.buildColor(documentData.fc);
      } else {
        this.values.fill = 'rgba(0,0,0,0)';
      }
      this.fill = hasFill;
      var hasStroke = false;
      if (documentData.sc) {
        hasStroke = true;
        this.values.stroke = this.buildColor(documentData.sc);
        this.values.sWidth = documentData.sw;
      }
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      var i;
      var len;
      var letters = documentData.l;
      var matrixHelper = this.mHelper;
      this.stroke = hasStroke;
      this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
      len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;

      var charData;
      var shapeData;
      var k;
      var kLen;
      var shapes;
      var j;
      var jLen;
      var pathNodes;
      var commands;
      var pathArr;
      var singleShape = this.data.singleShape;
      var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
      var xPos = 0;
      var yPos = 0;
      var firstLine = true;
      var cnt = 0;
      for (i = 0; i < len; i += 1) {
        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
        shapeData = charData && charData.data || {};
        matrixHelper.reset();
        if (singleShape && letters[i].n) {
          xPos = -trackingOffset;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          firstLine = false;
        }
        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
        jLen = shapes.length;
        matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
        if (singleShape) {
          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
        }
        commands = createSizedArray(jLen - 1);
        var commandsCounter = 0;
        for (j = 0; j < jLen; j += 1) {
          if (shapes[j].ty === 'sh') {
            kLen = shapes[j].ks.k.i.length;
            pathNodes = shapes[j].ks.k;
            pathArr = [];
            for (k = 1; k < kLen; k += 1) {
              if (k === 1) {
                pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
              }
              pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
            }
            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
            commands[commandsCounter] = pathArr;
            commandsCounter += 1;
          }
        }
        if (singleShape) {
          xPos += letters[i].l;
          xPos += trackingOffset;
        }
        if (this.textSpans[cnt]) {
          this.textSpans[cnt].elem = commands;
        } else {
          this.textSpans[cnt] = {
            elem: commands
          };
        }
        cnt += 1;
      }
    };
    CVTextElement.prototype.renderInnerContent = function () {
      this.validateText();
      var ctx = this.canvasContext;
      ctx.font = this.values.fValue;
      this.globalData.renderer.ctxLineCap('butt'); // ctx.lineCap = 'butt';

      this.globalData.renderer.ctxLineJoin('miter'); // ctx.lineJoin = 'miter';

      this.globalData.renderer.ctxMiterLimit(4); // ctx.miterLimit = 4;

      if (!this.data.singleShape) {
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      }
      var i;
      var len;
      var j;
      var jLen;
      var k;
      var kLen;
      var renderedLetters = this.textAnimator.renderedLetters;
      var letters = this.textProperty.currentData.l;
      len = letters.length;
      var renderedLetter;
      var lastFill = null;
      var lastStroke = null;
      var lastStrokeW = null;
      var commands;
      var pathArr;
      var renderer = this.globalData.renderer;
      for (i = 0; i < len; i += 1) {
        if (!letters[i].n) {
          renderedLetter = renderedLetters[i];
          if (renderedLetter) {
            renderer.save();
            renderer.ctxTransform(renderedLetter.p);
            renderer.ctxOpacity(renderedLetter.o);
          }
          if (this.fill) {
            if (renderedLetter && renderedLetter.fc) {
              if (lastFill !== renderedLetter.fc) {
                renderer.ctxFillStyle(renderedLetter.fc);
                lastFill = renderedLetter.fc; // ctx.fillStyle = renderedLetter.fc;
              }
            } else if (lastFill !== this.values.fill) {
              lastFill = this.values.fill;
              renderer.ctxFillStyle(this.values.fill); // ctx.fillStyle = this.values.fill;
            }
            commands = this.textSpans[i].elem;
            jLen = commands.length;
            this.globalData.canvasContext.beginPath();
            for (j = 0; j < jLen; j += 1) {
              pathArr = commands[j];
              kLen = pathArr.length;
              this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
              for (k = 2; k < kLen; k += 6) {
                this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
              }
            }
            this.globalData.canvasContext.closePath();
            renderer.ctxFill(); // this.globalData.canvasContext.fill();
            /// ctx.fillText(this.textSpans[i].val,0,0);
          }
          if (this.stroke) {
            if (renderedLetter && renderedLetter.sw) {
              if (lastStrokeW !== renderedLetter.sw) {
                lastStrokeW = renderedLetter.sw;
                renderer.ctxLineWidth(renderedLetter.sw); // ctx.lineWidth = renderedLetter.sw;
              }
            } else if (lastStrokeW !== this.values.sWidth) {
              lastStrokeW = this.values.sWidth;
              renderer.ctxLineWidth(this.values.sWidth); // ctx.lineWidth = this.values.sWidth;
            }
            if (renderedLetter && renderedLetter.sc) {
              if (lastStroke !== renderedLetter.sc) {
                lastStroke = renderedLetter.sc;
                renderer.ctxStrokeStyle(renderedLetter.sc); // ctx.strokeStyle = renderedLetter.sc;
              }
            } else if (lastStroke !== this.values.stroke) {
              lastStroke = this.values.stroke;
              renderer.ctxStrokeStyle(this.values.stroke); // ctx.strokeStyle = this.values.stroke;
            }
            commands = this.textSpans[i].elem;
            jLen = commands.length;
            this.globalData.canvasContext.beginPath();
            for (j = 0; j < jLen; j += 1) {
              pathArr = commands[j];
              kLen = pathArr.length;
              this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
              for (k = 2; k < kLen; k += 6) {
                this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
              }
            }
            this.globalData.canvasContext.closePath();
            renderer.ctxStroke(); // this.globalData.canvasContext.stroke();
            /// ctx.strokeText(letters[i].val,0,0);
          }
          if (renderedLetter) {
            this.globalData.renderer.restore();
          }
        }
      }
    };
    function CVImageElement(data, globalData, comp) {
      this.assetData = globalData.getAssetData(data.refId);
      this.img = globalData.imageLoader.getAsset(this.assetData);
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
    CVImageElement.prototype.createContent = function () {
      if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
        var canvas = createTag('canvas');
        canvas.width = this.assetData.w;
        canvas.height = this.assetData.h;
        var ctx = canvas.getContext('2d');
        var imgW = this.img.width;
        var imgH = this.img.height;
        var imgRel = imgW / imgH;
        var canvasRel = this.assetData.w / this.assetData.h;
        var widthCrop;
        var heightCrop;
        var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
        if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {
          heightCrop = imgH;
          widthCrop = heightCrop * canvasRel;
        } else {
          widthCrop = imgW;
          heightCrop = widthCrop / canvasRel;
        }
        ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
        this.img = canvas;
      }
    };
    CVImageElement.prototype.renderInnerContent = function () {
      this.canvasContext.drawImage(this.img, 0, 0);
    };
    CVImageElement.prototype.destroy = function () {
      this.img = null;
    };
    function CVSolidElement(data, globalData, comp) {
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
    CVSolidElement.prototype.renderInnerContent = function () {
      // var ctx = this.canvasContext;
      this.globalData.renderer.ctxFillStyle(this.data.sc); // ctx.fillStyle = this.data.sc;

      this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh); // ctx.fillRect(0, 0, this.data.sw, this.data.sh);
      //
    };
    function CanvasRendererBase() {}
    extendPrototype([BaseRenderer], CanvasRendererBase);
    CanvasRendererBase.prototype.createShape = function (data) {
      return new CVShapeElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createText = function (data) {
      return new CVTextElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createImage = function (data) {
      return new CVImageElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createSolid = function (data) {
      return new CVSolidElement(data, this.globalData, this);
    };
    CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
    CanvasRendererBase.prototype.ctxTransform = function (props) {
      if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
        return;
      }
      this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
    };
    CanvasRendererBase.prototype.ctxOpacity = function (op) {
      this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
    };
    CanvasRendererBase.prototype.ctxFillStyle = function (value) {
      this.canvasContext.fillStyle = value;
    };
    CanvasRendererBase.prototype.ctxStrokeStyle = function (value) {
      this.canvasContext.strokeStyle = value;
    };
    CanvasRendererBase.prototype.ctxLineWidth = function (value) {
      this.canvasContext.lineWidth = value;
    };
    CanvasRendererBase.prototype.ctxLineCap = function (value) {
      this.canvasContext.lineCap = value;
    };
    CanvasRendererBase.prototype.ctxLineJoin = function (value) {
      this.canvasContext.lineJoin = value;
    };
    CanvasRendererBase.prototype.ctxMiterLimit = function (value) {
      this.canvasContext.miterLimit = value;
    };
    CanvasRendererBase.prototype.ctxFill = function (rule) {
      this.canvasContext.fill(rule);
    };
    CanvasRendererBase.prototype.ctxFillRect = function (x, y, w, h) {
      this.canvasContext.fillRect(x, y, w, h);
    };
    CanvasRendererBase.prototype.ctxStroke = function () {
      this.canvasContext.stroke();
    };
    CanvasRendererBase.prototype.reset = function () {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      this.contextData.reset();
    };
    CanvasRendererBase.prototype.save = function () {
      this.canvasContext.save();
    };
    CanvasRendererBase.prototype.restore = function (actionFlag) {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      if (actionFlag) {
        this.globalData.blendMode = 'source-over';
      }
      this.contextData.restore(actionFlag);
    };
    CanvasRendererBase.prototype.configAnimation = function (animData) {
      if (this.animationItem.wrapper) {
        this.animationItem.container = createTag('canvas');
        var containerStyle = this.animationItem.container.style;
        containerStyle.width = '100%';
        containerStyle.height = '100%';
        var origin = '0px 0px 0px';
        containerStyle.transformOrigin = origin;
        containerStyle.mozTransformOrigin = origin;
        containerStyle.webkitTransformOrigin = origin;
        containerStyle['-webkit-transform'] = origin;
        containerStyle.contentVisibility = this.renderConfig.contentVisibility;
        this.animationItem.wrapper.appendChild(this.animationItem.container);
        this.canvasContext = this.animationItem.container.getContext('2d');
        if (this.renderConfig.className) {
          this.animationItem.container.setAttribute('class', this.renderConfig.className);
        }
        if (this.renderConfig.id) {
          this.animationItem.container.setAttribute('id', this.renderConfig.id);
        }
      } else {
        this.canvasContext = this.renderConfig.context;
      }
      this.contextData.setContext(this.canvasContext);
      this.data = animData;
      this.layers = animData.layers;
      this.transformCanvas = {
        w: animData.w,
        h: animData.h,
        sx: 0,
        sy: 0,
        tx: 0,
        ty: 0
      };
      this.setupGlobalData(animData, document.body);
      this.globalData.canvasContext = this.canvasContext;
      this.globalData.renderer = this;
      this.globalData.isDashed = false;
      this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
      this.globalData.transformCanvas = this.transformCanvas;
      this.elements = createSizedArray(animData.layers.length);
      this.updateContainerSize();
    };
    CanvasRendererBase.prototype.updateContainerSize = function (width, height) {
      this.reset();
      var elementWidth;
      var elementHeight;
      if (width) {
        elementWidth = width;
        elementHeight = height;
        this.canvasContext.canvas.width = elementWidth;
        this.canvasContext.canvas.height = elementHeight;
      } else {
        if (this.animationItem.wrapper && this.animationItem.container) {
          elementWidth = this.animationItem.wrapper.offsetWidth;
          elementHeight = this.animationItem.wrapper.offsetHeight;
        } else {
          elementWidth = this.canvasContext.canvas.width;
          elementHeight = this.canvasContext.canvas.height;
        }
        this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
        this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
      }
      var elementRel;
      var animationRel;
      if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
        var par = this.renderConfig.preserveAspectRatio.split(' ');
        var fillType = par[1] || 'meet';
        var pos = par[0] || 'xMidYMid';
        var xPos = pos.substr(0, 4);
        var yPos = pos.substr(4);
        elementRel = elementWidth / elementHeight;
        animationRel = this.transformCanvas.w / this.transformCanvas.h;
        if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
        } else {
          this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
        }
        if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
          this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
        } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
          this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
        } else {
          this.transformCanvas.tx = 0;
        }
        if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
          this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
        } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
          this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
        } else {
          this.transformCanvas.ty = 0;
        }
      } else if (this.renderConfig.preserveAspectRatio === 'none') {
        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
        this.transformCanvas.tx = 0;
        this.transformCanvas.ty = 0;
      } else {
        this.transformCanvas.sx = this.renderConfig.dpr;
        this.transformCanvas.sy = this.renderConfig.dpr;
        this.transformCanvas.tx = 0;
        this.transformCanvas.ty = 0;
      }
      this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
      /* var i, len = this.elements.length;
        for(i=0;i<len;i+=1){
            if(this.elements[i] && this.elements[i].data.ty === 0){
                this.elements[i].resize(this.globalData.transformCanvas);
            }
        } */

      this.ctxTransform(this.transformCanvas.props);
      this.canvasContext.beginPath();
      this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
      this.canvasContext.closePath();
      this.canvasContext.clip();
      this.renderFrame(this.renderedFrame, true);
    };
    CanvasRendererBase.prototype.destroy = function () {
      if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = '';
      }
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.elements[i] && this.elements[i].destroy) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.globalData.canvasContext = null;
      this.animationItem.container = null;
      this.destroyed = true;
    };
    CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {
      if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
        return;
      }
      this.renderedFrame = num;
      this.globalData.frameNum = num - this.animationItem._isFirstFrame;
      this.globalData.frameId += 1;
      this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
      this.globalData.projectInterface.currentFrame = num; // console.log('--------');
      // console.log('NEW: ',num);

      var i;
      var len = this.layers.length;
      if (!this.completeLayers) {
        this.checkLayers(num);
      }
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(num - this.layers[i].st);
        }
      }
      if (this.globalData._mdf) {
        if (this.renderConfig.clearCanvas === true) {
          this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        } else {
          this.save();
        }
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
        if (this.renderConfig.clearCanvas !== true) {
          this.restore();
        }
      }
    };
    CanvasRendererBase.prototype.buildItem = function (pos) {
      var elements = this.elements;
      if (elements[pos] || this.layers[pos].ty === 99) {
        return;
      }
      var element = this.createItem(this.layers[pos], this, this.globalData);
      elements[pos] = element;
      element.initExpressions();
      /* if(this.layers[pos].ty === 0){
            element.resize(this.globalData.transformCanvas);
        } */
    };
    CanvasRendererBase.prototype.checkPendingElements = function () {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
      }
    };
    CanvasRendererBase.prototype.hide = function () {
      this.animationItem.container.style.display = 'none';
    };
    CanvasRendererBase.prototype.show = function () {
      this.animationItem.container.style.display = 'block';
    };
    function CanvasContext() {
      this.opacity = -1;
      this.transform = createTypedArray('float32', 16);
      this.fillStyle = '';
      this.strokeStyle = '';
      this.lineWidth = '';
      this.lineCap = '';
      this.lineJoin = '';
      this.miterLimit = '';
      this.id = Math.random();
    }
    function CVContextData() {
      this.stack = [];
      this.cArrPos = 0;
      this.cTr = new Matrix();
      var i;
      var len = 15;
      for (i = 0; i < len; i += 1) {
        var canvasContext = new CanvasContext();
        this.stack[i] = canvasContext;
      }
      this._length = len;
      this.nativeContext = null;
      this.transformMat = new Matrix();
      this.currentOpacity = 1; //

      this.currentFillStyle = '';
      this.appliedFillStyle = ''; //

      this.currentStrokeStyle = '';
      this.appliedStrokeStyle = ''; //

      this.currentLineWidth = '';
      this.appliedLineWidth = ''; //

      this.currentLineCap = '';
      this.appliedLineCap = ''; //

      this.currentLineJoin = '';
      this.appliedLineJoin = ''; //

      this.appliedMiterLimit = '';
      this.currentMiterLimit = '';
    }
    CVContextData.prototype.duplicate = function () {
      var newLength = this._length * 2;
      var i = 0;
      for (i = this._length; i < newLength; i += 1) {
        this.stack[i] = new CanvasContext();
      }
      this._length = newLength;
    };
    CVContextData.prototype.reset = function () {
      this.cArrPos = 0;
      this.cTr.reset();
      this.stack[this.cArrPos].opacity = 1;
    };
    CVContextData.prototype.restore = function (forceRestore) {
      this.cArrPos -= 1;
      var currentContext = this.stack[this.cArrPos];
      var transform = currentContext.transform;
      var i;
      var arr = this.cTr.props;
      for (i = 0; i < 16; i += 1) {
        arr[i] = transform[i];
      }
      if (forceRestore) {
        this.nativeContext.restore();
        var prevStack = this.stack[this.cArrPos + 1];
        this.appliedFillStyle = prevStack.fillStyle;
        this.appliedStrokeStyle = prevStack.strokeStyle;
        this.appliedLineWidth = prevStack.lineWidth;
        this.appliedLineCap = prevStack.lineCap;
        this.appliedLineJoin = prevStack.lineJoin;
        this.appliedMiterLimit = prevStack.miterLimit;
      }
      this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);
      if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
        this.nativeContext.globalAlpha = currentContext.opacity;
        this.currentOpacity = currentContext.opacity;
      }
      this.currentFillStyle = currentContext.fillStyle;
      this.currentStrokeStyle = currentContext.strokeStyle;
      this.currentLineWidth = currentContext.lineWidth;
      this.currentLineCap = currentContext.lineCap;
      this.currentLineJoin = currentContext.lineJoin;
      this.currentMiterLimit = currentContext.miterLimit;
    };
    CVContextData.prototype.save = function (saveOnNativeFlag) {
      if (saveOnNativeFlag) {
        this.nativeContext.save();
      }
      var props = this.cTr.props;
      if (this._length <= this.cArrPos) {
        this.duplicate();
      }
      var currentStack = this.stack[this.cArrPos];
      var i;
      for (i = 0; i < 16; i += 1) {
        currentStack.transform[i] = props[i];
      }
      this.cArrPos += 1;
      var newStack = this.stack[this.cArrPos];
      newStack.opacity = currentStack.opacity;
      newStack.fillStyle = currentStack.fillStyle;
      newStack.strokeStyle = currentStack.strokeStyle;
      newStack.lineWidth = currentStack.lineWidth;
      newStack.lineCap = currentStack.lineCap;
      newStack.lineJoin = currentStack.lineJoin;
      newStack.miterLimit = currentStack.miterLimit;
    };
    CVContextData.prototype.setOpacity = function (value) {
      this.stack[this.cArrPos].opacity = value;
    };
    CVContextData.prototype.setContext = function (value) {
      this.nativeContext = value;
    };
    CVContextData.prototype.fillStyle = function (value) {
      if (this.stack[this.cArrPos].fillStyle !== value) {
        this.currentFillStyle = value;
        this.stack[this.cArrPos].fillStyle = value;
      }
    };
    CVContextData.prototype.strokeStyle = function (value) {
      if (this.stack[this.cArrPos].strokeStyle !== value) {
        this.currentStrokeStyle = value;
        this.stack[this.cArrPos].strokeStyle = value;
      }
    };
    CVContextData.prototype.lineWidth = function (value) {
      if (this.stack[this.cArrPos].lineWidth !== value) {
        this.currentLineWidth = value;
        this.stack[this.cArrPos].lineWidth = value;
      }
    };
    CVContextData.prototype.lineCap = function (value) {
      if (this.stack[this.cArrPos].lineCap !== value) {
        this.currentLineCap = value;
        this.stack[this.cArrPos].lineCap = value;
      }
    };
    CVContextData.prototype.lineJoin = function (value) {
      if (this.stack[this.cArrPos].lineJoin !== value) {
        this.currentLineJoin = value;
        this.stack[this.cArrPos].lineJoin = value;
      }
    };
    CVContextData.prototype.miterLimit = function (value) {
      if (this.stack[this.cArrPos].miterLimit !== value) {
        this.currentMiterLimit = value;
        this.stack[this.cArrPos].miterLimit = value;
      }
    };
    CVContextData.prototype.transform = function (props) {
      this.transformMat.cloneFromProps(props); // Taking the last transform value from the stored stack of transforms

      var currentTransform = this.cTr; // Applying the last transform value after the new transform to respect the order of transformations

      this.transformMat.multiply(currentTransform); // Storing the new transformed value in the stored transform

      currentTransform.cloneFromProps(this.transformMat.props);
      var trProps = currentTransform.props; // Applying the new transform to the canvas

      this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
    };
    CVContextData.prototype.opacity = function (op) {
      var currentOpacity = this.stack[this.cArrPos].opacity;
      currentOpacity *= op < 0 ? 0 : op;
      if (this.stack[this.cArrPos].opacity !== currentOpacity) {
        if (this.currentOpacity !== op) {
          this.nativeContext.globalAlpha = op;
          this.currentOpacity = op;
        }
        this.stack[this.cArrPos].opacity = currentOpacity;
      }
    };
    CVContextData.prototype.fill = function (rule) {
      if (this.appliedFillStyle !== this.currentFillStyle) {
        this.appliedFillStyle = this.currentFillStyle;
        this.nativeContext.fillStyle = this.appliedFillStyle;
      }
      this.nativeContext.fill(rule);
    };
    CVContextData.prototype.fillRect = function (x, y, w, h) {
      if (this.appliedFillStyle !== this.currentFillStyle) {
        this.appliedFillStyle = this.currentFillStyle;
        this.nativeContext.fillStyle = this.appliedFillStyle;
      }
      this.nativeContext.fillRect(x, y, w, h);
    };
    CVContextData.prototype.stroke = function () {
      if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
        this.appliedStrokeStyle = this.currentStrokeStyle;
        this.nativeContext.strokeStyle = this.appliedStrokeStyle;
      }
      if (this.appliedLineWidth !== this.currentLineWidth) {
        this.appliedLineWidth = this.currentLineWidth;
        this.nativeContext.lineWidth = this.appliedLineWidth;
      }
      if (this.appliedLineCap !== this.currentLineCap) {
        this.appliedLineCap = this.currentLineCap;
        this.nativeContext.lineCap = this.appliedLineCap;
      }
      if (this.appliedLineJoin !== this.currentLineJoin) {
        this.appliedLineJoin = this.currentLineJoin;
        this.nativeContext.lineJoin = this.appliedLineJoin;
      }
      if (this.appliedMiterLimit !== this.currentMiterLimit) {
        this.appliedMiterLimit = this.currentMiterLimit;
        this.nativeContext.miterLimit = this.appliedMiterLimit;
      }
      this.nativeContext.stroke();
    };
    function CVCompElement(data, globalData, comp) {
      this.completeLayers = false;
      this.layers = data.layers;
      this.pendingElements = [];
      this.elements = createSizedArray(this.layers.length);
      this.initElement(data, globalData, comp);
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
        _placeholder: true
      };
    }
    extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
    CVCompElement.prototype.renderInnerContent = function () {
      var ctx = this.canvasContext;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(this.data.w, 0);
      ctx.lineTo(this.data.w, this.data.h);
      ctx.lineTo(0, this.data.h);
      ctx.lineTo(0, 0);
      ctx.clip();
      var i;
      var len = this.layers.length;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }
    };
    CVCompElement.prototype.destroy = function () {
      var i;
      var len = this.layers.length;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
      this.layers = null;
      this.elements = null;
    };
    CVCompElement.prototype.createComp = function (data) {
      return new CVCompElement(data, this.globalData, this);
    };
    function CanvasRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.renderConfig = {
        clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
        context: config && config.context || null,
        progressiveLoad: config && config.progressiveLoad || false,
        preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
        contentVisibility: config && config.contentVisibility || 'visible',
        className: config && config.className || '',
        id: config && config.id || '',
        runExpressions: !config || config.runExpressions === undefined || config.runExpressions
      };
      this.renderConfig.dpr = config && config.dpr || 1;
      if (this.animationItem.wrapper) {
        this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
      }
      this.renderedFrame = -1;
      this.globalData = {
        frameNum: -1,
        _mdf: false,
        renderConfig: this.renderConfig,
        currentGlobalAlpha: -1
      };
      this.contextData = new CVContextData();
      this.elements = [];
      this.pendingElements = [];
      this.transformMat = new Matrix();
      this.completeLayers = false;
      this.rendererType = 'canvas';
      if (this.renderConfig.clearCanvas) {
        this.ctxTransform = this.contextData.transform.bind(this.contextData);
        this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
        this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
        this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
        this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
        this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
        this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
        this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
        this.ctxFill = this.contextData.fill.bind(this.contextData);
        this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
        this.ctxStroke = this.contextData.stroke.bind(this.contextData);
        this.save = this.contextData.save.bind(this.contextData);
      }
    }
    extendPrototype([CanvasRendererBase], CanvasRenderer);
    CanvasRenderer.prototype.createComp = function (data) {
      return new CVCompElement(data, this.globalData, this);
    };
    function HBaseElement() {}
    HBaseElement.prototype = {
      checkBlendMode: function checkBlendMode() {},
      initRendererElement: function initRendererElement() {
        this.baseElement = createTag(this.data.tg || 'div');
        if (this.data.hasMask) {
          this.svgElement = createNS('svg');
          this.layerElement = createNS('g');
          this.maskedElement = this.layerElement;
          this.svgElement.appendChild(this.layerElement);
          this.baseElement.appendChild(this.svgElement);
        } else {
          this.layerElement = this.baseElement;
        }
        styleDiv(this.baseElement);
      },
      createContainerElements: function createContainerElements() {
        this.renderableEffectsManager = new CVEffects(this);
        this.transformedElement = this.baseElement;
        this.maskedElement = this.layerElement;
        if (this.data.ln) {
          this.layerElement.setAttribute('id', this.data.ln);
        }
        if (this.data.cl) {
          this.layerElement.setAttribute('class', this.data.cl);
        }
        if (this.data.bm !== 0) {
          this.setBlendMode();
        }
      },
      renderElement: function renderElement() {
        var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
        if (this.finalTransform._matMdf) {
          var matrixValue = this.finalTransform.mat.toCSS();
          transformedElementStyle.transform = matrixValue;
          transformedElementStyle.webkitTransform = matrixValue;
        }
        if (this.finalTransform._opMdf) {
          transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
        }
      },
      renderFrame: function renderFrame() {
        // If it is exported as hidden (data.hd === true) no need to render
        // If it is not visible no need to render
        if (this.data.hd || this.hidden) {
          return;
        }
        this.renderTransform();
        this.renderRenderable();
        this.renderElement();
        this.renderInnerContent();
        if (this._isFirstFrame) {
          this._isFirstFrame = false;
        }
      },
      destroy: function destroy() {
        this.layerElement = null;
        this.transformedElement = null;
        if (this.matteElement) {
          this.matteElement = null;
        }
        if (this.maskManager) {
          this.maskManager.destroy();
          this.maskManager = null;
        }
      },
      createRenderableComponents: function createRenderableComponents() {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
      },
      addEffects: function addEffects() {},
      setMatte: function setMatte() {}
    };
    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
    HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
    function HSolidElement(data, globalData, comp) {
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
    HSolidElement.prototype.createContent = function () {
      var rect;
      if (this.data.hasMask) {
        rect = createNS('rect');
        rect.setAttribute('width', this.data.sw);
        rect.setAttribute('height', this.data.sh);
        rect.setAttribute('fill', this.data.sc);
        this.svgElement.setAttribute('width', this.data.sw);
        this.svgElement.setAttribute('height', this.data.sh);
      } else {
        rect = createTag('div');
        rect.style.width = this.data.sw + 'px';
        rect.style.height = this.data.sh + 'px';
        rect.style.backgroundColor = this.data.sc;
      }
      this.layerElement.appendChild(rect);
    };
    function HShapeElement(data, globalData, comp) {
      // List of drawable elements
      this.shapes = []; // Full shape data

      this.shapesData = data.shapes; // List of styles that will be applied to shapes

      this.stylesList = []; // List of modifiers that will be applied to shapes

      this.shapeModifiers = []; // List of items in shape tree

      this.itemsData = []; // List of items in previous shape tree

      this.processedElements = []; // List of animated components

      this.animatedContents = [];
      this.shapesContainer = createNS('g');
      this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
      // List of elements that have been created

      this.prevViewData = [];
      this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      };
    }
    extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
    HShapeElement.prototype.createContent = function () {
      var cont;
      this.baseElement.style.fontSize = 0;
      if (this.data.hasMask) {
        this.layerElement.appendChild(this.shapesContainer);
        cont = this.svgElement;
      } else {
        cont = createNS('svg');
        var size = this.comp.data ? this.comp.data : this.globalData.compSize;
        cont.setAttribute('width', size.w);
        cont.setAttribute('height', size.h);
        cont.appendChild(this.shapesContainer);
        this.layerElement.appendChild(cont);
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
      this.filterUniqueShapes();
      this.shapeCont = cont;
    };
    HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
      var i;
      var len = transformers.length;
      for (i = 0; i < len; i += 1) {
        point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
      }
      return point;
    };
    HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
      var shape = item.sh.v;
      var transformers = item.transformers;
      var i;
      var len = shape._length;
      var vPoint;
      var oPoint;
      var nextIPoint;
      var nextVPoint;
      if (len <= 1) {
        return;
      }
      for (i = 0; i < len - 1; i += 1) {
        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
        nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
        nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
      }
      if (shape.c) {
        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
        nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
        nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
      }
    };
    HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
      this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
      var bounds = this.shapeBoundingBox;
      boundingBox.x = bmMin(bounds.left, boundingBox.x);
      boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
      boundingBox.y = bmMin(bounds.top, boundingBox.y);
      boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
    };
    HShapeElement.prototype.shapeBoundingBox = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    HShapeElement.prototype.tempBoundingBox = {
      x: 0,
      xMax: 0,
      y: 0,
      yMax: 0,
      width: 0,
      height: 0
    };
    HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
      var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
      for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
        // eslint-disable-line no-plusplus
        b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        c = 3 * p1[i] - 3 * p0[i];
        b |= 0; // eslint-disable-line no-bitwise

        a |= 0; // eslint-disable-line no-bitwise

        c |= 0; // eslint-disable-line no-bitwise

        if (a === 0 && b === 0) ;else if (a === 0) {
          t = -c / b;
          if (t > 0 && t < 1) {
            bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
          }
        } else {
          b2ac = b * b - 4 * c * a;
          if (b2ac >= 0) {
            t1 = (-b + bmSqrt(b2ac)) / (2 * a);
            if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
            t2 = (-b - bmSqrt(b2ac)) / (2 * a);
            if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
          }
        }
      }
      this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
      this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
      this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
      this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
    };
    HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
      return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
    };
    HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
      var i;
      var len = itemsData.length;
      for (i = 0; i < len; i += 1) {
        if (itemsData[i] && itemsData[i].sh) {
          this.calculateShapeBoundingBox(itemsData[i], boundingBox);
        } else if (itemsData[i] && itemsData[i].it) {
          this.calculateBoundingBox(itemsData[i].it, boundingBox);
        } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {
          this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);
        }
      }
    };
    HShapeElement.prototype.expandStrokeBoundingBox = function (widthProperty, boundingBox) {
      var width = 0;
      if (widthProperty.keyframes) {
        for (var i = 0; i < widthProperty.keyframes.length; i += 1) {
          var kfw = widthProperty.keyframes[i].s;
          if (kfw > width) {
            width = kfw;
          }
        }
        width *= widthProperty.mult;
      } else {
        width = widthProperty.v * widthProperty.mult;
      }
      boundingBox.x -= width;
      boundingBox.xMax += width;
      boundingBox.y -= width;
      boundingBox.yMax += width;
    };
    HShapeElement.prototype.currentBoxContains = function (box) {
      return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
    };
    HShapeElement.prototype.renderInnerContent = function () {
      this._renderShapeFrame();
      if (!this.hidden && (this._isFirstFrame || this._mdf)) {
        var tempBoundingBox = this.tempBoundingBox;
        var max = 999999;
        tempBoundingBox.x = max;
        tempBoundingBox.xMax = -max;
        tempBoundingBox.y = max;
        tempBoundingBox.yMax = -max;
        this.calculateBoundingBox(this.itemsData, tempBoundingBox);
        tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
        tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();

        if (this.currentBoxContains(tempBoundingBox)) {
          return;
        }
        var changed = false;
        if (this.currentBBox.w !== tempBoundingBox.width) {
          this.currentBBox.w = tempBoundingBox.width;
          this.shapeCont.setAttribute('width', tempBoundingBox.width);
          changed = true;
        }
        if (this.currentBBox.h !== tempBoundingBox.height) {
          this.currentBBox.h = tempBoundingBox.height;
          this.shapeCont.setAttribute('height', tempBoundingBox.height);
          changed = true;
        }
        if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
          this.currentBBox.w = tempBoundingBox.width;
          this.currentBBox.h = tempBoundingBox.height;
          this.currentBBox.x = tempBoundingBox.x;
          this.currentBBox.y = tempBoundingBox.y;
          this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
          var shapeStyle = this.shapeCont.style;
          var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
          shapeStyle.transform = shapeTransform;
          shapeStyle.webkitTransform = shapeTransform;
        }
      }
    };
    function HTextElement(data, globalData, comp) {
      this.textSpans = [];
      this.textPaths = [];
      this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      };
      this.renderType = 'svg';
      this.isMasked = false;
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
    HTextElement.prototype.createContent = function () {
      this.isMasked = this.checkMasks();
      if (this.isMasked) {
        this.renderType = 'svg';
        this.compW = this.comp.data.w;
        this.compH = this.comp.data.h;
        this.svgElement.setAttribute('width', this.compW);
        this.svgElement.setAttribute('height', this.compH);
        var g = createNS('g');
        this.maskedElement.appendChild(g);
        this.innerElem = g;
      } else {
        this.renderType = 'html';
        this.innerElem = this.layerElement;
      }
      this.checkParenting();
    };
    HTextElement.prototype.buildNewText = function () {
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
      var innerElemStyle = this.innerElem.style;
      var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
      innerElemStyle.fill = textColor;
      innerElemStyle.color = textColor;
      if (documentData.sc) {
        innerElemStyle.stroke = this.buildColor(documentData.sc);
        innerElemStyle.strokeWidth = documentData.sw + 'px';
      }
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      if (!this.globalData.fontManager.chars) {
        innerElemStyle.fontSize = documentData.finalSize + 'px';
        innerElemStyle.lineHeight = documentData.finalSize + 'px';
        if (fontData.fClass) {
          this.innerElem.className = fontData.fClass;
        } else {
          innerElemStyle.fontFamily = fontData.fFamily;
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          innerElemStyle.fontStyle = fStyle;
          innerElemStyle.fontWeight = fWeight;
        }
      }
      var i;
      var len;
      var letters = documentData.l;
      len = letters.length;
      var tSpan;
      var tParent;
      var tCont;
      var matrixHelper = this.mHelper;
      var shapes;
      var shapeStr = '';
      var cnt = 0;
      for (i = 0; i < len; i += 1) {
        if (this.globalData.fontManager.chars) {
          if (!this.textPaths[cnt]) {
            tSpan = createNS('path');
            tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
            tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
            tSpan.setAttribute('stroke-miterlimit', '4');
          } else {
            tSpan = this.textPaths[cnt];
          }
          if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tCont = tParent.children[0];
            } else {
              tParent = createTag('div');
              tParent.style.lineHeight = 0;
              tCont = createNS('svg');
              tCont.appendChild(tSpan);
              styleDiv(tParent);
            }
          }
        } else if (!this.isMasked) {
          if (this.textSpans[cnt]) {
            tParent = this.textSpans[cnt];
            tSpan = this.textPaths[cnt];
          } else {
            tParent = createTag('span');
            styleDiv(tParent);
            tSpan = createTag('span');
            styleDiv(tSpan);
            tParent.appendChild(tSpan);
          }
        } else {
          tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
        } // tSpan.setAttribute('visibility', 'hidden');

        if (this.globalData.fontManager.chars) {
          var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          var shapeData;
          if (charData) {
            shapeData = charData.data;
          } else {
            shapeData = null;
          }
          matrixHelper.reset();
          if (shapeData && shapeData.shapes && shapeData.shapes.length) {
            shapes = shapeData.shapes[0].it;
            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
            shapeStr = this.createPathShape(matrixHelper, shapes);
            tSpan.setAttribute('d', shapeStr);
          }
          if (!this.isMasked) {
            this.innerElem.appendChild(tParent);
            if (shapeData && shapeData.shapes) {
              // document.body.appendChild is needed to get exact measure of shape
              document.body.appendChild(tCont);
              var boundingBox = tCont.getBBox();
              tCont.setAttribute('width', boundingBox.width + 2);
              tCont.setAttribute('height', boundingBox.height + 2);
              tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
              var tContStyle = tCont.style;
              var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
              tContStyle.transform = tContTranslation;
              tContStyle.webkitTransform = tContTranslation;
              letters[i].yOffset = boundingBox.y - 1;
            } else {
              tCont.setAttribute('width', 1);
              tCont.setAttribute('height', 1);
            }
            tParent.appendChild(tCont);
          } else {
            this.innerElem.appendChild(tSpan);
          }
        } else {
          tSpan.textContent = letters[i].val;
          tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
          if (!this.isMasked) {
            this.innerElem.appendChild(tParent); //

            var tStyle = tSpan.style;
            var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
            tStyle.transform = tSpanTranslation;
            tStyle.webkitTransform = tSpanTranslation;
          } else {
            this.innerElem.appendChild(tSpan);
          }
        } //

        if (!this.isMasked) {
          this.textSpans[cnt] = tParent;
        } else {
          this.textSpans[cnt] = tSpan;
        }
        this.textSpans[cnt].style.display = 'block';
        this.textPaths[cnt] = tSpan;
        cnt += 1;
      }
      while (cnt < this.textSpans.length) {
        this.textSpans[cnt].style.display = 'none';
        cnt += 1;
      }
    };
    HTextElement.prototype.renderInnerContent = function () {
      this.validateText();
      var svgStyle;
      if (this.data.singleShape) {
        if (!this._isFirstFrame && !this.lettersChangedFlag) {
          return;
        }
        if (this.isMasked && this.finalTransform._matMdf) {
          // Todo Benchmark if using this is better than getBBox
          this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
          svgStyle = this.svgElement.style;
          var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
          svgStyle.transform = translation;
          svgStyle.webkitTransform = translation;
        }
      }
      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
        return;
      }
      var i;
      var len;
      var count = 0;
      var renderedLetters = this.textAnimator.renderedLetters;
      var letters = this.textProperty.currentData.l;
      len = letters.length;
      var renderedLetter;
      var textSpan;
      var textPath;
      for (i = 0; i < len; i += 1) {
        if (letters[i].n) {
          count += 1;
        } else {
          textSpan = this.textSpans[i];
          textPath = this.textPaths[i];
          renderedLetter = renderedLetters[count];
          count += 1;
          if (renderedLetter._mdf.m) {
            if (!this.isMasked) {
              textSpan.style.webkitTransform = renderedLetter.m;
              textSpan.style.transform = renderedLetter.m;
            } else {
              textSpan.setAttribute('transform', renderedLetter.m);
            }
          } /// /textSpan.setAttribute('opacity',renderedLetter.o);

          textSpan.style.opacity = renderedLetter.o;
          if (renderedLetter.sw && renderedLetter._mdf.sw) {
            textPath.setAttribute('stroke-width', renderedLetter.sw);
          }
          if (renderedLetter.sc && renderedLetter._mdf.sc) {
            textPath.setAttribute('stroke', renderedLetter.sc);
          }
          if (renderedLetter.fc && renderedLetter._mdf.fc) {
            textPath.setAttribute('fill', renderedLetter.fc);
            textPath.style.color = renderedLetter.fc;
          }
        }
      }
      if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
        var boundingBox = this.innerElem.getBBox();
        if (this.currentBBox.w !== boundingBox.width) {
          this.currentBBox.w = boundingBox.width;
          this.svgElement.setAttribute('width', boundingBox.width);
        }
        if (this.currentBBox.h !== boundingBox.height) {
          this.currentBBox.h = boundingBox.height;
          this.svgElement.setAttribute('height', boundingBox.height);
        }
        var margin = 1;
        if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
          this.currentBBox.w = boundingBox.width + margin * 2;
          this.currentBBox.h = boundingBox.height + margin * 2;
          this.currentBBox.x = boundingBox.x - margin;
          this.currentBBox.y = boundingBox.y - margin;
          this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
          svgStyle = this.svgElement.style;
          var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
          svgStyle.transform = svgTransform;
          svgStyle.webkitTransform = svgTransform;
        }
      }
    };
    function HCameraElement(data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initHierarchy();
      var getProp = PropertyFactory.getProp;
      this.pe = getProp(this, data.pe, 0, 0, this);
      if (data.ks.p.s) {
        this.px = getProp(this, data.ks.p.x, 1, 0, this);
        this.py = getProp(this, data.ks.p.y, 1, 0, this);
        this.pz = getProp(this, data.ks.p.z, 1, 0, this);
      } else {
        this.p = getProp(this, data.ks.p, 1, 0, this);
      }
      if (data.ks.a) {
        this.a = getProp(this, data.ks.a, 1, 0, this);
      }
      if (data.ks.or.k.length && data.ks.or.k[0].to) {
        var i;
        var len = data.ks.or.k.length;
        for (i = 0; i < len; i += 1) {
          data.ks.or.k[i].to = null;
          data.ks.or.k[i].ti = null;
        }
      }
      this.or = getProp(this, data.ks.or, 1, degToRads, this);
      this.or.sh = true;
      this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
      this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
      this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
      this.mat = new Matrix();
      this._prevMat = new Matrix();
      this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.

      this.finalTransform = {
        mProp: this
      };
    }
    extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
    HCameraElement.prototype.setup = function () {
      var i;
      var len = this.comp.threeDElements.length;
      var comp;
      var perspectiveStyle;
      var containerStyle;
      for (i = 0; i < len; i += 1) {
        // [perspectiveElem,container]
        comp = this.comp.threeDElements[i];
        if (comp.type === '3d') {
          perspectiveStyle = comp.perspectiveElem.style;
          containerStyle = comp.container.style;
          var perspective = this.pe.v + 'px';
          var origin = '0px 0px 0px';
          var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
          perspectiveStyle.perspective = perspective;
          perspectiveStyle.webkitPerspective = perspective;
          containerStyle.transformOrigin = origin;
          containerStyle.mozTransformOrigin = origin;
          containerStyle.webkitTransformOrigin = origin;
          perspectiveStyle.transform = matrix;
          perspectiveStyle.webkitTransform = matrix;
        }
      }
    };
    HCameraElement.prototype.createElements = function () {};
    HCameraElement.prototype.hide = function () {};
    HCameraElement.prototype.renderFrame = function () {
      var _mdf = this._isFirstFrame;
      var i;
      var len;
      if (this.hierarchy) {
        len = this.hierarchy.length;
        for (i = 0; i < len; i += 1) {
          _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
        }
      }
      if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
        this.mat.reset();
        if (this.hierarchy) {
          len = this.hierarchy.length - 1;
          for (i = len; i >= 0; i -= 1) {
            var mTransf = this.hierarchy[i].finalTransform.mProp;
            this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
            this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
            this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
            this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
            this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
          }
        }
        if (this.p) {
          this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
        } else {
          this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
        }
        if (this.a) {
          var diffVector;
          if (this.p) {
            diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
          } else {
            diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
          }
          var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));

          var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
          var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
          var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
          var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
          this.mat.rotateY(mRotationY).rotateX(-mRotationX);
        }
        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
        this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
        this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
        this.mat.translate(0, 0, this.pe.v);
        var hasMatrixChanged = !this._prevMat.equals(this.mat);
        if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
          len = this.comp.threeDElements.length;
          var comp;
          var perspectiveStyle;
          var containerStyle;
          for (i = 0; i < len; i += 1) {
            comp = this.comp.threeDElements[i];
            if (comp.type === '3d') {
              if (hasMatrixChanged) {
                var matValue = this.mat.toCSS();
                containerStyle = comp.container.style;
                containerStyle.transform = matValue;
                containerStyle.webkitTransform = matValue;
              }
              if (this.pe._mdf) {
                perspectiveStyle = comp.perspectiveElem.style;
                perspectiveStyle.perspective = this.pe.v + 'px';
                perspectiveStyle.webkitPerspective = this.pe.v + 'px';
              }
            }
          }
          this.mat.clone(this._prevMat);
        }
      }
      this._isFirstFrame = false;
    };
    HCameraElement.prototype.prepareFrame = function (num) {
      this.prepareProperties(num, true);
    };
    HCameraElement.prototype.destroy = function () {};
    HCameraElement.prototype.getBaseElement = function () {
      return null;
    };
    function HImageElement(data, globalData, comp) {
      this.assetData = globalData.getAssetData(data.refId);
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
    HImageElement.prototype.createContent = function () {
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      var img = new Image();
      if (this.data.hasMask) {
        this.imageElem = createNS('image');
        this.imageElem.setAttribute('width', this.assetData.w + 'px');
        this.imageElem.setAttribute('height', this.assetData.h + 'px');
        this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
        this.layerElement.appendChild(this.imageElem);
        this.baseElement.setAttribute('width', this.assetData.w);
        this.baseElement.setAttribute('height', this.assetData.h);
      } else {
        this.layerElement.appendChild(img);
      }
      img.crossOrigin = 'anonymous';
      img.src = assetPath;
      if (this.data.ln) {
        this.baseElement.setAttribute('id', this.data.ln);
      }
    };
    function HybridRendererBase(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.renderConfig = {
        className: config && config.className || '',
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
        hideOnTransparent: !(config && config.hideOnTransparent === false),
        filterSize: {
          width: config && config.filterSize && config.filterSize.width || '400%',
          height: config && config.filterSize && config.filterSize.height || '400%',
          x: config && config.filterSize && config.filterSize.x || '-100%',
          y: config && config.filterSize && config.filterSize.y || '-100%'
        }
      };
      this.globalData = {
        _mdf: false,
        frameNum: -1,
        renderConfig: this.renderConfig
      };
      this.pendingElements = [];
      this.elements = [];
      this.threeDElements = [];
      this.destroyed = false;
      this.camera = null;
      this.supports3d = true;
      this.rendererType = 'html';
    }
    extendPrototype([BaseRenderer], HybridRendererBase);
    HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
    HybridRendererBase.prototype.checkPendingElements = function () {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
      }
    };
    HybridRendererBase.prototype.appendElementInPos = function (element, pos) {
      var newDOMElement = element.getBaseElement();
      if (!newDOMElement) {
        return;
      }
      var layer = this.layers[pos];
      if (!layer.ddd || !this.supports3d) {
        if (this.threeDElements) {
          this.addTo3dContainer(newDOMElement, pos);
        } else {
          var i = 0;
          var nextDOMElement;
          var nextLayer;
          var tmpDOMElement;
          while (i < pos) {
            if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
              nextLayer = this.elements[i];
              tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
              nextDOMElement = tmpDOMElement || nextDOMElement;
            }
            i += 1;
          }
          if (nextDOMElement) {
            if (!layer.ddd || !this.supports3d) {
              this.layerElement.insertBefore(newDOMElement, nextDOMElement);
            }
          } else if (!layer.ddd || !this.supports3d) {
            this.layerElement.appendChild(newDOMElement);
          }
        }
      } else {
        this.addTo3dContainer(newDOMElement, pos);
      }
    };
    HybridRendererBase.prototype.createShape = function (data) {
      if (!this.supports3d) {
        return new SVGShapeElement(data, this.globalData, this);
      }
      return new HShapeElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createText = function (data) {
      if (!this.supports3d) {
        return new SVGTextLottieElement(data, this.globalData, this);
      }
      return new HTextElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createCamera = function (data) {
      this.camera = new HCameraElement(data, this.globalData, this);
      return this.camera;
    };
    HybridRendererBase.prototype.createImage = function (data) {
      if (!this.supports3d) {
        return new IImageElement(data, this.globalData, this);
      }
      return new HImageElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createSolid = function (data) {
      if (!this.supports3d) {
        return new ISolidElement(data, this.globalData, this);
      }
      return new HSolidElement(data, this.globalData, this);
    };
    HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
    HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {
      var i = 0;
      var len = this.threeDElements.length;
      while (i < len) {
        if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
          return this.threeDElements[i].perspectiveElem;
        }
        i += 1;
      }
      return null;
    };
    HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {
      var perspectiveElem = createTag('div');
      var style;
      var containerStyle;
      styleDiv(perspectiveElem);
      var container = createTag('div');
      styleDiv(container);
      if (type === '3d') {
        style = perspectiveElem.style;
        style.width = this.globalData.compSize.w + 'px';
        style.height = this.globalData.compSize.h + 'px';
        var center = '50% 50%';
        style.webkitTransformOrigin = center;
        style.mozTransformOrigin = center;
        style.transformOrigin = center;
        containerStyle = container.style;
        var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
        containerStyle.transform = matrix;
        containerStyle.webkitTransform = matrix;
      }
      perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);

      var threeDContainerData = {
        container: container,
        perspectiveElem: perspectiveElem,
        startPos: pos,
        endPos: pos,
        type: type
      };
      this.threeDElements.push(threeDContainerData);
      return threeDContainerData;
    };
    HybridRendererBase.prototype.build3dContainers = function () {
      var i;
      var len = this.layers.length;
      var lastThreeDContainerData;
      var currentContainer = '';
      for (i = 0; i < len; i += 1) {
        if (this.layers[i].ddd && this.layers[i].ty !== 3) {
          if (currentContainer !== '3d') {
            currentContainer = '3d';
            lastThreeDContainerData = this.createThreeDContainer(i, '3d');
          }
          lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        } else {
          if (currentContainer !== '2d') {
            currentContainer = '2d';
            lastThreeDContainerData = this.createThreeDContainer(i, '2d');
          }
          lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        }
      }
      len = this.threeDElements.length;
      for (i = len - 1; i >= 0; i -= 1) {
        this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
      }
    };
    HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {
      var i = 0;
      var len = this.threeDElements.length;
      while (i < len) {
        if (pos <= this.threeDElements[i].endPos) {
          var j = this.threeDElements[i].startPos;
          var nextElement;
          while (j < pos) {
            if (this.elements[j] && this.elements[j].getBaseElement) {
              nextElement = this.elements[j].getBaseElement();
            }
            j += 1;
          }
          if (nextElement) {
            this.threeDElements[i].container.insertBefore(elem, nextElement);
          } else {
            this.threeDElements[i].container.appendChild(elem);
          }
          break;
        }
        i += 1;
      }
    };
    HybridRendererBase.prototype.configAnimation = function (animData) {
      var resizerElem = createTag('div');
      var wrapper = this.animationItem.wrapper;
      var style = resizerElem.style;
      style.width = animData.w + 'px';
      style.height = animData.h + 'px';
      this.resizerElem = resizerElem;
      styleDiv(resizerElem);
      style.transformStyle = 'flat';
      style.mozTransformStyle = 'flat';
      style.webkitTransformStyle = 'flat';
      if (this.renderConfig.className) {
        resizerElem.setAttribute('class', this.renderConfig.className);
      }
      wrapper.appendChild(resizerElem);
      style.overflow = 'hidden';
      var svg = createNS('svg');
      svg.setAttribute('width', '1');
      svg.setAttribute('height', '1');
      styleDiv(svg);
      this.resizerElem.appendChild(svg);
      var defs = createNS('defs');
      svg.appendChild(defs);
      this.data = animData; // Mask animation

      this.setupGlobalData(animData, svg);
      this.globalData.defs = defs;
      this.layers = animData.layers;
      this.layerElement = this.resizerElem;
      this.build3dContainers();
      this.updateContainerSize();
    };
    HybridRendererBase.prototype.destroy = function () {
      if (this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = '';
      }
      this.animationItem.container = null;
      this.globalData.defs = null;
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i] && this.elements[i].destroy) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.destroyed = true;
      this.animationItem = null;
    };
    HybridRendererBase.prototype.updateContainerSize = function () {
      var elementWidth = this.animationItem.wrapper.offsetWidth;
      var elementHeight = this.animationItem.wrapper.offsetHeight;
      var elementRel = elementWidth / elementHeight;
      var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
      var sx;
      var sy;
      var tx;
      var ty;
      if (animationRel > elementRel) {
        sx = elementWidth / this.globalData.compSize.w;
        sy = elementWidth / this.globalData.compSize.w;
        tx = 0;
        ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
      } else {
        sx = elementHeight / this.globalData.compSize.h;
        sy = elementHeight / this.globalData.compSize.h;
        tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
        ty = 0;
      }
      var style = this.resizerElem.style;
      style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
      style.transform = style.webkitTransform;
    };
    HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
    HybridRendererBase.prototype.hide = function () {
      this.resizerElem.style.display = 'none';
    };
    HybridRendererBase.prototype.show = function () {
      this.resizerElem.style.display = 'block';
    };
    HybridRendererBase.prototype.initItems = function () {
      this.buildAllItems();
      if (this.camera) {
        this.camera.setup();
      } else {
        var cWidth = this.globalData.compSize.w;
        var cHeight = this.globalData.compSize.h;
        var i;
        var len = this.threeDElements.length;
        for (i = 0; i < len; i += 1) {
          var style = this.threeDElements[i].perspectiveElem.style;
          style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
          style.perspective = style.webkitPerspective;
        }
      }
    };
    HybridRendererBase.prototype.searchExtraCompositions = function (assets) {
      var i;
      var len = assets.length;
      var floatingContainer = createTag('div');
      for (i = 0; i < len; i += 1) {
        if (assets[i].xt) {
          var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
          comp.initExpressions();
          this.globalData.projectInterface.registerComposition(comp);
        }
      }
    };
    function HCompElement(data, globalData, comp) {
      this.layers = data.layers;
      this.supports3d = !data.hasMask;
      this.completeLayers = false;
      this.pendingElements = [];
      this.elements = this.layers ? createSizedArray(this.layers.length) : [];
      this.initElement(data, globalData, comp);
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
        _placeholder: true
      };
    }
    extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
    HCompElement.prototype.createContainerElements = function () {
      this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';

      if (this.data.hasMask) {
        this.svgElement.setAttribute('width', this.data.w);
        this.svgElement.setAttribute('height', this.data.h);
        this.transformedElement = this.baseElement;
      } else {
        this.transformedElement = this.layerElement;
      }
    };
    HCompElement.prototype.addTo3dContainer = function (elem, pos) {
      var j = 0;
      var nextElement;
      while (j < pos) {
        if (this.elements[j] && this.elements[j].getBaseElement) {
          nextElement = this.elements[j].getBaseElement();
        }
        j += 1;
      }
      if (nextElement) {
        this.layerElement.insertBefore(elem, nextElement);
      } else {
        this.layerElement.appendChild(elem);
      }
    };
    HCompElement.prototype.createComp = function (data) {
      if (!this.supports3d) {
        return new SVGCompElement(data, this.globalData, this);
      }
      return new HCompElement(data, this.globalData, this);
    };
    function HybridRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.renderConfig = {
        className: config && config.className || '',
        imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
        hideOnTransparent: !(config && config.hideOnTransparent === false),
        filterSize: {
          width: config && config.filterSize && config.filterSize.width || '400%',
          height: config && config.filterSize && config.filterSize.height || '400%',
          x: config && config.filterSize && config.filterSize.x || '-100%',
          y: config && config.filterSize && config.filterSize.y || '-100%'
        },
        runExpressions: !config || config.runExpressions === undefined || config.runExpressions
      };
      this.globalData = {
        _mdf: false,
        frameNum: -1,
        renderConfig: this.renderConfig
      };
      this.pendingElements = [];
      this.elements = [];
      this.threeDElements = [];
      this.destroyed = false;
      this.camera = null;
      this.supports3d = true;
      this.rendererType = 'html';
    }
    extendPrototype([HybridRendererBase], HybridRenderer);
    HybridRenderer.prototype.createComp = function (data) {
      if (!this.supports3d) {
        return new SVGCompElement(data, this.globalData, this);
      }
      return new HCompElement(data, this.globalData, this);
    };
    var CompExpressionInterface = function () {
      return function (comp) {
        function _thisLayerFunction(name) {
          var i = 0;
          var len = comp.layers.length;
          while (i < len) {
            if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
              return comp.elements[i].layerInterface;
            }
            i += 1;
          }
          return null; // return {active:false};
        }
        Object.defineProperty(_thisLayerFunction, '_name', {
          value: comp.data.nm
        });
        _thisLayerFunction.layer = _thisLayerFunction;
        _thisLayerFunction.pixelAspect = 1;
        _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
        _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
        _thisLayerFunction.pixelAspect = 1;
        _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
        _thisLayerFunction.displayStartTime = 0;
        _thisLayerFunction.numLayers = comp.layers.length;
        return _thisLayerFunction;
      };
    }();
    function _typeof$2(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$2 = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof$2 = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof$2(obj);
    }

    /* eslint-disable */

    /*
     Copyright 2014 David Bau.
       Permission is hereby granted, free of charge, to any person obtaining
     a copy of this software and associated documentation files (the
     "Software"), to deal in the Software without restriction, including
     without limitation the rights to use, copy, modify, merge, publish,
     distribute, sublicense, and/or sell copies of the Software, and to
     permit persons to whom the Software is furnished to do so, subject to
     the following conditions:
       The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
       */
    function seedRandom(pool, math) {
      //
      // The following constants are related to IEEE 754 limits.
      //
      var global = this,
        width = 256,
        // each RC4 output is 0 <= x < 256
        chunks = 6,
        // at least six RC4 outputs for each double
        digits = 52,
        // there are 52 significant digits in a double
        rngname = 'random',
        // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1;
      // node.js crypto module, initialized at the bottom.
      //
      // seedrandom()
      // This is the seedrandom function described above.
      //

      function seedrandom(seed, options, callback) {
        var key = [];
        options = options === true ? {
          entropy: true
        } : options || {}; // Flatten the seed string or build one from local entropy if needed.

        var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.

        var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains
        // randomness in every bit of the mantissa of the IEEE 754 value.

        var prng = function prng() {
          var n = arc4.g(chunks),
            // Start with a numerator n < 2 ^ 48
            d = startdenom,
            //   and denominator d = 2 ^ 48.
            x = 0; //   and no 'extra last byte'.

          while (n < significance) {
            // Fill up all significant digits by
            n = (n + x) * width; //   shifting numerator and

            d *= width; //   denominator and generating a

            x = arc4.g(1); //   new least-significant-byte.
          }
          while (n >= overflow) {
            // To avoid rounding up, before adding
            n /= 2; //   last byte, shift everything

            d /= 2; //   right using integer math until

            x >>>= 1; //   we have exactly the desired bits.
          }
          return (n + x) / d; // Form the number within [0, 1).
        };
        prng.int32 = function () {
          return arc4.g(4) | 0;
        };
        prng.quick = function () {
          return arc4.g(4) / 0x100000000;
        };
        prng["double"] = prng; // Mix the randomness into accumulated entropy.

        mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.

        return (options.pass || callback || function (prng, seed, is_math_call, state) {
          if (state) {
            // Load the arc4 state from the given state if it has an S array.
            if (state.S) {
              copy(state, arc4);
            } // Only provide the .state method if requested via options.state.

            prng.state = function () {
              return copy(arc4, {});
            };
          } // If called as a method of Math (Math.seedrandom()), mutate
          // Math.random because that is how seedrandom.js has worked since v1.0.

          if (is_math_call) {
            math[rngname] = prng;
            return seed;
          } // Otherwise, it is a newer calling convention, so return the
          // prng directly.
          else return prng;
        })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);
      }
      math['seed' + rngname] = seedrandom; //
      // ARC4
      //
      // An ARC4 implementation.  The constructor takes a key in the form of
      // an array of at most (width) integers that should be 0 <= x < (width).
      //
      // The g(count) method returns a pseudorandom integer that concatenates
      // the next (count) outputs from ARC4.  Its return value is a number x
      // that is in the range 0 <= x < (width ^ count).
      //

      function ARC4(key) {
        var t,
          keylen = key.length,
          me = this,
          i = 0,
          j = me.i = me.j = 0,
          s = me.S = []; // The empty key [] is treated as [0].

        if (!keylen) {
          key = [keylen++];
        } // Set up S using the standard key scheduling algorithm.

        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        } // The "g" method returns the next (count) outputs as one number.

        me.g = function (count) {
          // Using instance members instead of closure state nearly doubles speed.
          var t,
            r = 0,
            i = me.i,
            j = me.j,
            s = me.S;
          while (count--) {
            t = s[i = mask & i + 1];
            r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
          }
          me.i = i;
          me.j = j;
          return r; // For robust unpredictability, the function call below automatically
          // discards an initial batch of values.  This is called RC4-drop[256].
          // See http://google.com/search?q=rsa+fluhrer+response&btnI
        };
      } //
      // copy()
      // Copies internal state of ARC4 to or from a plain object.
      //

      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      } //
      // flatten()
      // Converts an object tree to nested arrays of strings.
      //

      function flatten(obj, depth) {
        var result = [],
          typ = _typeof$2(obj),
          prop;
        if (depth && typ == 'object') {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e) {}
          }
        }
        return result.length ? result : typ == 'string' ? obj : obj + '\0';
      } //
      // mixkey()
      // Mixes a string seed into a key that is an array of integers, and
      // returns a shortened string seed that is equivalent to the result key.
      //

      function mixkey(seed, key) {
        var stringseed = seed + '',
          smear,
          j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      } //
      // autoseed()
      // Returns an object for autoseeding, using window.crypto and Node crypto
      // module if available.
      //

      function autoseed() {
        try {
          var out = new Uint8Array(width);
          (global.crypto || global.msCrypto).getRandomValues(out);
          return tostring(out);
        } catch (e) {
          var browser = global.navigator,
            plugins = browser && browser.plugins;
          return [+new Date(), global, plugins, global.screen, tostring(pool)];
        }
      } //
      // tostring()
      // Converts an array of charcodes to a string
      //

      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      } //
      // When seedrandom.js is loaded, we immediately mix a few bits
      // from the built-in RNG into the entropy pool.  Because we do
      // not want to interfere with deterministic PRNG state later,
      // seedrandom will not call math.random on its own again after
      // initialization.
      //

      mixkey(math.random(), pool); //
      // Nodejs and AMD support: export the implementation as a module using
      // either convention.
      //
      // End anonymous scope, and pass initial values.
    }
    function initialize$2(BMMath) {
      seedRandom([], BMMath);
    }
    var propTypes = {
      SHAPE: 'shape'
    };
    function _typeof$1(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$1 = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof$1 = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof$1(obj);
    }
    var ExpressionManager = function () {
      var ob = {};
      var Math = BMMath;
      var window = null;
      var document = null;
      var XMLHttpRequest = null;
      var fetch = null;
      var frames = null;
      var _lottieGlobal = {};
      initialize$2(BMMath);
      function resetFrame() {
        _lottieGlobal = {};
      }
      function $bm_isInstanceOfArray(arr) {
        return arr.constructor === Array || arr.constructor === Float32Array;
      }
      function isNumerable(tOfV, v) {
        return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';
      }
      function $bm_neg(a) {
        var tOfA = _typeof$1(a);
        if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {
          return -a;
        }
        if ($bm_isInstanceOfArray(a)) {
          var i;
          var lenA = a.length;
          var retArr = [];
          for (i = 0; i < lenA; i += 1) {
            retArr[i] = -a[i];
          }
          return retArr;
        }
        if (a.propType) {
          return a.v;
        }
        return -a;
      }
      var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
      var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
      var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;
      function sum(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === 'string' || tOfB === 'string') {
          return a + b;
        }
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          a = a.slice(0);
          a[0] += b;
          return a;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          b = b.slice(0);
          b[0] = a + b[0];
          return b;
        }
        if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
          var i = 0;
          var lenA = a.length;
          var lenB = b.length;
          var retArr = [];
          while (i < lenA || i < lenB) {
            if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
              retArr[i] = a[i] + b[i];
            } else {
              retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
            }
            i += 1;
          }
          return retArr;
        }
        return 0;
      }
      var add = sum;
      function sub(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
          if (tOfA === 'string') {
            a = parseInt(a, 10);
          }
          if (tOfB === 'string') {
            b = parseInt(b, 10);
          }
          return a - b;
        }
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          a = a.slice(0);
          a[0] -= b;
          return a;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          b = b.slice(0);
          b[0] = a - b[0];
          return b;
        }
        if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
          var i = 0;
          var lenA = a.length;
          var lenB = b.length;
          var retArr = [];
          while (i < lenA || i < lenB) {
            if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
              retArr[i] = a[i] - b[i];
            } else {
              retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
            }
            i += 1;
          }
          return retArr;
        }
        return 0;
      }
      function mul(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        var arr;
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
          return a * b;
        }
        var i;
        var len;
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          len = a.length;
          arr = createTypedArray('float32', len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a[i] * b;
          }
          return arr;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          len = b.length;
          arr = createTypedArray('float32', len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a * b[i];
          }
          return arr;
        }
        return 0;
      }
      function div(a, b) {
        var tOfA = _typeof$1(a);
        var tOfB = _typeof$1(b);
        var arr;
        if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
          return a / b;
        }
        var i;
        var len;
        if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
          len = a.length;
          arr = createTypedArray('float32', len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a[i] / b;
          }
          return arr;
        }
        if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
          len = b.length;
          arr = createTypedArray('float32', len);
          for (i = 0; i < len; i += 1) {
            arr[i] = a / b[i];
          }
          return arr;
        }
        return 0;
      }
      function mod(a, b) {
        if (typeof a === 'string') {
          a = parseInt(a, 10);
        }
        if (typeof b === 'string') {
          b = parseInt(b, 10);
        }
        return a % b;
      }
      var $bm_sum = sum;
      var $bm_sub = sub;
      var $bm_mul = mul;
      var $bm_div = div;
      var $bm_mod = mod;
      function clamp(num, min, max) {
        if (min > max) {
          var mm = max;
          max = min;
          min = mm;
        }
        return Math.min(Math.max(num, min), max);
      }
      function radiansToDegrees(val) {
        return val / degToRads;
      }
      var radians_to_degrees = radiansToDegrees;
      function degreesToRadians(val) {
        return val * degToRads;
      }
      var degrees_to_radians = radiansToDegrees;
      var helperLengthArray = [0, 0, 0, 0, 0, 0];
      function length(arr1, arr2) {
        if (typeof arr1 === 'number' || arr1 instanceof Number) {
          arr2 = arr2 || 0;
          return Math.abs(arr1 - arr2);
        }
        if (!arr2) {
          arr2 = helperLengthArray;
        }
        var i;
        var len = Math.min(arr1.length, arr2.length);
        var addedLength = 0;
        for (i = 0; i < len; i += 1) {
          addedLength += Math.pow(arr2[i] - arr1[i], 2);
        }
        return Math.sqrt(addedLength);
      }
      function normalize(vec) {
        return div(vec, length(vec));
      }
      function rgbToHsl(val) {
        var r = val[0];
        var g = val[1];
        var b = val[2];
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var h;
        var s;
        var l = (max + min) / 2;
        if (max === min) {
          h = 0; // achromatic

          s = 0; // achromatic
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return [h, s, l, val[3]];
      }
      function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }
      function hslToRgb(val) {
        var h = val[0];
        var s = val[1];
        var l = val[2];
        var r;
        var g;
        var b;
        if (s === 0) {
          r = l; // achromatic

          b = l; // achromatic

          g = l; // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r, g, b, val[3]];
      }
      function linear(t, tMin, tMax, value1, value2) {
        if (value1 === undefined || value2 === undefined) {
          value1 = tMin;
          value2 = tMax;
          tMin = 0;
          tMax = 1;
        }
        if (tMax < tMin) {
          var _tMin = tMax;
          tMax = tMin;
          tMin = _tMin;
        }
        if (t <= tMin) {
          return value1;
        }
        if (t >= tMax) {
          return value2;
        }
        var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);
        if (!value1.length) {
          return value1 + (value2 - value1) * perc;
        }
        var i;
        var len = value1.length;
        var arr = createTypedArray('float32', len);
        for (i = 0; i < len; i += 1) {
          arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
        }
        return arr;
      }
      function random(min, max) {
        if (max === undefined) {
          if (min === undefined) {
            min = 0;
            max = 1;
          } else {
            max = min;
            min = undefined;
          }
        }
        if (max.length) {
          var i;
          var len = max.length;
          if (!min) {
            min = createTypedArray('float32', len);
          }
          var arr = createTypedArray('float32', len);
          var rnd = BMMath.random();
          for (i = 0; i < len; i += 1) {
            arr[i] = min[i] + rnd * (max[i] - min[i]);
          }
          return arr;
        }
        if (min === undefined) {
          min = 0;
        }
        var rndm = BMMath.random();
        return min + rndm * (max - min);
      }
      function createPath(points, inTangents, outTangents, closed) {
        var i;
        var len = points.length;
        var path = shapePool.newElement();
        path.setPathData(!!closed, len);
        var arrPlaceholder = [0, 0];
        var inVertexPoint;
        var outVertexPoint;
        for (i = 0; i < len; i += 1) {
          inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
          outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
          path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
        }
        return path;
      }
      function initiateExpression(elem, data, property) {
        // Bail out if we don't want expressions
        function noOp(_value) {
          return _value;
        }
        if (!elem.globalData.renderConfig.runExpressions) {
          return noOp;
        }
        var val = data.x;
        var needsVelocity = /velocity(?![\w\d])/.test(val);
        var _needsRandom = val.indexOf('random') !== -1;
        var elemType = elem.data.ty;
        var transform;
        var $bm_transform;
        var content;
        var effect;
        var thisProperty = property;
        thisProperty.valueAtTime = thisProperty.getValueAtTime;
        Object.defineProperty(thisProperty, 'value', {
          get: function get() {
            return thisProperty.v;
          }
        });
        elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
        elem.comp.displayStartTime = 0;
        var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
        var outPoint = elem.data.op / elem.comp.globalData.frameRate;
        var width = elem.data.sw ? elem.data.sw : 0;
        var height = elem.data.sh ? elem.data.sh : 0;
        var name = elem.data.nm;
        var loopIn;
        var loop_in;
        var loopOut;
        var loop_out;
        var smooth;
        var toWorld;
        var fromWorld;
        var fromComp;
        var toComp;
        var fromCompToSurface;
        var position;
        var rotation;
        var anchorPoint;
        var scale;
        var thisLayer;
        var thisComp;
        var mask;
        var valueAtTime;
        var velocityAtTime;
        var scoped_bm_rt; // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls

        var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval

        var numKeys = property.kf ? data.k.length : 0;
        var active = !this.data || this.data.hd !== true;
        var wiggle = function wiggle(freq, amp) {
          var iWiggle;
          var j;
          var lenWiggle = this.pv.length ? this.pv.length : 1;
          var addedAmps = createTypedArray('float32', lenWiggle);
          freq = 5;
          var iterations = Math.floor(time * freq);
          iWiggle = 0;
          j = 0;
          while (iWiggle < iterations) {
            // var rnd = BMMath.random();
            for (j = 0; j < lenWiggle; j += 1) {
              addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;
            }
            iWiggle += 1;
          } // var rnd2 = BMMath.random();

          var periods = time * freq;
          var perc = periods - Math.floor(periods);
          var arr = createTypedArray('float32', lenWiggle);
          if (lenWiggle > 1) {
            for (j = 0; j < lenWiggle; j += 1) {
              arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
              // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
            }
            return arr;
          }
          return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
        }.bind(this);
        if (thisProperty.loopIn) {
          loopIn = thisProperty.loopIn.bind(thisProperty);
          loop_in = loopIn;
        }
        if (thisProperty.loopOut) {
          loopOut = thisProperty.loopOut.bind(thisProperty);
          loop_out = loopOut;
        }
        if (thisProperty.smooth) {
          smooth = thisProperty.smooth.bind(thisProperty);
        }
        function loopInDuration(type, duration) {
          return loopIn(type, duration, true);
        }
        function loopOutDuration(type, duration) {
          return loopOut(type, duration, true);
        }
        if (this.getValueAtTime) {
          valueAtTime = this.getValueAtTime.bind(this);
        }
        if (this.getVelocityAtTime) {
          velocityAtTime = this.getVelocityAtTime.bind(this);
        }
        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
        function lookAt(elem1, elem2) {
          var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
          var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
          var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
          return [yaw, pitch, 0];
        }
        function easeOut(t, tMin, tMax, val1, val2) {
          return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
        }
        function easeIn(t, tMin, tMax, val1, val2) {
          return applyEase(easeInBez, t, tMin, tMax, val1, val2);
        }
        function ease(t, tMin, tMax, val1, val2) {
          return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
        }
        function applyEase(fn, t, tMin, tMax, val1, val2) {
          if (val1 === undefined) {
            val1 = tMin;
            val2 = tMax;
          } else {
            t = (t - tMin) / (tMax - tMin);
          }
          if (t > 1) {
            t = 1;
          } else if (t < 0) {
            t = 0;
          }
          var mult = fn(t);
          if ($bm_isInstanceOfArray(val1)) {
            var iKey;
            var lenKey = val1.length;
            var arr = createTypedArray('float32', lenKey);
            for (iKey = 0; iKey < lenKey; iKey += 1) {
              arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
            }
            return arr;
          }
          return (val2 - val1) * mult + val1;
        }
        function nearestKey(time) {
          var iKey;
          var lenKey = data.k.length;
          var index;
          var keyTime;
          if (!data.k.length || typeof data.k[0] === 'number') {
            index = 0;
            keyTime = 0;
          } else {
            index = -1;
            time *= elem.comp.globalData.frameRate;
            if (time < data.k[0].t) {
              index = 1;
              keyTime = data.k[0].t;
            } else {
              for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                if (time === data.k[iKey].t) {
                  index = iKey + 1;
                  keyTime = data.k[iKey].t;
                  break;
                } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
                  if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                    index = iKey + 2;
                    keyTime = data.k[iKey + 1].t;
                  } else {
                    index = iKey + 1;
                    keyTime = data.k[iKey].t;
                  }
                  break;
                }
              }
              if (index === -1) {
                index = iKey + 1;
                keyTime = data.k[iKey].t;
              }
            }
          }
          var obKey = {};
          obKey.index = index;
          obKey.time = keyTime / elem.comp.globalData.frameRate;
          return obKey;
        }
        function key(ind) {
          var obKey;
          var iKey;
          var lenKey;
          if (!data.k.length || typeof data.k[0] === 'number') {
            throw new Error('The property has no keyframe at index ' + ind);
          }
          ind -= 1;
          obKey = {
            time: data.k[ind].t / elem.comp.globalData.frameRate,
            value: []
          };
          var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;
          lenKey = arr.length;
          for (iKey = 0; iKey < lenKey; iKey += 1) {
            obKey[iKey] = arr[iKey];
            obKey.value[iKey] = arr[iKey];
          }
          return obKey;
        }
        function framesToTime(fr, fps) {
          if (!fps) {
            fps = elem.comp.globalData.frameRate;
          }
          return fr / fps;
        }
        function timeToFrames(t, fps) {
          if (!t && t !== 0) {
            t = time;
          }
          if (!fps) {
            fps = elem.comp.globalData.frameRate;
          }
          return t * fps;
        }
        function seedRandom(seed) {
          BMMath.seedrandom(randSeed + seed);
        }
        function sourceRectAtTime() {
          return elem.sourceRectAtTime();
        }
        function substring(init, end) {
          if (typeof value === 'string') {
            if (end === undefined) {
              return value.substring(init);
            }
            return value.substring(init, end);
          }
          return '';
        }
        function substr(init, end) {
          if (typeof value === 'string') {
            if (end === undefined) {
              return value.substr(init);
            }
            return value.substr(init, end);
          }
          return '';
        }
        function posterizeTime(framesPerSecond) {
          time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
          value = valueAtTime(time);
        }
        var time;
        var velocity;
        var value;
        var text;
        var textIndex;
        var textTotal;
        var selectorValue;
        var index = elem.data.ind;
        var randSeed = Math.floor(Math.random() * 1000000);
        var globalData = elem.globalData;
        function executeExpression(_value) {
          // globalData.pushExpression();
          value = _value;
          if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
            return value;
          }
          if (this.propType === 'textSelector') {
            textIndex = this.textIndex;
            textTotal = this.textTotal;
            selectorValue = this.selectorValue;
          }
          if (!thisLayer) {
            text = elem.layerInterface.text;
            thisLayer = elem.layerInterface;
            thisComp = elem.comp.compInterface;
            toWorld = thisLayer.toWorld.bind(thisLayer);
            fromWorld = thisLayer.fromWorld.bind(thisLayer);
            fromComp = thisLayer.fromComp.bind(thisLayer);
            toComp = thisLayer.toComp.bind(thisLayer);
            mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
            fromCompToSurface = fromComp;
          }
          if (!transform) {
            transform = elem.layerInterface('ADBE Transform Group');
            $bm_transform = transform;
            if (transform) {
              anchorPoint = transform.anchorPoint;
              /* position = transform.position;
                        rotation = transform.rotation;
                        scale = transform.scale; */
            }
          }
          if (elemType === 4 && !content) {
            content = thisLayer('ADBE Root Vectors Group');
          }
          if (!effect) {
            effect = thisLayer(4);
          }
          time = this.comp.renderedFrame / this.comp.globalData.frameRate;
          if (_needsRandom) {
            seedRandom(randSeed + time);
          }
          if (needsVelocity) {
            velocity = velocityAtTime(time);
          }
          expression_function();
          this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value
          // Changed this to a ternary operation because Rollup failed compiling it correctly

          scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
          return scoped_bm_rt;
        } // Bundlers will see these as dead code and unless we reference them

        executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
        return executeExpression;
      }
      ob.initiateExpression = initiateExpression;
      ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
      ob.resetFrame = resetFrame;
      return ob;
    }();
    var Expressions = function () {
      var ob = {};
      ob.initExpressions = initExpressions;
      ob.resetFrame = ExpressionManager.resetFrame;
      function initExpressions(animation) {
        var stackCount = 0;
        var registers = [];
        function pushExpression() {
          stackCount += 1;
        }
        function popExpression() {
          stackCount -= 1;
          if (stackCount === 0) {
            releaseInstances();
          }
        }
        function registerExpressionProperty(expression) {
          if (registers.indexOf(expression) === -1) {
            registers.push(expression);
          }
        }
        function releaseInstances() {
          var i;
          var len = registers.length;
          for (i = 0; i < len; i += 1) {
            registers[i].release();
          }
          registers.length = 0;
        }
        animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
        animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
        animation.renderer.globalData.pushExpression = pushExpression;
        animation.renderer.globalData.popExpression = popExpression;
        animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
      }
      return ob;
    }();
    var MaskManagerInterface = function () {
      function MaskInterface(mask, data) {
        this._mask = mask;
        this._data = data;
      }
      Object.defineProperty(MaskInterface.prototype, 'maskPath', {
        get: function get() {
          if (this._mask.prop.k) {
            this._mask.prop.getValue();
          }
          return this._mask.prop;
        }
      });
      Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
        get: function get() {
          if (this._mask.op.k) {
            this._mask.op.getValue();
          }
          return this._mask.op.v * 100;
        }
      });
      var MaskManager = function MaskManager(maskManager) {
        var _masksInterfaces = createSizedArray(maskManager.viewData.length);
        var i;
        var len = maskManager.viewData.length;
        for (i = 0; i < len; i += 1) {
          _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
        }
        var maskFunction = function maskFunction(name) {
          i = 0;
          while (i < len) {
            if (maskManager.masksProperties[i].nm === name) {
              return _masksInterfaces[i];
            }
            i += 1;
          }
          return null;
        };
        return maskFunction;
      };
      return MaskManager;
    }();
    var ExpressionPropertyInterface = function () {
      var defaultUnidimensionalValue = {
        pv: 0,
        v: 0,
        mult: 1
      };
      var defaultMultidimensionalValue = {
        pv: [0, 0, 0],
        v: [0, 0, 0],
        mult: 1
      };
      function completeProperty(expressionValue, property, type) {
        Object.defineProperty(expressionValue, 'velocity', {
          get: function get() {
            return property.getVelocityAtTime(property.comp.currentFrame);
          }
        });
        expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
        expressionValue.key = function (pos) {
          if (!expressionValue.numKeys) {
            return 0;
          }
          var value = '';
          if ('s' in property.keyframes[pos - 1]) {
            value = property.keyframes[pos - 1].s;
          } else if ('e' in property.keyframes[pos - 2]) {
            value = property.keyframes[pos - 2].e;
          } else {
            value = property.keyframes[pos - 2].s;
          }
          var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers

          valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
          valueProp.value = type === 'unidimensional' ? value[0] : value;
          return valueProp;
        };
        expressionValue.valueAtTime = property.getValueAtTime;
        expressionValue.speedAtTime = property.getSpeedAtTime;
        expressionValue.velocityAtTime = property.getVelocityAtTime;
        expressionValue.propertyGroup = property.propertyGroup;
      }
      function UnidimensionalPropertyInterface(property) {
        if (!property || !('pv' in property)) {
          property = defaultUnidimensionalValue;
        }
        var mult = 1 / property.mult;
        var val = property.pv * mult;
        var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

        expressionValue.value = val;
        completeProperty(expressionValue, property, 'unidimensional');
        return function () {
          if (property.k) {
            property.getValue();
          }
          val = property.v * mult;
          if (expressionValue.value !== val) {
            expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

            expressionValue.value = val;
            completeProperty(expressionValue, property, 'unidimensional');
          }
          return expressionValue;
        };
      }
      function MultidimensionalPropertyInterface(property) {
        if (!property || !('pv' in property)) {
          property = defaultMultidimensionalValue;
        }
        var mult = 1 / property.mult;
        var len = property.data && property.data.l || property.pv.length;
        var expressionValue = createTypedArray('float32', len);
        var arrValue = createTypedArray('float32', len);
        expressionValue.value = arrValue;
        completeProperty(expressionValue, property, 'multidimensional');
        return function () {
          if (property.k) {
            property.getValue();
          }
          for (var i = 0; i < len; i += 1) {
            arrValue[i] = property.v[i] * mult;
            expressionValue[i] = arrValue[i];
          }
          return expressionValue;
        };
      } // TODO: try to avoid using this getter

      function defaultGetter() {
        return defaultUnidimensionalValue;
      }
      return function (property) {
        if (!property) {
          return defaultGetter;
        }
        if (property.propType === 'unidimensional') {
          return UnidimensionalPropertyInterface(property);
        }
        return MultidimensionalPropertyInterface(property);
      };
    }();
    var TransformExpressionInterface = function () {
      return function (transform) {
        function _thisFunction(name) {
          switch (name) {
            case 'scale':
            case 'Scale':
            case 'ADBE Scale':
            case 6:
              return _thisFunction.scale;
            case 'rotation':
            case 'Rotation':
            case 'ADBE Rotation':
            case 'ADBE Rotate Z':
            case 10:
              return _thisFunction.rotation;
            case 'ADBE Rotate X':
              return _thisFunction.xRotation;
            case 'ADBE Rotate Y':
              return _thisFunction.yRotation;
            case 'position':
            case 'Position':
            case 'ADBE Position':
            case 2:
              return _thisFunction.position;
            case 'ADBE Position_0':
              return _thisFunction.xPosition;
            case 'ADBE Position_1':
              return _thisFunction.yPosition;
            case 'ADBE Position_2':
              return _thisFunction.zPosition;
            case 'anchorPoint':
            case 'AnchorPoint':
            case 'Anchor Point':
            case 'ADBE AnchorPoint':
            case 1:
              return _thisFunction.anchorPoint;
            case 'opacity':
            case 'Opacity':
            case 11:
              return _thisFunction.opacity;
            default:
              return null;
          }
        }
        Object.defineProperty(_thisFunction, 'rotation', {
          get: ExpressionPropertyInterface(transform.r || transform.rz)
        });
        Object.defineProperty(_thisFunction, 'zRotation', {
          get: ExpressionPropertyInterface(transform.rz || transform.r)
        });
        Object.defineProperty(_thisFunction, 'xRotation', {
          get: ExpressionPropertyInterface(transform.rx)
        });
        Object.defineProperty(_thisFunction, 'yRotation', {
          get: ExpressionPropertyInterface(transform.ry)
        });
        Object.defineProperty(_thisFunction, 'scale', {
          get: ExpressionPropertyInterface(transform.s)
        });
        var _px;
        var _py;
        var _pz;
        var _transformFactory;
        if (transform.p) {
          _transformFactory = ExpressionPropertyInterface(transform.p);
        } else {
          _px = ExpressionPropertyInterface(transform.px);
          _py = ExpressionPropertyInterface(transform.py);
          if (transform.pz) {
            _pz = ExpressionPropertyInterface(transform.pz);
          }
        }
        Object.defineProperty(_thisFunction, 'position', {
          get: function get() {
            if (transform.p) {
              return _transformFactory();
            }
            return [_px(), _py(), _pz ? _pz() : 0];
          }
        });
        Object.defineProperty(_thisFunction, 'xPosition', {
          get: ExpressionPropertyInterface(transform.px)
        });
        Object.defineProperty(_thisFunction, 'yPosition', {
          get: ExpressionPropertyInterface(transform.py)
        });
        Object.defineProperty(_thisFunction, 'zPosition', {
          get: ExpressionPropertyInterface(transform.pz)
        });
        Object.defineProperty(_thisFunction, 'anchorPoint', {
          get: ExpressionPropertyInterface(transform.a)
        });
        Object.defineProperty(_thisFunction, 'opacity', {
          get: ExpressionPropertyInterface(transform.o)
        });
        Object.defineProperty(_thisFunction, 'skew', {
          get: ExpressionPropertyInterface(transform.sk)
        });
        Object.defineProperty(_thisFunction, 'skewAxis', {
          get: ExpressionPropertyInterface(transform.sa)
        });
        Object.defineProperty(_thisFunction, 'orientation', {
          get: ExpressionPropertyInterface(transform.or)
        });
        return _thisFunction;
      };
    }();
    var LayerExpressionInterface = function () {
      function getMatrix(time) {
        var toWorldMat = new Matrix();
        if (time !== undefined) {
          var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
          propMatrix.clone(toWorldMat);
        } else {
          var transformMat = this._elem.finalTransform.mProp;
          transformMat.applyToMatrix(toWorldMat);
        }
        return toWorldMat;
      }
      function toWorldVec(arr, time) {
        var toWorldMat = this.getMatrix(time);
        toWorldMat.props[12] = 0;
        toWorldMat.props[13] = 0;
        toWorldMat.props[14] = 0;
        return this.applyPoint(toWorldMat, arr);
      }
      function toWorld(arr, time) {
        var toWorldMat = this.getMatrix(time);
        return this.applyPoint(toWorldMat, arr);
      }
      function fromWorldVec(arr, time) {
        var toWorldMat = this.getMatrix(time);
        toWorldMat.props[12] = 0;
        toWorldMat.props[13] = 0;
        toWorldMat.props[14] = 0;
        return this.invertPoint(toWorldMat, arr);
      }
      function fromWorld(arr, time) {
        var toWorldMat = this.getMatrix(time);
        return this.invertPoint(toWorldMat, arr);
      }
      function applyPoint(matrix, arr) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
          }
        }
        return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
      }
      function invertPoint(matrix, arr) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
          }
        }
        return matrix.inversePoint(arr);
      }
      function fromComp(arr) {
        var toWorldMat = new Matrix();
        toWorldMat.reset();
        this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
          }
          return toWorldMat.inversePoint(arr);
        }
        return toWorldMat.inversePoint(arr);
      }
      function sampleImage() {
        return [1, 1, 1, 1];
      }
      return function (elem) {
        var transformInterface;
        function _registerMaskInterface(maskManager) {
          _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
        }
        function _registerEffectsInterface(effects) {
          _thisLayerFunction.effect = effects;
        }
        function _thisLayerFunction(name) {
          switch (name) {
            case 'ADBE Root Vectors Group':
            case 'Contents':
            case 2:
              return _thisLayerFunction.shapeInterface;
            case 1:
            case 6:
            case 'Transform':
            case 'transform':
            case 'ADBE Transform Group':
              return transformInterface;
            case 4:
            case 'ADBE Effect Parade':
            case 'effects':
            case 'Effects':
              return _thisLayerFunction.effect;
            case 'ADBE Text Properties':
              return _thisLayerFunction.textInterface;
            default:
              return null;
          }
        }
        _thisLayerFunction.getMatrix = getMatrix;
        _thisLayerFunction.invertPoint = invertPoint;
        _thisLayerFunction.applyPoint = applyPoint;
        _thisLayerFunction.toWorld = toWorld;
        _thisLayerFunction.toWorldVec = toWorldVec;
        _thisLayerFunction.fromWorld = fromWorld;
        _thisLayerFunction.fromWorldVec = fromWorldVec;
        _thisLayerFunction.toComp = toWorld;
        _thisLayerFunction.fromComp = fromComp;
        _thisLayerFunction.sampleImage = sampleImage;
        _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
        _thisLayerFunction._elem = elem;
        transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
        var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
        Object.defineProperties(_thisLayerFunction, {
          hasParent: {
            get: function get() {
              return elem.hierarchy.length;
            }
          },
          parent: {
            get: function get() {
              return elem.hierarchy[0].layerInterface;
            }
          },
          rotation: getDescriptor(transformInterface, 'rotation'),
          scale: getDescriptor(transformInterface, 'scale'),
          position: getDescriptor(transformInterface, 'position'),
          opacity: getDescriptor(transformInterface, 'opacity'),
          anchorPoint: anchorPointDescriptor,
          anchor_point: anchorPointDescriptor,
          transform: {
            get: function get() {
              return transformInterface;
            }
          },
          active: {
            get: function get() {
              return elem.isInRange;
            }
          }
        });
        _thisLayerFunction.startTime = elem.data.st;
        _thisLayerFunction.index = elem.data.ind;
        _thisLayerFunction.source = elem.data.refId;
        _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
        _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
        _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
        _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
        _thisLayerFunction._name = elem.data.nm;
        _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
        _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
        return _thisLayerFunction;
      };
    }();
    var propertyGroupFactory = function () {
      return function (interfaceFunction, parentPropertyGroup) {
        return function (val) {
          val = val === undefined ? 1 : val;
          if (val <= 0) {
            return interfaceFunction;
          }
          return parentPropertyGroup(val - 1);
        };
      };
    }();
    var PropertyInterface = function () {
      return function (propertyName, propertyGroup) {
        var interfaceFunction = {
          _name: propertyName
        };
        function _propertyGroup(val) {
          val = val === undefined ? 1 : val;
          if (val <= 0) {
            return interfaceFunction;
          }
          return propertyGroup(val - 1);
        }
        return _propertyGroup;
      };
    }();
    var EffectsExpressionInterface = function () {
      var ob = {
        createEffectsInterface: createEffectsInterface
      };
      function createEffectsInterface(elem, propertyGroup) {
        if (elem.effectsManager) {
          var effectElements = [];
          var effectsData = elem.data.ef;
          var i;
          var len = elem.effectsManager.effectElements.length;
          for (i = 0; i < len; i += 1) {
            effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
          }
          var effects = elem.data.ef || [];
          var groupInterface = function groupInterface(name) {
            i = 0;
            len = effects.length;
            while (i < len) {
              if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                return effectElements[i];
              }
              i += 1;
            }
            return null;
          };
          Object.defineProperty(groupInterface, 'numProperties', {
            get: function get() {
              return effects.length;
            }
          });
          return groupInterface;
        }
        return null;
      }
      function createGroupInterface(data, elements, propertyGroup, elem) {
        function groupInterface(name) {
          var effects = data.ef;
          var i = 0;
          var len = effects.length;
          while (i < len) {
            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
              if (effects[i].ty === 5) {
                return effectElements[i];
              }
              return effectElements[i]();
            }
            i += 1;
          }
          throw new Error();
        }
        var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
        var effectElements = [];
        var i;
        var len = data.ef.length;
        for (i = 0; i < len; i += 1) {
          if (data.ef[i].ty === 5) {
            effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
          } else {
            effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
          }
        }
        if (data.mn === 'ADBE Color Control') {
          Object.defineProperty(groupInterface, 'color', {
            get: function get() {
              return effectElements[0]();
            }
          });
        }
        Object.defineProperties(groupInterface, {
          numProperties: {
            get: function get() {
              return data.np;
            }
          },
          _name: {
            value: data.nm
          },
          propertyGroup: {
            value: _propertyGroup
          }
        });
        groupInterface.enabled = data.en !== 0;
        groupInterface.active = groupInterface.enabled;
        return groupInterface;
      }
      function createValueInterface(element, type, elem, propertyGroup) {
        var expressionProperty = ExpressionPropertyInterface(element.p);
        function interfaceFunction() {
          if (type === 10) {
            return elem.comp.compInterface(element.p.v);
          }
          return expressionProperty();
        }
        if (element.p.setGroupProperty) {
          element.p.setGroupProperty(PropertyInterface('', propertyGroup));
        }
        return interfaceFunction;
      }
      return ob;
    }();
    var ShapePathInterface = function () {
      return function pathInterfaceFactory(shape, view, propertyGroup) {
        var prop = view.sh;
        function interfaceFunction(val) {
          if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
            return interfaceFunction.path;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          path: {
            get: function get() {
              if (prop.k) {
                prop.getValue();
              }
              return prop;
            }
          },
          shape: {
            get: function get() {
              if (prop.k) {
                prop.getValue();
              }
              return prop;
            }
          },
          _name: {
            value: shape.nm
          },
          ix: {
            value: shape.ix
          },
          propertyIndex: {
            value: shape.ix
          },
          mn: {
            value: shape.mn
          },
          propertyGroup: {
            value: propertyGroup
          }
        });
        return interfaceFunction;
      };
    }();
    var ShapeExpressionInterface = function () {
      function iterateElements(shapes, view, propertyGroup) {
        var arr = [];
        var i;
        var len = shapes ? shapes.length : 0;
        for (i = 0; i < len; i += 1) {
          if (shapes[i].ty === 'gr') {
            arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'fl') {
            arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'st') {
            arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'tm') {
            arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'tr') ;else if (shapes[i].ty === 'el') {
            arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'sr') {
            arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'sh') {
            arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'rc') {
            arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'rd') {
            arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'rp') {
            arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'gf') {
            arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else {
            arr.push(defaultInterfaceFactory());
          }
        }
        return arr;
      }
      function contentsInterfaceFactory(shape, view, propertyGroup) {
        var interfaces;
        var interfaceFunction = function _interfaceFunction(value) {
          var i = 0;
          var len = interfaces.length;
          while (i < len) {
            if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
              return interfaces[i];
            }
            i += 1;
          }
          if (typeof value === 'number') {
            return interfaces[value - 1];
          }
          return null;
        };
        interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
        interfaceFunction.numProperties = interfaces.length;
        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
        interfaceFunction.transform = transformInterface;
        interfaceFunction.propertyIndex = shape.cix;
        interfaceFunction._name = shape.nm;
        return interfaceFunction;
      }
      function groupInterfaceFactory(shape, view, propertyGroup) {
        var interfaceFunction = function _interfaceFunction(value) {
          switch (value) {
            case 'ADBE Vectors Group':
            case 'Contents':
            case 2:
              return interfaceFunction.content;
            // Not necessary for now. Keeping them here in case a new case appears
            // case 'ADBE Vector Transform Group':
            // case 3:

            default:
              return interfaceFunction.transform;
          }
        };
        interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
        interfaceFunction.content = content;
        interfaceFunction.transform = transformInterface;
        Object.defineProperty(interfaceFunction, '_name', {
          get: function get() {
            return shape.nm;
          }
        }); // interfaceFunction.content = interfaceFunction;

        interfaceFunction.numProperties = shape.np;
        interfaceFunction.propertyIndex = shape.ix;
        interfaceFunction.nm = shape.nm;
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function fillInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val) {
          if (val === 'Color' || val === 'color') {
            return interfaceFunction.color;
          }
          if (val === 'Opacity' || val === 'opacity') {
            return interfaceFunction.opacity;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          color: {
            get: ExpressionPropertyInterface(view.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o)
          },
          _name: {
            value: shape.nm
          },
          mn: {
            value: shape.mn
          }
        });
        view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
        return interfaceFunction;
      }
      function gradientFillInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val) {
          if (val === 'Start Point' || val === 'start point') {
            return interfaceFunction.startPoint;
          }
          if (val === 'End Point' || val === 'end point') {
            return interfaceFunction.endPoint;
          }
          if (val === 'Opacity' || val === 'opacity') {
            return interfaceFunction.opacity;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          startPoint: {
            get: ExpressionPropertyInterface(view.s)
          },
          endPoint: {
            get: ExpressionPropertyInterface(view.e)
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o)
          },
          type: {
            get: function get() {
              return 'a';
            }
          },
          _name: {
            value: shape.nm
          },
          mn: {
            value: shape.mn
          }
        });
        view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
        view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
        return interfaceFunction;
      }
      function defaultInterfaceFactory() {
        function interfaceFunction() {
          return null;
        }
        return interfaceFunction;
      }
      function strokeInterfaceFactory(shape, view, propertyGroup) {
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
        function addPropertyToDashOb(i) {
          Object.defineProperty(dashOb, shape.d[i].nm, {
            get: ExpressionPropertyInterface(view.d.dataProps[i].p)
          });
        }
        var i;
        var len = shape.d ? shape.d.length : 0;
        var dashOb = {};
        for (i = 0; i < len; i += 1) {
          addPropertyToDashOb(i);
          view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
        }
        function interfaceFunction(val) {
          if (val === 'Color' || val === 'color') {
            return interfaceFunction.color;
          }
          if (val === 'Opacity' || val === 'opacity') {
            return interfaceFunction.opacity;
          }
          if (val === 'Stroke Width' || val === 'stroke width') {
            return interfaceFunction.strokeWidth;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          color: {
            get: ExpressionPropertyInterface(view.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o)
          },
          strokeWidth: {
            get: ExpressionPropertyInterface(view.w)
          },
          dash: {
            get: function get() {
              return dashOb;
            }
          },
          _name: {
            value: shape.nm
          },
          mn: {
            value: shape.mn
          }
        });
        view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
        view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
        return interfaceFunction;
      }
      function trimInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val) {
          if (val === shape.e.ix || val === 'End' || val === 'end') {
            return interfaceFunction.end;
          }
          if (val === shape.s.ix) {
            return interfaceFunction.start;
          }
          if (val === shape.o.ix) {
            return interfaceFunction.offset;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaceFunction.propertyIndex = shape.ix;
        view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
        view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
        interfaceFunction.propertyIndex = shape.ix;
        interfaceFunction.propertyGroup = propertyGroup;
        Object.defineProperties(interfaceFunction, {
          start: {
            get: ExpressionPropertyInterface(view.s)
          },
          end: {
            get: ExpressionPropertyInterface(view.e)
          },
          offset: {
            get: ExpressionPropertyInterface(view.o)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function transformInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.a.ix === value || value === 'Anchor Point') {
            return interfaceFunction.anchorPoint;
          }
          if (shape.o.ix === value || value === 'Opacity') {
            return interfaceFunction.opacity;
          }
          if (shape.p.ix === value || value === 'Position') {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
            return interfaceFunction.rotation;
          }
          if (shape.s.ix === value || value === 'Scale') {
            return interfaceFunction.scale;
          }
          if (shape.sk && shape.sk.ix === value || value === 'Skew') {
            return interfaceFunction.skew;
          }
          if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {
            return interfaceFunction.skewAxis;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
        view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
        view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
        view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
        view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
        if (view.transform.mProps.sk) {
          view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
          view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
        }
        view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          opacity: {
            get: ExpressionPropertyInterface(view.transform.mProps.o)
          },
          position: {
            get: ExpressionPropertyInterface(view.transform.mProps.p)
          },
          anchorPoint: {
            get: ExpressionPropertyInterface(view.transform.mProps.a)
          },
          scale: {
            get: ExpressionPropertyInterface(view.transform.mProps.s)
          },
          rotation: {
            get: ExpressionPropertyInterface(view.transform.mProps.r)
          },
          skew: {
            get: ExpressionPropertyInterface(view.transform.mProps.sk)
          },
          skewAxis: {
            get: ExpressionPropertyInterface(view.transform.mProps.sa)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.ty = 'tr';
        interfaceFunction.mn = shape.mn;
        interfaceFunction.propertyGroup = propertyGroup;
        return interfaceFunction;
      }
      function ellipseInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.p.ix === value) {
            return interfaceFunction.position;
          }
          if (shape.s.ix === value) {
            return interfaceFunction.size;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaceFunction.propertyIndex = shape.ix;
        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
        prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
        prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          size: {
            get: ExpressionPropertyInterface(prop.s)
          },
          position: {
            get: ExpressionPropertyInterface(prop.p)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function starInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.p.ix === value) {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value) {
            return interfaceFunction.rotation;
          }
          if (shape.pt.ix === value) {
            return interfaceFunction.points;
          }
          if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
            return interfaceFunction.outerRadius;
          }
          if (shape.os.ix === value) {
            return interfaceFunction.outerRoundness;
          }
          if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
            return interfaceFunction.innerRadius;
          }
          if (shape.is && shape.is.ix === value) {
            return interfaceFunction.innerRoundness;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
        interfaceFunction.propertyIndex = shape.ix;
        prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
        prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
        prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
        prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
        prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
        if (shape.ir) {
          prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
          prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
        }
        Object.defineProperties(interfaceFunction, {
          position: {
            get: ExpressionPropertyInterface(prop.p)
          },
          rotation: {
            get: ExpressionPropertyInterface(prop.r)
          },
          points: {
            get: ExpressionPropertyInterface(prop.pt)
          },
          outerRadius: {
            get: ExpressionPropertyInterface(prop.or)
          },
          outerRoundness: {
            get: ExpressionPropertyInterface(prop.os)
          },
          innerRadius: {
            get: ExpressionPropertyInterface(prop.ir)
          },
          innerRoundness: {
            get: ExpressionPropertyInterface(prop.is)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function rectInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.p.ix === value) {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value) {
            return interfaceFunction.roundness;
          }
          if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
            return interfaceFunction.size;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
        interfaceFunction.propertyIndex = shape.ix;
        prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
        prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
        prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          position: {
            get: ExpressionPropertyInterface(prop.p)
          },
          roundness: {
            get: ExpressionPropertyInterface(prop.r)
          },
          size: {
            get: ExpressionPropertyInterface(prop.s)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function roundedInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.r.ix === value || value === 'Round Corners 1') {
            return interfaceFunction.radius;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view;
        interfaceFunction.propertyIndex = shape.ix;
        prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          radius: {
            get: ExpressionPropertyInterface(prop.rd)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      function repeaterInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.c.ix === value || value === 'Copies') {
            return interfaceFunction.copies;
          }
          if (shape.o.ix === value || value === 'Offset') {
            return interfaceFunction.offset;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view;
        interfaceFunction.propertyIndex = shape.ix;
        prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
        prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          copies: {
            get: ExpressionPropertyInterface(prop.c)
          },
          offset: {
            get: ExpressionPropertyInterface(prop.o)
          },
          _name: {
            value: shape.nm
          }
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }
      return function (shapes, view, propertyGroup) {
        var interfaces;
        function _interfaceFunction(value) {
          if (typeof value === 'number') {
            value = value === undefined ? 1 : value;
            if (value === 0) {
              return propertyGroup;
            }
            return interfaces[value - 1];
          }
          var i = 0;
          var len = interfaces.length;
          while (i < len) {
            if (interfaces[i]._name === value) {
              return interfaces[i];
            }
            i += 1;
          }
          return null;
        }
        function parentGroupWrapper() {
          return propertyGroup;
        }
        _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
        interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
        _interfaceFunction.numProperties = interfaces.length;
        _interfaceFunction._name = 'Contents';
        return _interfaceFunction;
      };
    }();
    var TextExpressionInterface = function () {
      return function (elem) {
        var _sourceText;
        function _thisLayerFunction(name) {
          switch (name) {
            case 'ADBE Text Document':
              return _thisLayerFunction.sourceText;
            default:
              return null;
          }
        }
        Object.defineProperty(_thisLayerFunction, 'sourceText', {
          get: function get() {
            elem.textProperty.getValue();
            var stringValue = elem.textProperty.currentData.t;
            if (!_sourceText || stringValue !== _sourceText.value) {
              _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
              // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive

              _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers

              Object.defineProperty(_sourceText, 'style', {
                get: function get() {
                  return {
                    fillColor: elem.textProperty.currentData.fc
                  };
                }
              });
            }
            return _sourceText;
          }
        });
        return _thisLayerFunction;
      };
    }();
    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof(obj);
    }
    var FootageInterface = function () {
      var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {
        var currentPropertyName = '';
        var currentProperty = elem.getFootageData();
        function init() {
          currentPropertyName = '';
          currentProperty = elem.getFootageData();
          return searchProperty;
        }
        function searchProperty(value) {
          if (currentProperty[value]) {
            currentPropertyName = value;
            currentProperty = currentProperty[value];
            if (_typeof(currentProperty) === 'object') {
              return searchProperty;
            }
            return currentProperty;
          }
          var propertyNameIndex = value.indexOf(currentPropertyName);
          if (propertyNameIndex !== -1) {
            var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
            currentProperty = currentProperty[index];
            if (_typeof(currentProperty) === 'object') {
              return searchProperty;
            }
            return currentProperty;
          }
          return '';
        }
        return init;
      };
      var dataInterfaceFactory = function dataInterfaceFactory(elem) {
        function interfaceFunction(value) {
          if (value === 'Outline') {
            return interfaceFunction.outlineInterface();
          }
          return null;
        }
        interfaceFunction._name = 'Outline';
        interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
        return interfaceFunction;
      };
      return function (elem) {
        function _interfaceFunction(value) {
          if (value === 'Data') {
            return _interfaceFunction.dataInterface;
          }
          return null;
        }
        _interfaceFunction._name = 'Data';
        _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
        return _interfaceFunction;
      };
    }();
    var interfaces = {
      layer: LayerExpressionInterface,
      effects: EffectsExpressionInterface,
      comp: CompExpressionInterface,
      shape: ShapeExpressionInterface,
      text: TextExpressionInterface,
      footage: FootageInterface
    };
    function getInterface(type) {
      return interfaces[type] || null;
    }
    var expressionHelpers = function () {
      function searchExpressions(elem, data, prop) {
        if (data.x) {
          prop.k = true;
          prop.x = true;
          prop.initiateExpression = ExpressionManager.initiateExpression;
          prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
        }
      }
      function getValueAtTime(frameNum) {
        frameNum *= this.elem.globalData.frameRate;
        frameNum -= this.offsetTime;
        if (frameNum !== this._cachingAtTime.lastFrame) {
          this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
          this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
          this._cachingAtTime.lastFrame = frameNum;
        }
        return this._cachingAtTime.value;
      }
      function getSpeedAtTime(frameNum) {
        var delta = -0.01;
        var v1 = this.getValueAtTime(frameNum);
        var v2 = this.getValueAtTime(frameNum + delta);
        var speed = 0;
        if (v1.length) {
          var i;
          for (i = 0; i < v1.length; i += 1) {
            speed += Math.pow(v2[i] - v1[i], 2);
          }
          speed = Math.sqrt(speed) * 100;
        } else {
          speed = 0;
        }
        return speed;
      }
      function getVelocityAtTime(frameNum) {
        if (this.vel !== undefined) {
          return this.vel;
        }
        var delta = -0.001; // frameNum += this.elem.data.st;

        var v1 = this.getValueAtTime(frameNum);
        var v2 = this.getValueAtTime(frameNum + delta);
        var velocity;
        if (v1.length) {
          velocity = createTypedArray('float32', v1.length);
          var i;
          for (i = 0; i < v1.length; i += 1) {
            // removing frameRate
            // if needed, don't add it here
            // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
            velocity[i] = (v2[i] - v1[i]) / delta;
          }
        } else {
          velocity = (v2 - v1) / delta;
        }
        return velocity;
      }
      function getStaticValueAtTime() {
        return this.pv;
      }
      function setGroupProperty(propertyGroup) {
        this.propertyGroup = propertyGroup;
      }
      return {
        searchExpressions: searchExpressions,
        getSpeedAtTime: getSpeedAtTime,
        getVelocityAtTime: getVelocityAtTime,
        getValueAtTime: getValueAtTime,
        getStaticValueAtTime: getStaticValueAtTime,
        setGroupProperty: setGroupProperty
      };
    }();
    function addPropertyDecorator() {
      function loopOut(type, duration, durationFlag) {
        if (!this.k || !this.keyframes) {
          return this.pv;
        }
        type = type ? type.toLowerCase() : '';
        var currentFrame = this.comp.renderedFrame;
        var keyframes = this.keyframes;
        var lastKeyFrame = keyframes[keyframes.length - 1].t;
        if (currentFrame <= lastKeyFrame) {
          return this.pv;
        }
        var cycleDuration;
        var firstKeyFrame;
        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }
          firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
          } else {
            cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
          }
          firstKeyFrame = lastKeyFrame - cycleDuration;
        }
        var i;
        var len;
        var ret;
        if (type === 'pingpong') {
          var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
          if (iterations % 2 !== 0) {
            return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
          }
        } else if (type === 'offset') {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line

          var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = (endV[i] - initV[i]) * repeats + current[i];
            }
            return ret;
          }
          return (endV - initV) * repeats + current;
        } else if (type === 'continue') {
          var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            ret = new Array(lastValue.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
            }
            return ret;
          }
          return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);
        }
        return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      }
      function loopIn(type, duration, durationFlag) {
        if (!this.k) {
          return this.pv;
        }
        type = type ? type.toLowerCase() : '';
        var currentFrame = this.comp.renderedFrame;
        var keyframes = this.keyframes;
        var firstKeyFrame = keyframes[0].t;
        if (currentFrame >= firstKeyFrame) {
          return this.pv;
        }
        var cycleDuration;
        var lastKeyFrame;
        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }
          lastKeyFrame = keyframes[duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
          } else {
            cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
          }
          lastKeyFrame = firstKeyFrame + cycleDuration;
        }
        var i;
        var len;
        var ret;
        if (type === 'pingpong') {
          var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
          if (iterations % 2 === 0) {
            return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
          }
        } else if (type === 'offset') {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
            }
            return ret;
          }
          return current - (endV - initV) * repeats;
        } else if (type === 'continue') {
          var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            ret = new Array(firstValue.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;
            }
            return ret;
          }
          return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;
        }
        return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
      }
      function smooth(width, samples) {
        if (!this.k) {
          return this.pv;
        }
        width = (width || 0.4) * 0.5;
        samples = Math.floor(samples || 5);
        if (samples <= 1) {
          return this.pv;
        }
        var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
        var initFrame = currentTime - width;
        var endFrame = currentTime + width;
        var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
        var i = 0;
        var j = 0;
        var value;
        if (this.pv.length) {
          value = createTypedArray('float32', this.pv.length);
        } else {
          value = 0;
        }
        var sampleValue;
        while (i < samples) {
          sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
          if (this.pv.length) {
            for (j = 0; j < this.pv.length; j += 1) {
              value[j] += sampleValue[j];
            }
          } else {
            value += sampleValue;
          }
          i += 1;
        }
        if (this.pv.length) {
          for (j = 0; j < this.pv.length; j += 1) {
            value[j] /= samples;
          }
        } else {
          value /= samples;
        }
        return value;
      }
      function getTransformValueAtTime(time) {
        if (!this._transformCachingAtTime) {
          this._transformCachingAtTime = {
            v: new Matrix()
          };
        } /// /

        var matrix = this._transformCachingAtTime.v;
        matrix.cloneFromProps(this.pre.props);
        if (this.appliedTransformations < 1) {
          var anchor = this.a.getValueAtTime(time);
          matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
        }
        if (this.appliedTransformations < 2) {
          var scale = this.s.getValueAtTime(time);
          matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);
        }
        if (this.sk && this.appliedTransformations < 3) {
          var skew = this.sk.getValueAtTime(time);
          var skewAxis = this.sa.getValueAtTime(time);
          matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
        }
        if (this.r && this.appliedTransformations < 4) {
          var rotation = this.r.getValueAtTime(time);
          matrix.rotate(-rotation * this.r.mult);
        } else if (!this.r && this.appliedTransformations < 4) {
          var rotationZ = this.rz.getValueAtTime(time);
          var rotationY = this.ry.getValueAtTime(time);
          var rotationX = this.rx.getValueAtTime(time);
          var orientation = this.or.getValueAtTime(time);
          matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
        }
        if (this.data.p && this.data.p.s) {
          var positionX = this.px.getValueAtTime(time);
          var positionY = this.py.getValueAtTime(time);
          if (this.data.p.z) {
            var positionZ = this.pz.getValueAtTime(time);
            matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
          } else {
            matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
          }
        } else {
          var position = this.p.getValueAtTime(time);
          matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);
        }
        return matrix; /// /
      }
      function getTransformStaticValueAtTime() {
        return this.v.clone(new Matrix());
      }
      var getTransformProperty = TransformPropertyFactory.getTransformProperty;
      TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
        var prop = getTransformProperty(elem, data, container);
        if (prop.dynamicProperties.length) {
          prop.getValueAtTime = getTransformValueAtTime.bind(prop);
        } else {
          prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
        }
        prop.setGroupProperty = expressionHelpers.setGroupProperty;
        return prop;
      };
      var propertyGetProp = PropertyFactory.getProp;
      PropertyFactory.getProp = function (elem, data, type, mult, container) {
        var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;
        // prop.loopOut = loopOut;
        // prop.loopIn = loopIn;

        if (prop.kf) {
          prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
        } else {
          prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
        }
        prop.setGroupProperty = expressionHelpers.setGroupProperty;
        prop.loopOut = loopOut;
        prop.loopIn = loopIn;
        prop.smooth = smooth;
        prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
        prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
        prop.numKeys = data.a === 1 ? data.k.length : 0;
        prop.propertyIndex = data.ix;
        var value = 0;
        if (type !== 0) {
          value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
        }
        prop._cachingAtTime = {
          lastFrame: initialDefaultFrame,
          lastIndex: 0,
          value: value
        };
        expressionHelpers.searchExpressions(elem, data, prop);
        if (prop.k) {
          container.addDynamicProperty(prop);
        }
        return prop;
      };
      function getShapeValueAtTime(frameNum) {
        // For now this caching object is created only when needed instead of creating it when the shape is initialized.
        if (!this._cachingAtTime) {
          this._cachingAtTime = {
            shapeValue: shapePool.clone(this.pv),
            lastIndex: 0,
            lastTime: initialDefaultFrame
          };
        }
        frameNum *= this.elem.globalData.frameRate;
        frameNum -= this.offsetTime;
        if (frameNum !== this._cachingAtTime.lastTime) {
          this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
          this._cachingAtTime.lastTime = frameNum;
          this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
        }
        return this._cachingAtTime.shapeValue;
      }
      var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
      var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
      function ShapeExpressions() {}
      ShapeExpressions.prototype = {
        vertices: function vertices(prop, time) {
          if (this.k) {
            this.getValue();
          }
          var shapePath = this.v;
          if (time !== undefined) {
            shapePath = this.getValueAtTime(time, 0);
          }
          var i;
          var len = shapePath._length;
          var vertices = shapePath[prop];
          var points = shapePath.v;
          var arr = createSizedArray(len);
          for (i = 0; i < len; i += 1) {
            if (prop === 'i' || prop === 'o') {
              arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
            } else {
              arr[i] = [vertices[i][0], vertices[i][1]];
            }
          }
          return arr;
        },
        points: function points(time) {
          return this.vertices('v', time);
        },
        inTangents: function inTangents(time) {
          return this.vertices('i', time);
        },
        outTangents: function outTangents(time) {
          return this.vertices('o', time);
        },
        isClosed: function isClosed() {
          return this.v.c;
        },
        pointOnPath: function pointOnPath(perc, time) {
          var shapePath = this.v;
          if (time !== undefined) {
            shapePath = this.getValueAtTime(time, 0);
          }
          if (!this._segmentsLength) {
            this._segmentsLength = bez.getSegmentsLength(shapePath);
          }
          var segmentsLength = this._segmentsLength;
          var lengths = segmentsLength.lengths;
          var lengthPos = segmentsLength.totalLength * perc;
          var i = 0;
          var len = lengths.length;
          var accumulatedLength = 0;
          var pt;
          while (i < len) {
            if (accumulatedLength + lengths[i].addedLength > lengthPos) {
              var initIndex = i;
              var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
              var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
              pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
              break;
            } else {
              accumulatedLength += lengths[i].addedLength;
            }
            i += 1;
          }
          if (!pt) {
            pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
          }
          return pt;
        },
        vectorOnPath: function vectorOnPath(perc, time, vectorType) {
          // perc doesn't use triple equality because it can be a Number object as well as a primitive.
          if (perc == 1) {
            // eslint-disable-line eqeqeq
            perc = this.v.c;
          } else if (perc == 0) {
            // eslint-disable-line eqeqeq
            perc = 0.999;
          }
          var pt1 = this.pointOnPath(perc, time);
          var pt2 = this.pointOnPath(perc + 0.001, time);
          var xLength = pt2[0] - pt1[0];
          var yLength = pt2[1] - pt1[1];
          var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
          if (magnitude === 0) {
            return [0, 0];
          }
          var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
          return unitVector;
        },
        tangentOnPath: function tangentOnPath(perc, time) {
          return this.vectorOnPath(perc, time, 'tangent');
        },
        normalOnPath: function normalOnPath(perc, time) {
          return this.vectorOnPath(perc, time, 'normal');
        },
        setGroupProperty: expressionHelpers.setGroupProperty,
        getValueAtTime: expressionHelpers.getStaticValueAtTime
      };
      extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
      extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
      KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
      KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
      var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
      ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
        var prop = propertyGetShapeProp(elem, data, type, arr, trims);
        prop.propertyIndex = data.ix;
        prop.lock = false;
        if (type === 3) {
          expressionHelpers.searchExpressions(elem, data.pt, prop);
        } else if (type === 4) {
          expressionHelpers.searchExpressions(elem, data.ks, prop);
        }
        if (prop.k) {
          elem.addDynamicProperty(prop);
        }
        return prop;
      };
    }
    function initialize$1() {
      addPropertyDecorator();
    }
    function addDecorator() {
      function searchExpressions() {
        if (this.data.d.x) {
          this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
          this.addEffect(this.getExpressionValue.bind(this));
          return true;
        }
        return null;
      }
      TextProperty.prototype.getExpressionValue = function (currentValue, text) {
        var newValue = this.calculateExpression(text);
        if (currentValue.t !== newValue) {
          var newData = {};
          this.copyData(newData, currentValue);
          newData.t = newValue.toString();
          newData.__complete = false;
          return newData;
        }
        return currentValue;
      };
      TextProperty.prototype.searchProperty = function () {
        var isKeyframed = this.searchKeyframes();
        var hasExpressions = this.searchExpressions();
        this.kf = isKeyframed || hasExpressions;
        return this.kf;
      };
      TextProperty.prototype.searchExpressions = searchExpressions;
    }
    function initialize() {
      addDecorator();
    }
    function SVGComposableEffect() {}
    SVGComposableEffect.prototype = {
      createMergeNode: function createMergeNode(resultId, ins) {
        var feMerge = createNS('feMerge');
        feMerge.setAttribute('result', resultId);
        var feMergeNode;
        var i;
        for (i = 0; i < ins.length; i += 1) {
          feMergeNode = createNS('feMergeNode');
          feMergeNode.setAttribute('in', ins[i]);
          feMerge.appendChild(feMergeNode);
          feMerge.appendChild(feMergeNode);
        }
        return feMerge;
      }
    };
    var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';
    function SVGTintFilter(filter, filterManager, elem, id, source) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
      feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');
      this.linearFilter = feColorMatrix;
      feColorMatrix.setAttribute('result', id + '_tint_1');
      filter.appendChild(feColorMatrix);
      feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
      feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
      feColorMatrix.setAttribute('result', id + '_tint_2');
      filter.appendChild(feColorMatrix);
      this.matrixFilter = feColorMatrix;
      var feMerge = this.createMergeNode(id, [source, id + '_tint_1', id + '_tint_2']);
      filter.appendChild(feMerge);
    }
    extendPrototype([SVGComposableEffect], SVGTintFilter);
    SVGTintFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var colorBlack = this.filterManager.effectElements[0].p.v;
        var colorWhite = this.filterManager.effectElements[1].p.v;
        var opacity = this.filterManager.effectElements[2].p.v / 100;
        this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');
        this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');
      }
    };
    function SVGFillFilter(filter, filterManager, elem, id) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
      feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
      feColorMatrix.setAttribute('result', id);
      filter.appendChild(feColorMatrix);
      this.matrixFilter = feColorMatrix;
    }
    SVGFillFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var color = this.filterManager.effectElements[2].p.v;
        var opacity = this.filterManager.effectElements[6].p.v;
        this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
      }
    };
    function SVGStrokeEffect(fil, filterManager, elem) {
      this.initialized = false;
      this.filterManager = filterManager;
      this.elem = elem;
      this.paths = [];
    }
    SVGStrokeEffect.prototype.initialize = function () {
      var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
      var path;
      var groupPath;
      var i;
      var len;
      if (this.filterManager.effectElements[1].p.v === 1) {
        len = this.elem.maskManager.masksProperties.length;
        i = 0;
      } else {
        i = this.filterManager.effectElements[0].p.v - 1;
        len = i + 1;
      }
      groupPath = createNS('g');
      groupPath.setAttribute('fill', 'none');
      groupPath.setAttribute('stroke-linecap', 'round');
      groupPath.setAttribute('stroke-dashoffset', 1);
      for (i; i < len; i += 1) {
        path = createNS('path');
        groupPath.appendChild(path);
        this.paths.push({
          p: path,
          m: i
        });
      }
      if (this.filterManager.effectElements[10].p.v === 3) {
        var mask = createNS('mask');
        var id = createElementID();
        mask.setAttribute('id', id);
        mask.setAttribute('mask-type', 'alpha');
        mask.appendChild(groupPath);
        this.elem.globalData.defs.appendChild(mask);
        var g = createNS('g');
        g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
        while (elemChildren[0]) {
          g.appendChild(elemChildren[0]);
        }
        this.elem.layerElement.appendChild(g);
        this.masker = mask;
        groupPath.setAttribute('stroke', '#fff');
      } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (this.filterManager.effectElements[10].p.v === 2) {
          elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
          while (elemChildren.length) {
            this.elem.layerElement.removeChild(elemChildren[0]);
          }
        }
        this.elem.layerElement.appendChild(groupPath);
        this.elem.layerElement.removeAttribute('mask');
        groupPath.setAttribute('stroke', '#fff');
      }
      this.initialized = true;
      this.pathMasker = groupPath;
    };
    SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
      if (!this.initialized) {
        this.initialize();
      }
      var i;
      var len = this.paths.length;
      var mask;
      var path;
      for (i = 0; i < len; i += 1) {
        if (this.paths[i].m !== -1) {
          mask = this.elem.maskManager.viewData[this.paths[i].m];
          path = this.paths[i].p;
          if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
            path.setAttribute('d', mask.lastPath);
          }
          if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
            var dasharrayValue;
            if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
              var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
              var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
              var l = path.getTotalLength();
              dasharrayValue = '0 0 0 ' + l * s + ' ';
              var lineLength = l * (e - s);
              var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              var units = Math.floor(lineLength / segment);
              var j;
              for (j = 0; j < units; j += 1) {
                dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
              }
              dasharrayValue += '0 ' + l * 10 + ' 0 0';
            } else {
              dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
            }
            path.setAttribute('stroke-dasharray', dasharrayValue);
          }
        }
      }
      if (forceRender || this.filterManager.effectElements[4].p._mdf) {
        this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
      }
      if (forceRender || this.filterManager.effectElements[6].p._mdf) {
        this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
      }
      if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (forceRender || this.filterManager.effectElements[3].p._mdf) {
          var color = this.filterManager.effectElements[3].p.v;
          this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
        }
      }
    };
    function SVGTritoneFilter(filter, filterManager, elem, id) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
      feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
      filter.appendChild(feColorMatrix);
      var feComponentTransfer = createNS('feComponentTransfer');
      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
      feComponentTransfer.setAttribute('result', id);
      this.matrixFilter = feComponentTransfer;
      var feFuncR = createNS('feFuncR');
      feFuncR.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFuncR);
      this.feFuncR = feFuncR;
      var feFuncG = createNS('feFuncG');
      feFuncG.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFuncG);
      this.feFuncG = feFuncG;
      var feFuncB = createNS('feFuncB');
      feFuncB.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFuncB);
      this.feFuncB = feFuncB;
      filter.appendChild(feComponentTransfer);
    }
    SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var color1 = this.filterManager.effectElements[0].p.v;
        var color2 = this.filterManager.effectElements[1].p.v;
        var color3 = this.filterManager.effectElements[2].p.v;
        var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
        var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
        var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
        this.feFuncR.setAttribute('tableValues', tableR);
        this.feFuncG.setAttribute('tableValues', tableG);
        this.feFuncB.setAttribute('tableValues', tableB);
      }
    };
    function SVGProLevelsFilter(filter, filterManager, elem, id) {
      this.filterManager = filterManager;
      var effectElements = this.filterManager.effectElements;
      var feComponentTransfer = createNS('feComponentTransfer'); // Red

      if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
        this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
      } // Green

      if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
        this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
      } // Blue

      if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
        this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
      } // Alpha

      if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
        this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
      } // RGB

      if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
        feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
        filter.appendChild(feComponentTransfer);
      }
      if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
        feComponentTransfer = createNS('feComponentTransfer');
        feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
        feComponentTransfer.setAttribute('result', id);
        filter.appendChild(feComponentTransfer);
        this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
        this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
        this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
      }
    }
    SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
      var feFunc = createNS(type);
      feFunc.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFunc);
      return feFunc;
    };
    SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
      var cnt = 0;
      var segments = 256;
      var perc;
      var min = Math.min(inputBlack, inputWhite);
      var max = Math.max(inputBlack, inputWhite);
      var table = Array.call(null, {
        length: segments
      });
      var colorValue;
      var pos = 0;
      var outputDelta = outputWhite - outputBlack;
      var inputDelta = inputWhite - inputBlack;
      while (cnt <= 256) {
        perc = cnt / 256;
        if (perc <= min) {
          colorValue = inputDelta < 0 ? outputWhite : outputBlack;
        } else if (perc >= max) {
          colorValue = inputDelta < 0 ? outputBlack : outputWhite;
        } else {
          colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
        }
        table[pos] = colorValue;
        pos += 1;
        cnt += 256 / (segments - 1);
      }
      return table.join(' ');
    };
    SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var val;
        var effectElements = this.filterManager.effectElements;
        if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
          val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
          this.feFuncRComposed.setAttribute('tableValues', val);
          this.feFuncGComposed.setAttribute('tableValues', val);
          this.feFuncBComposed.setAttribute('tableValues', val);
        }
        if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
          val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
          this.feFuncR.setAttribute('tableValues', val);
        }
        if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
          val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
          this.feFuncG.setAttribute('tableValues', val);
        }
        if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
          val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
          this.feFuncB.setAttribute('tableValues', val);
        }
        if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
          val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
          this.feFuncA.setAttribute('tableValues', val);
        }
      }
    };
    function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
      var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
      var filterSize = filterManager.data.fs || globalFilterSize;
      filter.setAttribute('x', filterSize.x || globalFilterSize.x);
      filter.setAttribute('y', filterSize.y || globalFilterSize.y);
      filter.setAttribute('width', filterSize.width || globalFilterSize.width);
      filter.setAttribute('height', filterSize.height || globalFilterSize.height);
      this.filterManager = filterManager;
      var feGaussianBlur = createNS('feGaussianBlur');
      feGaussianBlur.setAttribute('in', 'SourceAlpha');
      feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');
      feGaussianBlur.setAttribute('stdDeviation', '0');
      this.feGaussianBlur = feGaussianBlur;
      filter.appendChild(feGaussianBlur);
      var feOffset = createNS('feOffset');
      feOffset.setAttribute('dx', '25');
      feOffset.setAttribute('dy', '0');
      feOffset.setAttribute('in', id + '_drop_shadow_1');
      feOffset.setAttribute('result', id + '_drop_shadow_2');
      this.feOffset = feOffset;
      filter.appendChild(feOffset);
      var feFlood = createNS('feFlood');
      feFlood.setAttribute('flood-color', '#00ff00');
      feFlood.setAttribute('flood-opacity', '1');
      feFlood.setAttribute('result', id + '_drop_shadow_3');
      this.feFlood = feFlood;
      filter.appendChild(feFlood);
      var feComposite = createNS('feComposite');
      feComposite.setAttribute('in', id + '_drop_shadow_3');
      feComposite.setAttribute('in2', id + '_drop_shadow_2');
      feComposite.setAttribute('operator', 'in');
      feComposite.setAttribute('result', id + '_drop_shadow_4');
      filter.appendChild(feComposite);
      var feMerge = this.createMergeNode(id, [id + '_drop_shadow_4', source]);
      filter.appendChild(feMerge); //
    }
    extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
    SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
        }
        if (forceRender || this.filterManager.effectElements[0].p._mdf) {
          var col = this.filterManager.effectElements[0].p.v;
          this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
        }
        if (forceRender || this.filterManager.effectElements[1].p._mdf) {
          this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
        }
        if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
          var distance = this.filterManager.effectElements[3].p.v;
          var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
          var x = distance * Math.cos(angle);
          var y = distance * Math.sin(angle);
          this.feOffset.setAttribute('dx', x);
          this.feOffset.setAttribute('dy', y);
        }
      }
    };
    var _svgMatteSymbols = [];
    function SVGMatte3Effect(filterElem, filterManager, elem) {
      this.initialized = false;
      this.filterManager = filterManager;
      this.filterElem = filterElem;
      this.elem = elem;
      elem.matteElement = createNS('g');
      elem.matteElement.appendChild(elem.layerElement);
      elem.matteElement.appendChild(elem.transformedElement);
      elem.baseElement = elem.matteElement;
    }
    SVGMatte3Effect.prototype.findSymbol = function (mask) {
      var i = 0;
      var len = _svgMatteSymbols.length;
      while (i < len) {
        if (_svgMatteSymbols[i] === mask) {
          return _svgMatteSymbols[i];
        }
        i += 1;
      }
      return null;
    };
    SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
      var parentNode = mask.layerElement.parentNode;
      if (!parentNode) {
        return;
      }
      var children = parentNode.children;
      var i = 0;
      var len = children.length;
      while (i < len) {
        if (children[i] === mask.layerElement) {
          break;
        }
        i += 1;
      }
      var nextChild;
      if (i <= len - 2) {
        nextChild = children[i + 1];
      }
      var useElem = createNS('use');
      useElem.setAttribute('href', '#' + symbolId);
      if (nextChild) {
        parentNode.insertBefore(useElem, nextChild);
      } else {
        parentNode.appendChild(useElem);
      }
    };
    SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
      if (!this.findSymbol(mask)) {
        var symbolId = createElementID();
        var masker = createNS('mask');
        masker.setAttribute('id', mask.layerId);
        masker.setAttribute('mask-type', 'alpha');
        _svgMatteSymbols.push(mask);
        var defs = elem.globalData.defs;
        defs.appendChild(masker);
        var symbol = createNS('symbol');
        symbol.setAttribute('id', symbolId);
        this.replaceInParent(mask, symbolId);
        symbol.appendChild(mask.layerElement);
        defs.appendChild(symbol);
        var useElem = createNS('use');
        useElem.setAttribute('href', '#' + symbolId);
        masker.appendChild(useElem);
        mask.data.hd = false;
        mask.show();
      }
      elem.setMatte(mask.layerId);
    };
    SVGMatte3Effect.prototype.initialize = function () {
      var ind = this.filterManager.effectElements[0].p.v;
      var elements = this.elem.comp.elements;
      var i = 0;
      var len = elements.length;
      while (i < len) {
        if (elements[i] && elements[i].data.ind === ind) {
          this.setElementAsMask(this.elem, elements[i]);
        }
        i += 1;
      }
      this.initialized = true;
    };
    SVGMatte3Effect.prototype.renderFrame = function () {
      if (!this.initialized) {
        this.initialize();
      }
    };
    function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
      // Outset the filter region by 100% on all sides to accommodate blur expansion.
      filter.setAttribute('x', '-100%');
      filter.setAttribute('y', '-100%');
      filter.setAttribute('width', '300%');
      filter.setAttribute('height', '300%');
      this.filterManager = filterManager;
      var feGaussianBlur = createNS('feGaussianBlur');
      feGaussianBlur.setAttribute('result', id);
      filter.appendChild(feGaussianBlur);
      this.feGaussianBlur = feGaussianBlur;
    }
    SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        // Empirical value, matching AE's blur appearance.
        var kBlurrinessToSigma = 0.3;
        var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:
        //
        //   1 -> horizontal & vertical
        //   2 -> horizontal only
        //   3 -> vertical only
        //

        var dimensions = this.filterManager.effectElements[1].p.v;
        var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq

        var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq

        this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY); // Repeat edges mapping:
        //
        //   0 -> off -> duplicate
        //   1 -> on  -> wrap

        var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq

        this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
      }
    };
    function TransformEffect() {}
    TransformEffect.prototype.init = function (effectsManager) {
      this.effectsManager = effectsManager;
      this.type = effectTypes.TRANSFORM_EFFECT;
      this.matrix = new Matrix();
      this.opacity = -1;
      this._mdf = false;
      this._opMdf = false;
    };
    TransformEffect.prototype.renderFrame = function (forceFrame) {
      this._opMdf = false;
      this._mdf = false;
      if (forceFrame || this.effectsManager._mdf) {
        var effectElements = this.effectsManager.effectElements;
        var anchor = effectElements[0].p.v;
        var position = effectElements[1].p.v;
        var isUniformScale = effectElements[2].p.v === 1;
        var scaleHeight = effectElements[3].p.v;
        var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
        var skew = effectElements[5].p.v;
        var skewAxis = effectElements[6].p.v;
        var rotation = effectElements[7].p.v;
        this.matrix.reset();
        this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
        this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
        this.matrix.rotate(-rotation * degToRads);
        this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
        this.matrix.translate(position[0], position[1], 0);
        this._mdf = true;
        if (this.opacity !== effectElements[8].p.v) {
          this.opacity = effectElements[8].p.v;
          this._opMdf = true;
        }
      }
    };
    function SVGTransformEffect(_, filterManager) {
      this.init(filterManager);
    }
    extendPrototype([TransformEffect], SVGTransformEffect);
    function CVTransformEffect(effectsManager) {
      this.init(effectsManager);
    }
    extendPrototype([TransformEffect], CVTransformEffect);
    registerRenderer('canvas', CanvasRenderer);
    registerRenderer('html', HybridRenderer);
    registerRenderer('svg', SVGRenderer); // Registering shape modifiers

    ShapeModifiers.registerModifier('tm', TrimModifier);
    ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);
    ShapeModifiers.registerModifier('rp', RepeaterModifier);
    ShapeModifiers.registerModifier('rd', RoundCornersModifier);
    ShapeModifiers.registerModifier('zz', ZigZagModifier);
    ShapeModifiers.registerModifier('op', OffsetPathModifier); // Registering expression plugin

    setExpressionsPlugin(Expressions);
    setExpressionInterfaces(getInterface);
    initialize$1();
    initialize(); // Registering svg effects

    registerEffect$1(20, SVGTintFilter, true);
    registerEffect$1(21, SVGFillFilter, true);
    registerEffect$1(22, SVGStrokeEffect, false);
    registerEffect$1(23, SVGTritoneFilter, true);
    registerEffect$1(24, SVGProLevelsFilter, true);
    registerEffect$1(25, SVGDropShadowEffect, true);
    registerEffect$1(28, SVGMatte3Effect, false);
    registerEffect$1(29, SVGGaussianBlurEffect, true);
    registerEffect$1(35, SVGTransformEffect, false);
    registerEffect(35, CVTransformEffect);
    return lottie;
  });
})(lottie$1, lottie$1.exports);
const lottie = lottie$1.exports;
const buttonBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block}:host .button,:host a.button,:host button.button,:host input.button{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;text-decoration:none;text-align:center;white-space:nowrap;box-sizing:border-box;border:0 solid transparent;--wink-icon-button-padding:var(--semantic-spacing-sm);--wink-icon-button-padding-sm:var(--semantic-spacing-xs)}:host .button:hover,:host a.button:hover,:host button.button:hover,:host input.button:hover{cursor:pointer;text-decoration:none}:host .button:focus,:host a.button:focus,:host button.button:focus,:host input.button:focus{text-decoration:none}:host .button wink-icon,:host .button ::part(icon),:host a.button wink-icon,:host a.button ::part(icon),:host button.button wink-icon,:host button.button ::part(icon),:host input.button wink-icon,:host input.button ::part(icon){font-weight:normal;line-height:unset;padding:0}:host .button.primary,:host a.button.primary,:host button.button.primary,:host input.button.primary{color:var(--semantic-color-text-on-action);background-color:var(--semantic-color-background-surface-action-default);padding:calc(var(--semantic-spacing-sm) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);border-radius:calc(var(--semantic-radius-sm) * 1rem)}:host .button.primary ::part(icon),:host a.button.primary ::part(icon),:host button.button.primary ::part(icon),:host input.button.primary ::part(icon){color:var(--semantic-color-icon-on-brand)}:host .button.primary:hover,:host a.button.primary:hover,:host button.button.primary:hover,:host input.button.primary:hover{color:var(--semantic-color-text-on-action);background-color:var(--semantic-color-background-surface-action-hover)}:host .button.primary:active,:host a.button.primary:active,:host button.button.primary:active,:host input.button.primary:active{color:var(--semantic-color-text-on-action);background-color:var(--semantic-color-background-surface-action-active)}:host .button.primary:focus,:host .button.primary:focus-visible,:host a.button.primary:focus,:host a.button.primary:focus-visible,:host button.button.primary:focus,:host button.button.primary:focus-visible,:host input.button.primary:focus,:host input.button.primary:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .button.secondary,:host a.button.secondary,:host button.button.secondary,:host input.button.secondary{color:var(--semantic-color-text-default);background-color:transparent;padding:calc(var(--semantic-spacing-sm) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);border-radius:calc(var(--semantic-radius-sm) * 1rem);box-shadow:inset 0 0 0 0.2rem var(--semantic-color-border-button-default)}:host .button.secondary ::part(icon) i,:host a.button.secondary ::part(icon) i,:host button.button.secondary ::part(icon) i,:host input.button.secondary ::part(icon) i{color:var(--semantic-color-icon-default)}:host .button.secondary:hover,:host a.button.secondary:hover,:host button.button.secondary:hover,:host input.button.secondary:hover{color:var(--semantic-color-text-default);background-color:transparent;box-shadow:inset 0 0 0 0.3rem var(--semantic-color-border-highlight)}:host .button.secondary:active,:host a.button.secondary:active,:host button.button.secondary:active,:host input.button.secondary:active{color:var(--semantic-color-text-default);background-color:transparent;box-shadow:inset 0 0 0 0.1rem var(--semantic-color-border-highlight)}:host .button.secondary:focus,:host .button.secondary:focus-visible,:host a.button.secondary:focus,:host a.button.secondary:focus-visible,:host button.button.secondary:focus,:host button.button.secondary:focus-visible,:host input.button.secondary:focus,:host input.button.secondary:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}@media only screen and (min-width: 74.5em){:host .button,:host a.button,:host button.button,:host input.button{--wink-icon-button-padding:1.4;--wink-icon-button-padding-sm:1}}:host .button.tertiary,:host a.button.tertiary,:host button.button.tertiary,:host input.button.tertiary{position:relative;left:0;color:var(--semantic-color-text-default);background-color:transparent;padding:0 0 calc(var(--semantic-spacing-3xs) * 1rem);border-radius:calc(var(--semantic-radius-sm) * 1rem)}:host .button.tertiary ::part(icon) i,:host a.button.tertiary ::part(icon) i,:host button.button.tertiary ::part(icon) i,:host input.button.tertiary ::part(icon) i{color:var(--semantic-color-icon-default)}:host .button.tertiary::before,:host .button.tertiary::after,:host a.button.tertiary::before,:host a.button.tertiary::after,:host button.button.tertiary::before,:host button.button.tertiary::after,:host input.button.tertiary::before,:host input.button.tertiary::after{content:\" \";display:inline-block;height:0.2rem;position:absolute;left:0;bottom:0}:host .button.tertiary::before,:host a.button.tertiary::before,:host button.button.tertiary::before,:host input.button.tertiary::before{background-color:var(--semantic-color-border-button-underline);width:100%}:host .button.tertiary::after,:host a.button.tertiary::after,:host button.button.tertiary::after,:host input.button.tertiary::after{background-color:var(--semantic-color-border-highlight);width:0%;transition:all 500ms cubic-bezier(0.23, 1, 0.32, 1)}:host .button.tertiary.icon-left::before,:host .button.tertiary.icon-left::after,:host a.button.tertiary.icon-left::before,:host a.button.tertiary.icon-left::after,:host button.button.tertiary.icon-left::before,:host button.button.tertiary.icon-left::after,:host input.button.tertiary.icon-left::before,:host input.button.tertiary.icon-left::after{left:3.2rem}:host .button.tertiary.icon-right::before,:host .button.tertiary.icon-left::before,:host a.button.tertiary.icon-right::before,:host a.button.tertiary.icon-left::before,:host button.button.tertiary.icon-right::before,:host button.button.tertiary.icon-left::before,:host input.button.tertiary.icon-right::before,:host input.button.tertiary.icon-left::before{width:calc(100% - 3.2rem)}:host .button.tertiary:hover::after,:host a.button.tertiary:hover::after,:host button.button.tertiary:hover::after,:host input.button.tertiary:hover::after{width:100%}:host .button.tertiary:hover.icon-right::after,:host .button.tertiary:hover.icon-left::after,:host a.button.tertiary:hover.icon-right::after,:host a.button.tertiary:hover.icon-left::after,:host button.button.tertiary:hover.icon-right::after,:host button.button.tertiary:hover.icon-left::after,:host input.button.tertiary:hover.icon-right::after,:host input.button.tertiary:hover.icon-left::after{width:calc(100% - 3.2rem)}:host .button.tertiary:active,:host a.button.tertiary:active,:host button.button.tertiary:active,:host input.button.tertiary:active{color:var(--semantic-color-text-subtlest)}:host .button.tertiary:active::after,:host a.button.tertiary:active::after,:host button.button.tertiary:active::after,:host input.button.tertiary:active::after{background-color:var(--semantic-color-text-subtlest)}:host .button.tertiary:active ::part(icon),:host a.button.tertiary:active ::part(icon),:host button.button.tertiary:active ::part(icon),:host input.button.tertiary:active ::part(icon){color:var(--semantic-color-text-subtlest)}:host .button.tertiary:focus,:host .button.tertiary:focus-visible,:host a.button.tertiary:focus,:host a.button.tertiary:focus-visible,:host button.button.tertiary:focus,:host button.button.tertiary:focus-visible,:host input.button.tertiary:focus,:host input.button.tertiary:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .button.icon-button,:host a.button.icon-button,:host button.button.icon-button,:host input.button.icon-button{padding:calc(var(--wink-icon-button-padding) * 1rem)}:host .button.icon-button.tertiary::before,:host .button.icon-button.tertiary:hover::after,:host a.button.icon-button.tertiary::before,:host a.button.icon-button.tertiary:hover::after,:host button.button.icon-button.tertiary::before,:host button.button.icon-button.tertiary:hover::after,:host input.button.icon-button.tertiary::before,:host input.button.icon-button.tertiary:hover::after{width:0}:host .button.icon-button.tertiary:hover ::part(icon)::before,:host a.button.icon-button.tertiary:hover ::part(icon)::before,:host button.button.icon-button.tertiary:hover ::part(icon)::before,:host input.button.icon-button.tertiary:hover ::part(icon)::before{position:relative;top:-0.1rem}:host .button.size-sm.primary,:host a.button.size-sm.primary,:host button.button.size-sm.primary,:host input.button.size-sm.primary{padding:calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem)}:host .button.size-sm.secondary,:host a.button.size-sm.secondary,:host button.button.size-sm.secondary,:host input.button.size-sm.secondary{padding:calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem)}:host .button.size-sm.tertiary.icon-left::before,:host .button.size-sm.tertiary.icon-left::after,:host a.button.size-sm.tertiary.icon-left::before,:host a.button.size-sm.tertiary.icon-left::after,:host button.button.size-sm.tertiary.icon-left::before,:host button.button.size-sm.tertiary.icon-left::after,:host input.button.size-sm.tertiary.icon-left::before,:host input.button.size-sm.tertiary.icon-left::after{left:2.8rem}:host .button.size-sm.tertiary.icon-right::before,:host .button.size-sm.tertiary.icon-left::before,:host a.button.size-sm.tertiary.icon-right::before,:host a.button.size-sm.tertiary.icon-left::before,:host button.button.size-sm.tertiary.icon-right::before,:host button.button.size-sm.tertiary.icon-left::before,:host input.button.size-sm.tertiary.icon-right::before,:host input.button.size-sm.tertiary.icon-left::before{width:calc(100% - 2.8rem)}:host .button.size-sm.tertiary.icon-button::before,:host a.button.size-sm.tertiary.icon-button::before,:host button.button.size-sm.tertiary.icon-button::before,:host input.button.size-sm.tertiary.icon-button::before{width:0}:host .button.size-sm.tertiary:hover.icon-right.size-sm::after,:host .button.size-sm.tertiary:hover.icon-left.size-sm::after,:host a.button.size-sm.tertiary:hover.icon-right.size-sm::after,:host a.button.size-sm.tertiary:hover.icon-left.size-sm::after,:host button.button.size-sm.tertiary:hover.icon-right.size-sm::after,:host button.button.size-sm.tertiary:hover.icon-left.size-sm::after,:host input.button.size-sm.tertiary:hover.icon-right.size-sm::after,:host input.button.size-sm.tertiary:hover.icon-left.size-sm::after{width:calc(100% - 2.8rem)}:host .button.size-sm.tertiary:hover.icon-button.size-sm::after,:host a.button.size-sm.tertiary:hover.icon-button.size-sm::after,:host button.button.size-sm.tertiary:hover.icon-button.size-sm::after,:host input.button.size-sm.tertiary:hover.icon-button.size-sm::after{width:0}:host .button.size-sm.icon-button,:host a.button.size-sm.icon-button,:host button.button.size-sm.icon-button,:host input.button.size-sm.icon-button{padding:calc(var(--wink-icon-button-padding-sm) * 1rem)}:host .button.size-sm.icon-button ::part(icon)::before,:host a.button.size-sm.icon-button ::part(icon)::before,:host button.button.size-sm.icon-button ::part(icon)::before,:host input.button.size-sm.icon-button ::part(icon)::before{position:relative;top:-0.2rem}:host .button.size-sm.icon-button.tertiary:hover ::part(icon)::before,:host a.button.size-sm.icon-button.tertiary:hover ::part(icon)::before,:host button.button.size-sm.icon-button.tertiary:hover ::part(icon)::before,:host input.button.size-sm.icon-button.tertiary:hover ::part(icon)::before{top:-0.5rem}:host .button.state-disable,:host .button:disabled,:host a.button.state-disable,:host a.button:disabled,:host button.button.state-disable,:host button.button:disabled,:host input.button.state-disable,:host input.button:disabled{opacity:0.4;pointer-events:none}:host .button.state-loading,:host a.button.state-loading,:host button.button.state-loading,:host input.button.state-loading{display:flex;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem);pointer-events:none;opacity:0.4}:host .button.state-loading .animation,:host a.button.state-loading .animation,:host button.button.state-loading .animation,:host input.button.state-loading .animation{height:calc(var(--semantic-icon-md) * 1rem);width:calc(var(--semantic-icon-md) * 1rem)}:host .button.state-loading.size-sm .animation,:host a.button.state-loading.size-sm .animation,:host button.button.state-loading.size-sm .animation,:host input.button.state-loading.size-sm .animation{height:calc(var(--semantic-icon-sm) * 1rem);width:calc(var(--semantic-icon-sm) * 1rem)}:host .button.state-loading.tertiary::before,:host .button.state-loading.tertiary::after,:host a.button.state-loading.tertiary::before,:host a.button.state-loading.tertiary::after,:host button.button.state-loading.tertiary::before,:host button.button.state-loading.tertiary::after,:host input.button.state-loading.tertiary::before,:host input.button.state-loading.tertiary::after{content:unset}:host .button.icon-left,:host .button.icon-right,:host a.button.icon-left,:host a.button.icon-right,:host button.button.icon-left,:host button.button.icon-right,:host input.button.icon-left,:host input.button.icon-right{display:flex;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem)}:host .button.icon-left wink-icon,:host .button.icon-right wink-icon,:host a.button.icon-left wink-icon,:host a.button.icon-right wink-icon,:host button.button.icon-left wink-icon,:host button.button.icon-right wink-icon,:host input.button.icon-left wink-icon,:host input.button.icon-right wink-icon{align-self:start}:host .button.icon-right,:host a.button.icon-right,:host button.button.icon-right,:host input.button.icon-right{flex-direction:row-reverse}:host([status=loading]){cursor:not-allowed}:host([status=disable]){cursor:not-allowed}:host([width=full]){display:block;width:100%}:host([width=full]) .button{width:100%}.button,a.button,button.button,input.button{font-family:AkagiProBold}";
const WinkButtonBaseStyle0 = buttonBaseCss;
const buttonTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block}:host .button,:host a.button,:host button.button,:host input.button{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:inline-flex;justify-content:center;align-items:center;vertical-align:middle;text-decoration:none;text-align:center;white-space:nowrap;box-sizing:border-box;border:0 solid transparent;--wink-icon-button-padding:var(--semantic-spacing-sm);--wink-icon-button-padding-sm:var(--semantic-spacing-xs)}:host .button:hover,:host a.button:hover,:host button.button:hover,:host input.button:hover{cursor:pointer;text-decoration:none}:host .button:focus,:host a.button:focus,:host button.button:focus,:host input.button:focus{text-decoration:none}:host .button wink-icon,:host .button ::part(icon),:host a.button wink-icon,:host a.button ::part(icon),:host button.button wink-icon,:host button.button ::part(icon),:host input.button wink-icon,:host input.button ::part(icon){font-weight:normal;line-height:unset;padding:0}:host .button.primary,:host a.button.primary,:host button.button.primary,:host input.button.primary{color:var(--semantic-color-text-on-action);background-color:var(--semantic-color-background-surface-action-default);padding:calc(var(--semantic-spacing-sm) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);border-radius:calc(var(--semantic-radius-sm) * 1rem)}:host .button.primary ::part(icon),:host a.button.primary ::part(icon),:host button.button.primary ::part(icon),:host input.button.primary ::part(icon){color:var(--semantic-color-icon-on-brand)}:host .button.primary:hover,:host a.button.primary:hover,:host button.button.primary:hover,:host input.button.primary:hover{color:var(--semantic-color-text-on-action);background-color:var(--semantic-color-background-surface-action-hover)}:host .button.primary:active,:host a.button.primary:active,:host button.button.primary:active,:host input.button.primary:active{color:var(--semantic-color-text-on-action);background-color:var(--semantic-color-background-surface-action-active)}:host .button.primary:focus,:host .button.primary:focus-visible,:host a.button.primary:focus,:host a.button.primary:focus-visible,:host button.button.primary:focus,:host button.button.primary:focus-visible,:host input.button.primary:focus,:host input.button.primary:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .button.secondary,:host a.button.secondary,:host button.button.secondary,:host input.button.secondary{color:var(--semantic-color-text-default);background-color:transparent;padding:calc(var(--semantic-spacing-sm) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);border-radius:calc(var(--semantic-radius-sm) * 1rem);box-shadow:inset 0 0 0 0.2rem var(--semantic-color-border-button-default)}:host .button.secondary ::part(icon) i,:host a.button.secondary ::part(icon) i,:host button.button.secondary ::part(icon) i,:host input.button.secondary ::part(icon) i{color:var(--semantic-color-icon-default)}:host .button.secondary:hover,:host a.button.secondary:hover,:host button.button.secondary:hover,:host input.button.secondary:hover{color:var(--semantic-color-text-default);background-color:transparent;box-shadow:inset 0 0 0 0.3rem var(--semantic-color-border-highlight)}:host .button.secondary:active,:host a.button.secondary:active,:host button.button.secondary:active,:host input.button.secondary:active{color:var(--semantic-color-text-default);background-color:transparent;box-shadow:inset 0 0 0 0.1rem var(--semantic-color-border-highlight)}:host .button.secondary:focus,:host .button.secondary:focus-visible,:host a.button.secondary:focus,:host a.button.secondary:focus-visible,:host button.button.secondary:focus,:host button.button.secondary:focus-visible,:host input.button.secondary:focus,:host input.button.secondary:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}@media only screen and (min-width: 74.5em){:host .button,:host a.button,:host button.button,:host input.button{--wink-icon-button-padding:1.4;--wink-icon-button-padding-sm:1}}:host .button.tertiary,:host a.button.tertiary,:host button.button.tertiary,:host input.button.tertiary{position:relative;left:0;color:var(--semantic-color-text-default);background-color:transparent;padding:0 0 calc(var(--semantic-spacing-3xs) * 1rem);border-radius:calc(var(--semantic-radius-sm) * 1rem)}:host .button.tertiary ::part(icon) i,:host a.button.tertiary ::part(icon) i,:host button.button.tertiary ::part(icon) i,:host input.button.tertiary ::part(icon) i{color:var(--semantic-color-icon-default)}:host .button.tertiary::before,:host .button.tertiary::after,:host a.button.tertiary::before,:host a.button.tertiary::after,:host button.button.tertiary::before,:host button.button.tertiary::after,:host input.button.tertiary::before,:host input.button.tertiary::after{content:\" \";display:inline-block;height:0.2rem;position:absolute;left:0;bottom:0}:host .button.tertiary::before,:host a.button.tertiary::before,:host button.button.tertiary::before,:host input.button.tertiary::before{background-color:var(--semantic-color-border-button-underline);width:100%}:host .button.tertiary::after,:host a.button.tertiary::after,:host button.button.tertiary::after,:host input.button.tertiary::after{background-color:var(--semantic-color-border-highlight);width:0%;transition:all 500ms cubic-bezier(0.23, 1, 0.32, 1)}:host .button.tertiary.icon-left::before,:host .button.tertiary.icon-left::after,:host a.button.tertiary.icon-left::before,:host a.button.tertiary.icon-left::after,:host button.button.tertiary.icon-left::before,:host button.button.tertiary.icon-left::after,:host input.button.tertiary.icon-left::before,:host input.button.tertiary.icon-left::after{left:3.2rem}:host .button.tertiary.icon-right::before,:host .button.tertiary.icon-left::before,:host a.button.tertiary.icon-right::before,:host a.button.tertiary.icon-left::before,:host button.button.tertiary.icon-right::before,:host button.button.tertiary.icon-left::before,:host input.button.tertiary.icon-right::before,:host input.button.tertiary.icon-left::before{width:calc(100% - 3.2rem)}:host .button.tertiary:hover::after,:host a.button.tertiary:hover::after,:host button.button.tertiary:hover::after,:host input.button.tertiary:hover::after{width:100%}:host .button.tertiary:hover.icon-right::after,:host .button.tertiary:hover.icon-left::after,:host a.button.tertiary:hover.icon-right::after,:host a.button.tertiary:hover.icon-left::after,:host button.button.tertiary:hover.icon-right::after,:host button.button.tertiary:hover.icon-left::after,:host input.button.tertiary:hover.icon-right::after,:host input.button.tertiary:hover.icon-left::after{width:calc(100% - 3.2rem)}:host .button.tertiary:active,:host a.button.tertiary:active,:host button.button.tertiary:active,:host input.button.tertiary:active{color:var(--semantic-color-text-subtlest)}:host .button.tertiary:active::after,:host a.button.tertiary:active::after,:host button.button.tertiary:active::after,:host input.button.tertiary:active::after{background-color:var(--semantic-color-text-subtlest)}:host .button.tertiary:active ::part(icon),:host a.button.tertiary:active ::part(icon),:host button.button.tertiary:active ::part(icon),:host input.button.tertiary:active ::part(icon){color:var(--semantic-color-text-subtlest)}:host .button.tertiary:focus,:host .button.tertiary:focus-visible,:host a.button.tertiary:focus,:host a.button.tertiary:focus-visible,:host button.button.tertiary:focus,:host button.button.tertiary:focus-visible,:host input.button.tertiary:focus,:host input.button.tertiary:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .button.icon-button,:host a.button.icon-button,:host button.button.icon-button,:host input.button.icon-button{padding:calc(var(--wink-icon-button-padding) * 1rem)}:host .button.icon-button.tertiary::before,:host .button.icon-button.tertiary:hover::after,:host a.button.icon-button.tertiary::before,:host a.button.icon-button.tertiary:hover::after,:host button.button.icon-button.tertiary::before,:host button.button.icon-button.tertiary:hover::after,:host input.button.icon-button.tertiary::before,:host input.button.icon-button.tertiary:hover::after{width:0}:host .button.icon-button.tertiary:hover ::part(icon)::before,:host a.button.icon-button.tertiary:hover ::part(icon)::before,:host button.button.icon-button.tertiary:hover ::part(icon)::before,:host input.button.icon-button.tertiary:hover ::part(icon)::before{position:relative;top:-0.1rem}:host .button.size-sm.primary,:host a.button.size-sm.primary,:host button.button.size-sm.primary,:host input.button.size-sm.primary{padding:calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem)}:host .button.size-sm.secondary,:host a.button.size-sm.secondary,:host button.button.size-sm.secondary,:host input.button.size-sm.secondary{padding:calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem)}:host .button.size-sm.tertiary.icon-left::before,:host .button.size-sm.tertiary.icon-left::after,:host a.button.size-sm.tertiary.icon-left::before,:host a.button.size-sm.tertiary.icon-left::after,:host button.button.size-sm.tertiary.icon-left::before,:host button.button.size-sm.tertiary.icon-left::after,:host input.button.size-sm.tertiary.icon-left::before,:host input.button.size-sm.tertiary.icon-left::after{left:2.8rem}:host .button.size-sm.tertiary.icon-right::before,:host .button.size-sm.tertiary.icon-left::before,:host a.button.size-sm.tertiary.icon-right::before,:host a.button.size-sm.tertiary.icon-left::before,:host button.button.size-sm.tertiary.icon-right::before,:host button.button.size-sm.tertiary.icon-left::before,:host input.button.size-sm.tertiary.icon-right::before,:host input.button.size-sm.tertiary.icon-left::before{width:calc(100% - 2.8rem)}:host .button.size-sm.tertiary.icon-button::before,:host a.button.size-sm.tertiary.icon-button::before,:host button.button.size-sm.tertiary.icon-button::before,:host input.button.size-sm.tertiary.icon-button::before{width:0}:host .button.size-sm.tertiary:hover.icon-right.size-sm::after,:host .button.size-sm.tertiary:hover.icon-left.size-sm::after,:host a.button.size-sm.tertiary:hover.icon-right.size-sm::after,:host a.button.size-sm.tertiary:hover.icon-left.size-sm::after,:host button.button.size-sm.tertiary:hover.icon-right.size-sm::after,:host button.button.size-sm.tertiary:hover.icon-left.size-sm::after,:host input.button.size-sm.tertiary:hover.icon-right.size-sm::after,:host input.button.size-sm.tertiary:hover.icon-left.size-sm::after{width:calc(100% - 2.8rem)}:host .button.size-sm.tertiary:hover.icon-button.size-sm::after,:host a.button.size-sm.tertiary:hover.icon-button.size-sm::after,:host button.button.size-sm.tertiary:hover.icon-button.size-sm::after,:host input.button.size-sm.tertiary:hover.icon-button.size-sm::after{width:0}:host .button.size-sm.icon-button,:host a.button.size-sm.icon-button,:host button.button.size-sm.icon-button,:host input.button.size-sm.icon-button{padding:calc(var(--wink-icon-button-padding-sm) * 1rem)}:host .button.size-sm.icon-button ::part(icon)::before,:host a.button.size-sm.icon-button ::part(icon)::before,:host button.button.size-sm.icon-button ::part(icon)::before,:host input.button.size-sm.icon-button ::part(icon)::before{position:relative;top:-0.2rem}:host .button.size-sm.icon-button.tertiary:hover ::part(icon)::before,:host a.button.size-sm.icon-button.tertiary:hover ::part(icon)::before,:host button.button.size-sm.icon-button.tertiary:hover ::part(icon)::before,:host input.button.size-sm.icon-button.tertiary:hover ::part(icon)::before{top:-0.5rem}:host .button.state-disable,:host .button:disabled,:host a.button.state-disable,:host a.button:disabled,:host button.button.state-disable,:host button.button:disabled,:host input.button.state-disable,:host input.button:disabled{opacity:0.4;pointer-events:none}:host .button.state-loading,:host a.button.state-loading,:host button.button.state-loading,:host input.button.state-loading{display:flex;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem);pointer-events:none;opacity:0.4}:host .button.state-loading .animation,:host a.button.state-loading .animation,:host button.button.state-loading .animation,:host input.button.state-loading .animation{height:calc(var(--semantic-icon-md) * 1rem);width:calc(var(--semantic-icon-md) * 1rem)}:host .button.state-loading.size-sm .animation,:host a.button.state-loading.size-sm .animation,:host button.button.state-loading.size-sm .animation,:host input.button.state-loading.size-sm .animation{height:calc(var(--semantic-icon-sm) * 1rem);width:calc(var(--semantic-icon-sm) * 1rem)}:host .button.state-loading.tertiary::before,:host .button.state-loading.tertiary::after,:host a.button.state-loading.tertiary::before,:host a.button.state-loading.tertiary::after,:host button.button.state-loading.tertiary::before,:host button.button.state-loading.tertiary::after,:host input.button.state-loading.tertiary::before,:host input.button.state-loading.tertiary::after{content:unset}:host .button.icon-left,:host .button.icon-right,:host a.button.icon-left,:host a.button.icon-right,:host button.button.icon-left,:host button.button.icon-right,:host input.button.icon-left,:host input.button.icon-right{display:flex;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem)}:host .button.icon-left wink-icon,:host .button.icon-right wink-icon,:host a.button.icon-left wink-icon,:host a.button.icon-right wink-icon,:host button.button.icon-left wink-icon,:host button.button.icon-right wink-icon,:host input.button.icon-left wink-icon,:host input.button.icon-right wink-icon{align-self:start}:host .button.icon-right,:host a.button.icon-right,:host button.button.icon-right,:host input.button.icon-right{flex-direction:row-reverse}:host([status=loading]){cursor:not-allowed}:host([status=disable]){cursor:not-allowed}:host([width=full]){display:block;width:100%}:host([width=full]) .button{width:100%}:host .button,:host a.button,:host button.button,:host input.button{font-family:TelenetAlbra-Regular, Helvetica, Verdana, Arial, sans-serif;font-size:1.6rem;line-height:2.4rem;font-weight:400}@media only screen and (min-width: 48.0625em){:host .button,:host a.button,:host button.button,:host input.button{font-size:1.6rem;line-height:2.4rem}}@media only screen and (min-width: 74.5em){:host .button,:host a.button,:host button.button,:host input.button{font-size:1.8rem;line-height:2.8rem}}:host .button.primary,:host a.button.primary,:host button.button.primary,:host input.button.primary{font-weight:700;font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host .button.secondary,:host a.button.secondary,:host button.button.secondary,:host input.button.secondary{font-weight:600;font-family:TelenetAlbra-Semi, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host .button.tertiary,:host a.button.tertiary,:host button.button.tertiary,:host input.button.tertiary{font-weight:500}:host .button.size-sm,:host a.button.size-sm,:host button.button.size-sm,:host input.button.size-sm{font-size:var(--wink-button--sm-fs, 1.4rem);line-height:var(--wink-button--sm-lh, 2rem)}@media only screen and (min-width: 74.5em){:host .button.size-sm,:host a.button.size-sm,:host button.button.size-sm,:host input.button.size-sm{--wink-button--sm-fs:1.6rem;--wink-button--sm-lh:2.4rem}}:host .button.size-sm.primary,:host a.button.size-sm.primary,:host button.button.size-sm.primary,:host input.button.size-sm.primary{font-weight:700;font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host .button.size-sm.secondary,:host a.button.size-sm.secondary,:host button.button.size-sm.secondary,:host input.button.size-sm.secondary{font-weight:600;font-family:TelenetAlbra-Semi, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host .button.size-sm.tertiary,:host a.button.size-sm.tertiary,:host button.button.size-sm.tertiary,:host input.button.size-sm.tertiary{font-weight:500}";
const WinkButtonTelenetStyle0 = buttonTelenetCss;
const Button = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.proxyCustomElement)(class Button extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.text = undefined;
    this.loadingText = undefined;
    this.element = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.B.button;
    this.appearance = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.a.secondary;
    this.size = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.b.md;
    this.width = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.c.none;
    this.status = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.d.none;
    this.href = undefined;
    this.target = _targets_types_js__WEBPACK_IMPORTED_MODULE_1__.T.self;
    this.type = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.T.button;
    this.icon = undefined;
    this.iconButtonAriaLabel = undefined;
    this.iconPosition = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.e.left;
  }
  getText = () => {
    if (this.status === _button_types_js__WEBPACK_IMPORTED_MODULE_2__.d.loading) {
      return this.loadingText;
    }
    return this.text;
  };
  loaderSVG = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-animation", {
    class: "animation",
    src: "/assets/shared/animations/spinner.json",
    autoplay: true
  });
  getClasses() {
    return {
      button: true,
      [`type-${this.element}`]: this.element !== 'button',
      [`${this.appearance}`]: true,
      [`size-${this.size}`]: this.size !== _button_types_js__WEBPACK_IMPORTED_MODULE_2__.b.md,
      [`icon-${this.iconPosition}`]: typeof this.icon !== 'undefined',
      [`state-${this.status}`]: this.status !== 'none',
      ['icon-button']: !this.getText() && this.icon !== ''
    };
  }
  getAttributes() {
    return {
      ...(this.element !== 'a' && {
        type: this.type
      }),
      ...(this.element === 'a' && {
        href: this.href
      }),
      ...(this.element === 'a' && {
        target: this.target
      }),
      ...(this.element === 'input' && {
        value: this.getText()
      }),
      disabled: (this.status === 'disable' || this.status === 'loading') && this.element !== 'a',
      ...(this.element !== 'button' && {
        role: 'button'
      }),
      ...((this.status === 'disable' || this.status === 'loading') && {
        ['aria-disabled']: 'true'
      }),
      'aria-label': this.text ? this.text : this.iconButtonAriaLabel
    };
  }
  componentDidRender() {
    if (this.status === _button_types_js__WEBPACK_IMPORTED_MODULE_2__.d.loading) {
      this.iconPosition = _button_types_js__WEBPACK_IMPORTED_MODULE_2__.e.right;
    }
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.Host, {
      key: '61b61e2d5528b91a81d3e956b1276081ce2fc13f',
      exportparts: this.icon && `icon, icon-${this.icon}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)(this.element, {
      key: '94b61f7d41421ab21375d4269568c439b270ddaa',
      class: this.getClasses(),
      ...this.getAttributes()
    }, this.icon && this.status !== 'loading' && this.element !== 'input' && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-icon", {
      appearance: "default",
      icon: this.icon,
      size: this.size
    }), this.status === _button_types_js__WEBPACK_IMPORTED_MODULE_2__.d.loading && this.loaderSVG, this.element !== 'input' && this.getText()));
  }
  static get style() {
    return {
      base: WinkButtonBaseStyle0,
      telenet: WinkButtonTelenetStyle0
    };
  }
}, [33, "wink-button", {
  "text": [1],
  "loadingText": [1, "loading-text"],
  "element": [1],
  "appearance": [1],
  "size": [1],
  "width": [1],
  "status": [1],
  "href": [1],
  "target": [1],
  "type": [1],
  "icon": [1],
  "iconButtonAriaLabel": [1, "icon-button-aria-label"],
  "iconPosition": [1025, "icon-position"]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-button", "wink-animation", "wink-button", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Button);
        }
        break;
      case "wink-animation":
        if (!customElements.get(tagName)) {
          defineCustomElement();
        }
        break;
      case "wink-button":
        if (!customElements.get(tagName)) {
          defineCustomElement$1();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
    }
  });
}
const animationBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;position:relative;width:100%;height:auto}:host .controls{width:100%;position:absolute;bottom:calc(var(--semantic-spacing-md) * 1rem);display:flex;gap:calc(var(--semantic-spacing-xl) * 1rem);justify-content:center;align-items:center}";
const WinkAnimationBaseStyle0 = animationBaseCss;
const animationTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;position:relative;width:100%;height:auto}:host .controls{width:100%;position:absolute;bottom:calc(var(--semantic-spacing-md) * 1rem);display:flex;gap:calc(var(--semantic-spacing-xl) * 1rem);justify-content:center;align-items:center}";
const WinkAnimationTelenetStyle0 = animationTelenetCss;
const Animation = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.proxyCustomElement)(class Animation extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.src = '';
    this.count = 0;
    this.autoplay = false;
    this.controls = false;
    this.clickToPlay = false;
    this.lottie = {};
    this.status = ANIMATION_STATES.play;
    this.loaded = false;
  }
  get host() {
    return this;
  }
  watchPropHandler(newValue, oldValue) {
    if (newValue !== oldValue && this.loaded) {
      this.loadAnimation();
    }
  }
  toggleAnimation() {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (_this.status === ANIMATION_STATES.stop || _this.status === ANIMATION_STATES.pauze) {
        _this.play();
        _this.autoplay = true;
      } else {
        _this.pause();
      }
    })();
  }
  componentDidLoad() {
    this.loadAnimation();
    if (!this.autoplay) {
      this.pause();
    }
  }
  loadAnimation() {
    const container = this.host.shadowRoot?.querySelector('.animation-wrapper');
    if (container) {
      if (this.lottie.isLoaded) {
        this.lottie?.destroy();
      }
      container.innerHTML = '';
      this.lottie = lottie.loadAnimation({
        container: container,
        renderer: 'svg',
        loop: this.count > 0 ? this.count : true,
        autoplay: this.autoplay,
        path: this.src
      });
      this.loaded = true;
    }
    if (this.autoplay) {
      this.play();
      this.status = ANIMATION_STATES.play;
    }
    this.lottie.addEventListener('complete', () => {
      this.status = ANIMATION_STATES.stop;
    });
  }
  play() {
    if (this.status === ANIMATION_STATES.stop) {
      this.lottie.goToAndPlay(0);
    } else {
      this.lottie.play();
    }
    this.status = ANIMATION_STATES.play;
  }
  pause() {
    this.status = ANIMATION_STATES.pauze;
    this.lottie.pause();
  }
  stop() {
    this.status = ANIMATION_STATES.stop;
    this.lottie.stop();
  }
  toggleAnimationOnClick() {
    if (!this.clickToPlay) return;
    if (this.status === ANIMATION_STATES.stop || this.status === ANIMATION_STATES.pauze) {
      this.play();
    } else {
      this.pause();
    }
  }
  renderControls() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
      class: "controls"
    }, this.lottie.isPaused ? (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-button", {
      element: "button",
      type: "button",
      appearance: "primary",
      size: "sm",
      icon: "play",
      onClick: this.play.bind(this)
    }) : (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-button", {
      element: "button",
      type: "button",
      appearance: "primary",
      size: "sm",
      icon: "pause",
      onClick: this.pause.bind(this)
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-button", {
      element: "button",
      type: "button",
      appearance: "primary",
      size: "sm",
      icon: "stop",
      onClick: this.stop.bind(this)
    }));
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.Host, {
      key: '68d3c41efa8301a1b6dd5b056c93b8318bc7007e'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
      key: 'd0b94395072a43af73184fccfd5fbf075d77427b',
      onClick: () => this.toggleAnimationOnClick(),
      class: "animation-wrapper",
      "data-status": this.status
    }), this.lottie && this.controls && this.renderControls());
  }
  static get watchers() {
    return {
      "src": ["watchPropHandler"],
      "count": ["watchPropHandler"],
      "autoplay": ["watchPropHandler"],
      "controls": ["watchPropHandler"]
    };
  }
  static get style() {
    return {
      base: WinkAnimationBaseStyle0,
      telenet: WinkAnimationTelenetStyle0
    };
  }
}, [33, "wink-animation", {
  "src": [1],
  "count": [2],
  "autoplay": [1540],
  "controls": [516],
  "clickToPlay": [4, "click-to-play"],
  "lottie": [32],
  "status": [32],
  "loaded": [32],
  "toggleAnimation": [64]
}, undefined, {
  "src": ["watchPropHandler"],
  "count": ["watchPropHandler"],
  "autoplay": ["watchPropHandler"],
  "controls": ["watchPropHandler"]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-animation", "wink-animation", "wink-button", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-animation":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Animation);
        }
        break;
      case "wink-animation":
        if (!customElements.get(tagName)) {
          defineCustomElement();
        }
        break;
      case "wink-button":
        if (!customElements.get(tagName)) {
          defineCustomElement$1();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
    }
  });
}


/***/ }),

/***/ 69214:
/*!*******************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/breakpoints.types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ BREAKPOINTS)
/* harmony export */ });
const BREAKPOINTS = {
  mobile: '(max-width: 576px)',
  tablet: '(max-width: 769px)'
};


/***/ }),

/***/ 5074:
/*!**************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/button.types.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   B: () => (/* binding */ BUTTON_ELEMENTS),
/* harmony export */   T: () => (/* binding */ TYPES),
/* harmony export */   a: () => (/* binding */ BUTTON_APPEARANCES),
/* harmony export */   b: () => (/* binding */ BUTTON_SIZES),
/* harmony export */   c: () => (/* binding */ BUTTON_WIDTHS),
/* harmony export */   d: () => (/* binding */ BUTTON_STATUSES),
/* harmony export */   e: () => (/* binding */ BUTTON_ICON_POSITIONS)
/* harmony export */ });
/* harmony import */ var _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.types.js */ 7988);

const BUTTON_APPEARANCES = {
  primary: 'primary',
  secondary: 'secondary',
  tertiary: 'tertiary'
};
const TYPES = {
  button: 'button',
  submit: 'submit',
  reset: 'reset',
  file: 'file'
};
const BUTTON_ELEMENTS = {
  button: 'button',
  input: 'input',
  a: 'a'
};
const BUTTON_SIZES = {
  md: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.md,
  sm: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.sm
};
const BUTTON_WIDTHS = {
  none: 'none',
  full: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.full
};
const BUTTON_STATUSES = {
  none: 'none',
  disable: 'disable',
  loading: 'loading',
  skeleton: 'skeleton'
};
const BUTTON_ICON_POSITIONS = {
  left: 'left',
  right: 'right'
};


/***/ }),

/***/ 84878:
/*!***************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/dropdown-menu.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DropdownMenu),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _icon_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.types.js */ 98681);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);



const DROPDOWN_ALIGN = {
  topLeft: 'top-left',
  topRight: 'top-right',
  bottomLeft: 'bottom-left',
  bottomRight: 'bottom-right'
};
const dropdownMenuBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{box-sizing:border-box;position:relative;display:inline-block;font-family:TelenetAlbra-Regular, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-size:1.6rem}:host .dropdown-menu--heading{display:flex;justify-content:center;align-items:center;border:0;padding:calc(var(--semantic-spacing-xs) * 1rem);border-radius:calc(var(--semantic-radius-default) * 1rem);color:var(--wink-dropdown-color, var(--semantic-color-text-default));background-color:var(--wink-dropdown-bg-color, var(--semantic-color-background-surface-subtle-default));font-size:var(--wink-dropdown-font-size, inherit);text-align:right}:host .dropdown-menu--heading ::slotted([slot=dropdown-menu--avatar]){margin-right:calc(var(--semantic-spacing-xs) * 1rem)}:host .dropdown-menu--heading .dropdown-menu--chevron{display:inline-flex;margin-left:0.8rem;transform:rotate(0deg);transition:0.25s ease-in-out}:host .dropdown-menu--heading:hover,:host .dropdown-menu--heading:focus{cursor:pointer;background-color:var(--semantic-color-background-surface-subtle-hovered)}:host .dropdown-menu--heading:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .dropdown-menu--list{position:absolute;margin:0;display:none;flex-direction:column;padding:calc(var(--semantic-spacing-sm) * 1rem);gap:calc(var(--semantic-spacing-xs) * 1rem);background-color:var(--semantic-color-background-canvas-overlapping);box-shadow:0 0.8rem 1.6rem 0 rgba(41, 29, 24, 0.08);z-index:3;width:100%}:host .dropdown-menu--list li{list-style-type:none}:host([is-expanded]) .dropdown-menu--heading .dropdown-menu--chevron{transform:scaleY(-1)}:host([is-expanded]) .dropdown-menu--list{display:flex}:host(.dropdown-menu--align-list--top-left) .dropdown-menu--list{left:0;top:calc(100% + 0.8rem)}:host(.dropdown-menu--align-list--top-right) .dropdown-menu--list{right:0;top:calc(100% + 0.8rem)}:host(.dropdown-menu--align-list--bottom-left) .dropdown-menu--list{left:0;bottom:calc(100% + 0.8rem)}:host(.dropdown-menu--align-list--bottom-right) .dropdown-menu--list{right:0;bottom:calc(100% + 0.8rem)}";
const WinkDropdownMenuBaseStyle0 = dropdownMenuBaseCss;
const dropdownMenuTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{box-sizing:border-box;position:relative;display:inline-block;font-family:TelenetAlbra-Regular, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-size:1.6rem}:host .dropdown-menu--heading{display:flex;justify-content:center;align-items:center;border:0;padding:calc(var(--semantic-spacing-xs) * 1rem);border-radius:calc(var(--semantic-radius-default) * 1rem);color:var(--wink-dropdown-color, var(--semantic-color-text-default));background-color:var(--wink-dropdown-bg-color, var(--semantic-color-background-surface-subtle-default));font-size:var(--wink-dropdown-font-size, inherit);text-align:right}:host .dropdown-menu--heading ::slotted([slot=dropdown-menu--avatar]){margin-right:calc(var(--semantic-spacing-xs) * 1rem)}:host .dropdown-menu--heading .dropdown-menu--chevron{display:inline-flex;margin-left:0.8rem;transform:rotate(0deg);transition:0.25s ease-in-out}:host .dropdown-menu--heading:hover,:host .dropdown-menu--heading:focus{cursor:pointer;background-color:var(--semantic-color-background-surface-subtle-hovered)}:host .dropdown-menu--heading:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .dropdown-menu--list{position:absolute;margin:0;display:none;flex-direction:column;padding:calc(var(--semantic-spacing-sm) * 1rem);gap:calc(var(--semantic-spacing-xs) * 1rem);background-color:var(--semantic-color-background-canvas-overlapping);box-shadow:0 0.8rem 1.6rem 0 rgba(41, 29, 24, 0.08);z-index:3;width:100%}:host .dropdown-menu--list li{list-style-type:none}:host([is-expanded]) .dropdown-menu--heading .dropdown-menu--chevron{transform:scaleY(-1)}:host([is-expanded]) .dropdown-menu--list{display:flex}:host(.dropdown-menu--align-list--top-left) .dropdown-menu--list{left:0;top:calc(100% + 0.8rem)}:host(.dropdown-menu--align-list--top-right) .dropdown-menu--list{right:0;top:calc(100% + 0.8rem)}:host(.dropdown-menu--align-list--bottom-left) .dropdown-menu--list{left:0;bottom:calc(100% + 0.8rem)}:host(.dropdown-menu--align-list--bottom-right) .dropdown-menu--list{right:0;bottom:calc(100% + 0.8rem)}";
const WinkDropdownMenuTelenetStyle0 = dropdownMenuTelenetCss;
const DropdownMenu = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class DropdownMenu extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.heading = 'default-1';
    this.isExpanded = false;
    this.dropdownTabIndex = 1;
    this.itemSelected = undefined;
    this.listPosition = DROPDOWN_ALIGN.topLeft;
    this.focusableItem = NaN;
  }
  get host() {
    return this;
  }
  componentDidLoad() {
    this.setPosition();
    for (let i = 0; i < this.getDropdownItems().length; i++) {
      if (this.getDropdownItems()[i].innerText === this.itemSelected) {
        this.getDropdownItems()[i].classList.add('active');
      }
    }
  }
  handleKeyDown(ev) {
    switch (ev.key) {
      case ' ':
      case 'Enter':
        {
          const element = ev?.target;
          if (element.tagName.toUpperCase() === 'WINK-LINK') {
            element?.shadowRoot?.querySelector('a')?.click();
          } else {
            this.toggleDropdown(ev);
          }
          break;
        }
      case 'Tab':
        {
          if (ev.target === this.getDropdownItems()[this.getDropdownItems().length - 1]) {
            this.toggleDropdown(ev);
          }
          break;
        }
      case 'ArrowDown':
        {
          if (Number.isNaN(this.focusableItem) || this.focusableItem === this.getDropdownItems().length - 1) {
            this.focusableItem = 0;
          } else {
            this.focusableItem++;
          }
          this.focusOnItem(this.focusableItem);
          break;
        }
      case 'ArrowUp':
        {
          if (!this.focusableItem || this.focusableItem === -1) {
            this.focusableItem = this.getDropdownItems().length - 1;
          } else {
            this.focusableItem--;
          }
          this.focusOnItem(this.focusableItem);
          break;
        }
      case 'Escape':
        {
          this.isExpanded = false;
          this.host.shadowRoot?.querySelector('button')?.focus();
          break;
        }
      case 'Home':
        {
          this.focusableItem = 0;
          this.focusOnItem(this.focusableItem);
          break;
        }
      case 'End':
        {
          this.focusableItem = this.getDropdownItems().length - 1;
          this.focusOnItem(this.focusableItem);
          break;
        }
    }
  }
  focusOnItem(focusItem) {
    const itemToFocus = this.getDropdownItems()[focusItem];
    if (itemToFocus instanceof _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement) {
      return itemToFocus?.shadowRoot?.querySelector('a')?.focus();
    }
  }
  getDropdownItems() {
    return this.host.querySelectorAll('wink-link');
  }
  toggleDropdown = _e => {
    this.setPosition();
    this.isExpanded = !this.isExpanded;
  };
  setPosition = () => {
    const dropdownRect = this.host.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const spaceOnLeft = dropdownRect.left;
    const spaceOnRight = viewportWidth - dropdownRect.right;
    const spaceOnTop = dropdownRect.top;
    const spaceOnBottom = viewportHeight - dropdownRect.bottom;
    const positionX = Math.max(spaceOnLeft, spaceOnRight) === spaceOnRight ? 'left' : 'right';
    const positionY = Math.max(spaceOnTop, spaceOnBottom) === spaceOnBottom ? 'top' : 'bottom';
    this.listPosition = `${positionY}-${positionX}`;
  };
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, {
      key: '88fbb34e0b20c23d779fc73f705761149dcb19c0',
      class: `dropdown-menu--align-list--${this.listPosition}`,
      "is-expanded": this.isExpanded,
      onMouseDown: this.toggleDropdown,
      exportparts: "icon, icon-chevron-down-small"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("button", {
      key: '72d134a0d53203c6003a8da891c7bb85a5f1e753',
      class: "dropdown-menu--heading",
      tabindex: this.dropdownTabIndex
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("slot", {
      key: '427559f9fceb6bd78f61e84c3d06cacafd52985c',
      name: "dropdown-menu--avatar"
    }), this.heading, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: '477b64011bfef337fb58cecc1c1402e3a3b5ab6e',
      class: "dropdown-menu--chevron"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: '5dd905ae775fdfc695d61871a06525a90c753a0b',
      size: _icon_types_js__WEBPACK_IMPORTED_MODULE_0__.I.sm,
      icon: "chevron-down-small"
    }))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("ul", {
      key: 'a61a0687e6c2c7e7707a3a4cd6a1abdeb378b35c',
      class: "dropdown-menu--list"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("slot", {
      key: '65527a46e8fac48e64133f1367b91f02997cebb3'
    })));
  }
  static get style() {
    return {
      base: WinkDropdownMenuBaseStyle0,
      telenet: WinkDropdownMenuTelenetStyle0
    };
  }
}, [33, "wink-dropdown-menu", {
  "heading": [1],
  "isExpanded": [1028, "is-expanded"],
  "dropdownTabIndex": [2, "dropdown-tab-index"],
  "itemSelected": [1, "item-selected"],
  "listPosition": [32],
  "focusableItem": [32]
}, [[1, "keydown", "handleKeyDown"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-dropdown-menu", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-dropdown-menu":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, DropdownMenu);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}


/***/ }),

/***/ 78529:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/form-label.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ FORM_LABEL_RENDITION),
/* harmony export */   a: () => (/* binding */ FormLabel),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);

const FORM_LABEL_RENDITION = {
  default: 'default',
  subComponent: 'subComponent'
};
const formLabelBaseCss = ".sr-only.sc-wink-form-label-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-form-label-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-form-label-base-h{display:flex;width:100%;justify-content:space-between}.sc-wink-form-label-base-h .label--content-wrapper.sc-wink-form-label-base{display:flex;flex-direction:column}.sc-wink-form-label-base-h .label--text.sc-wink-form-label-base{color:var(--semantic-color-text-default);font-size:1.6rem;line-height:2.4rem;background-color:transparent}@media only screen and (max-width: calc(74.5em - 1px)){.sc-wink-form-label-base-h .label--text.sc-wink-form-label-base{font-size:1.4rem;line-height:2rem}}.sc-wink-form-label-base-h .label--helper.sc-wink-form-label-base{color:var(--semantic-color-text-subtlest);font-size:1.4rem;line-height:2rem}@media only screen and (max-width: calc(74.5em - 1px)){.sc-wink-form-label-base-h .label--helper.sc-wink-form-label-base{font-size:1.2rem;line-height:1.6rem}}.sc-wink-form-label-base-h .label--optional.sc-wink-form-label-base{font-size:1.4rem;line-height:2rem;color:var(--semantic-color-text-subtlest)}.label--subcomponent.sc-wink-form-label-base-h .label--text.sc-wink-form-label-base{color:var(--semantic-color-text-default);font-size:1.8rem;line-height:2.8rem}@media only screen and (max-width: calc(74.5em - 1px)){.label--subcomponent.sc-wink-form-label-base-h .label--text.sc-wink-form-label-base{font-size:1.6rem;line-height:2rem}}.label--subcomponent.sc-wink-form-label-base-h .label--helper.sc-wink-form-label-base{color:var(--semantic-color-text-subtlest);font-size:1.4rem;line-height:2rem}@media only screen and (max-width: calc(74.5em - 1px)){.label--subcomponent.sc-wink-form-label-base-h .label--helper.sc-wink-form-label-base{font-size:1.2rem;line-height:1.6rem}}.label--disabled.sc-wink-form-label-base-h{opacity:calc(var(--semantic-opacity-disabled) / 10)}";
const WinkFormLabelBaseStyle0 = formLabelBaseCss;
const formLabelTelenetCss = ".sr-only.sc-wink-form-label-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-form-label-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-form-label-telenet-h{display:flex;width:100%;justify-content:space-between}.sc-wink-form-label-telenet-h .label--content-wrapper.sc-wink-form-label-telenet{display:flex;flex-direction:column}.sc-wink-form-label-telenet-h .label--text.sc-wink-form-label-telenet{color:var(--semantic-color-text-default);font-size:1.6rem;line-height:2.4rem;background-color:transparent}@media only screen and (max-width: calc(74.5em - 1px)){.sc-wink-form-label-telenet-h .label--text.sc-wink-form-label-telenet{font-size:1.4rem;line-height:2rem}}.sc-wink-form-label-telenet-h .label--helper.sc-wink-form-label-telenet{color:var(--semantic-color-text-subtlest);font-size:1.4rem;line-height:2rem}@media only screen and (max-width: calc(74.5em - 1px)){.sc-wink-form-label-telenet-h .label--helper.sc-wink-form-label-telenet{font-size:1.2rem;line-height:1.6rem}}.sc-wink-form-label-telenet-h .label--optional.sc-wink-form-label-telenet{font-size:1.4rem;line-height:2rem;color:var(--semantic-color-text-subtlest)}.label--subcomponent.sc-wink-form-label-telenet-h .label--text.sc-wink-form-label-telenet{color:var(--semantic-color-text-default);font-size:1.8rem;line-height:2.8rem}@media only screen and (max-width: calc(74.5em - 1px)){.label--subcomponent.sc-wink-form-label-telenet-h .label--text.sc-wink-form-label-telenet{font-size:1.6rem;line-height:2rem}}.label--subcomponent.sc-wink-form-label-telenet-h .label--helper.sc-wink-form-label-telenet{color:var(--semantic-color-text-subtlest);font-size:1.4rem;line-height:2rem}@media only screen and (max-width: calc(74.5em - 1px)){.label--subcomponent.sc-wink-form-label-telenet-h .label--helper.sc-wink-form-label-telenet{font-size:1.2rem;line-height:1.6rem}}.label--disabled.sc-wink-form-label-telenet-h{opacity:calc(var(--semantic-opacity-disabled) / 10)}";
const WinkFormLabelTelenetStyle0 = formLabelTelenetCss;
const FormLabel = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.proxyCustomElement)(class FormLabel extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.label = '';
    this.helper = undefined;
    this.labelId = undefined;
    this.helperId = undefined;
    this.rendition = FORM_LABEL_RENDITION.default;
    this.optionalText = 'Optioneel';
    this.showOptional = false;
    this.isDisabled = false;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.Host, {
      key: '5dfbd831a7ebb558e65cb7ae7e9746124d52f7b5',
      class: `${this.isDisabled ? 'label--disabled' : ''} label--${this.rendition}`.toLocaleLowerCase()
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", {
      key: 'aae45fa31c41b7dab0483d2dddbaf879ff4f3ca8',
      class: "label--content-wrapper"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", {
      key: 'fae2d7ebaa990faec70d1e5e118459f343d543f2',
      class: "label--text"
    }, this.label), this.helper && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", {
      class: "label--helper",
      id: this.helperId
    }, this.helper)), this.showOptional && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("span", {
      class: "label--optional"
    }, this.optionalText));
  }
  static get style() {
    return {
      base: WinkFormLabelBaseStyle0,
      telenet: WinkFormLabelTelenetStyle0
    };
  }
}, [34, "wink-form-label", {
  "label": [1],
  "helper": [1],
  "labelId": [1, "label-id"],
  "helperId": [1, "helper-id"],
  "rendition": [1],
  "optionalText": [1, "optional-text"],
  "showOptional": [4, "show-optional"],
  "isDisabled": [4, "is-disabled"]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-form-label"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, FormLabel);
        }
        break;
    }
  });
}


/***/ }),

/***/ 45477:
/*!******************************************************!*\
  !*** ./libs/foundation/wink/dist/components/icon.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ Icon),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _icon_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.types.js */ 98681);


const iconBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-flex;place-content:center;width:-moz-fit-content;width:fit-content;aspect-ratio:1/1;font-size:1rem}:host i{display:inline-block;text-align:center;font-size:2.4rem;color:var(--wink-icon-color, var(--semantic-color-icon-default))}:host i:before{display:block}:host i.primary{color:var(--wink-icon-color, var(--semantic-color-icon-on-brand));background-color:var(--wink-icon-bg-color, var(--semantic-color-background-icon-primary))}:host i.secondary{color:var(--wink-icon-color, var(--semantic-color-icon-default));background-color:var(--wink-icon-bg-color, var(--semantic-color-background-icon-secondary))}:host i.transparent{color:var(--wink-icon-color, var(--semantic-color-icon-on-brand));background-color:var(--wink-icon-bg-color, var(--semantic-color-background-icon-transparant))}:host i.sm{font-size:calc(var(--semantic-icon-sm) * 1rem);width:calc(var(--semantic-icon-sm) * 1rem)}:host i.md{font-size:calc(var(--semantic-icon-md) * 1rem);width:calc(var(--semantic-icon-md) * 1rem)}:host i.lg{font-size:calc(var(--semantic-icon-lg) * 1rem);width:calc(var(--semantic-icon-lg) * 1rem)}:host i.xl{font-size:calc(var(--semantic-icon-xl) * 1rem);width:calc(var(--semantic-icon-xl) * 1rem)}:host i.backdrop{mask:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='109' height='109' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M105.9 20C104.8 11.2 98 4.2 89.2 3.2c0 0-14-2.2-34.7-2.2-20.6 0-34.7 2.2-34.7 2.2-8.8 1-15.6 8-16.7 16.8C3.1 20 1 35.8 1 54.5S3.1 89 3.1 89c1.1 8.8 7.9 15.8 16.7 16.8 0 0 14 2.2 34.7 2.2 20.6 0 34.7-2.2 34.7-2.2 8.8-1.1 15.6-8 16.7-16.8 0 0 2.1-15.8 2.1-34.5S105.9 20 105.9 20' fill-rule='evenodd'/%3E%3C/svg%3E\");mask-size:contain;mask-repeat:no-repeat}:host i.backdrop.sm{padding:calc(var(--semantic-spacing-3xs) * 1rem)}:host i.backdrop.md{padding:calc(var(--semantic-spacing-xs) * 1rem)}:host i.backdrop.lg{padding:calc(var(--semantic-spacing-xs) * 1rem)}:host i.backdrop.xl{padding:calc(var(--semantic-spacing-xs) * 1rem)}@media only screen and (min-width: 36em){:host i.backdrop.xl{padding:calc(var(--semantic-spacing-md) * 1rem)}}";
const WinkIconBaseStyle0 = iconBaseCss;
const iconTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-flex;place-content:center;width:-moz-fit-content;width:fit-content;aspect-ratio:1/1;font-size:1rem}:host i{display:inline-block;text-align:center;font-size:2.4rem;color:var(--wink-icon-color, var(--semantic-color-icon-default))}:host i:before{display:block}:host i.primary{color:var(--wink-icon-color, var(--semantic-color-icon-on-brand));background-color:var(--wink-icon-bg-color, var(--semantic-color-background-icon-primary))}:host i.secondary{color:var(--wink-icon-color, var(--semantic-color-icon-default));background-color:var(--wink-icon-bg-color, var(--semantic-color-background-icon-secondary))}:host i.transparent{color:var(--wink-icon-color, var(--semantic-color-icon-on-brand));background-color:var(--wink-icon-bg-color, var(--semantic-color-background-icon-transparant))}:host i.sm{font-size:calc(var(--semantic-icon-sm) * 1rem);width:calc(var(--semantic-icon-sm) * 1rem)}:host i.md{font-size:calc(var(--semantic-icon-md) * 1rem);width:calc(var(--semantic-icon-md) * 1rem)}:host i.lg{font-size:calc(var(--semantic-icon-lg) * 1rem);width:calc(var(--semantic-icon-lg) * 1rem)}:host i.xl{font-size:calc(var(--semantic-icon-xl) * 1rem);width:calc(var(--semantic-icon-xl) * 1rem)}:host i.backdrop{mask:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='109' height='109' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M105.9 20C104.8 11.2 98 4.2 89.2 3.2c0 0-14-2.2-34.7-2.2-20.6 0-34.7 2.2-34.7 2.2-8.8 1-15.6 8-16.7 16.8C3.1 20 1 35.8 1 54.5S3.1 89 3.1 89c1.1 8.8 7.9 15.8 16.7 16.8 0 0 14 2.2 34.7 2.2 20.6 0 34.7-2.2 34.7-2.2 8.8-1.1 15.6-8 16.7-16.8 0 0 2.1-15.8 2.1-34.5S105.9 20 105.9 20' fill-rule='evenodd'/%3E%3C/svg%3E\");mask-size:contain;mask-repeat:no-repeat}:host i.backdrop.sm{padding:calc(var(--semantic-spacing-3xs) * 1rem)}:host i.backdrop.md{padding:calc(var(--semantic-spacing-xs) * 1rem)}:host i.backdrop.lg{padding:calc(var(--semantic-spacing-xs) * 1rem)}:host i.backdrop.xl{padding:calc(var(--semantic-spacing-xs) * 1rem)}@media only screen and (min-width: 36em){:host i.backdrop.xl{padding:calc(var(--semantic-spacing-md) * 1rem)}}";
const WinkIconTelenetStyle0 = iconTelenetCss;
const Icon = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class Icon extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.appearance = _icon_types_js__WEBPACK_IMPORTED_MODULE_0__.a.default;
    this.size = _icon_types_js__WEBPACK_IMPORTED_MODULE_0__.I.md;
    this.icon = 'bell';
    this.hasBackdrop = false;
  }
  componentWillRender() {
    this.hasBackdrop = this.appearance !== 'default' && Object.values(_icon_types_js__WEBPACK_IMPORTED_MODULE_0__.a).includes(this.appearance);
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: 'bd4199183f03ccaca1e483e179f0dae4d5c11b6f',
      exportparts: `icon, icon-${this.icon}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("i", {
      key: 'a42f47cc73e52a702175c1f62efd1ce44483b4f6',
      class: {
        [this.size]: true,
        [this.appearance]: true,
        ['backdrop']: this.hasBackdrop
      },
      part: `icon icon-${this.icon}`,
      "aria-hidden": "true"
    }));
  }
  static get style() {
    return {
      base: WinkIconBaseStyle0,
      telenet: WinkIconTelenetStyle0
    };
  }
}, [33, "wink-icon", {
  "appearance": [1],
  "size": [1],
  "icon": [1],
  "hasBackdrop": [32]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-icon":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Icon);
        }
        break;
    }
  });
}


/***/ }),

/***/ 98681:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/icon.types.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ ICON_SIZES),
/* harmony export */   a: () => (/* binding */ ICON_TYPES),
/* harmony export */   b: () => (/* binding */ ICON_TYPES_BASIS)
/* harmony export */ });
/* harmony import */ var _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.types.js */ 7988);

const ICON_TYPES_BASIS = {
  default: 'default',
  primary: 'primary',
  secondary: 'secondary'
};
const ICON_TYPES = {
  ...ICON_TYPES_BASIS,
  transparent: 'transparent'
};
const ICON_SIZES = {
  sm: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.sm,
  md: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.md,
  lg: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.lg,
  xl: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.xl
};


/***/ }),

/***/ 19766:
/*!***********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/indicator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ Indicator),
/* harmony export */   a: () => (/* binding */ INDICATOR_DIRECTIONS),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _button_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./button.types.js */ 5074);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);



const INDICATOR_DIRECTIONS = {
  left: 'left',
  right: 'right',
  up: 'up',
  down: 'down'
};
const indicatorBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block}:host .wrapper{filter:drop-shadow(0rem 0.4rem 0.4rem var(--semantic-color-background-surface-bold-pressed))}:host .wrapper .indicator{background-color:var(--semantic-color-text-inverse-on-brand);padding:calc(var(--semantic-spacing-3xs) * 1rem);position:relative;display:flex;flex-direction:column;align-items:center;transition:transform 0.1s ease-in-out}:host .wrapper .indicator:hover{transform:scale(1.1)}:host .wrapper .indicator wink-icon{--wink-icon-color:var(--semantic-color-icon-on-brand);height:auto}";
const WinkIndicatorBaseStyle0 = indicatorBaseCss;
const indicatorTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host img{mask:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='109' height='109' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M105.9 20C104.8 11.2 98 4.2 89.2 3.2c0 0-14-2.2-34.7-2.2-20.6 0-34.7 2.2-34.7 2.2-8.8 1-15.6 8-16.7 16.8C3.1 20 1 35.8 1 54.5S3.1 89 3.1 89c1.1 8.8 7.9 15.8 16.7 16.8 0 0 14 2.2 34.7 2.2 20.6 0 34.7-2.2 34.7-2.2 8.8-1.1 15.6-8 16.7-16.8 0 0 2.1-15.8 2.1-34.5S105.9 20 105.9 20' fill-rule='evenodd'/%3E%3C/svg%3E\");mask-size:contain;mask-repeat:no-repeat}:host{display:block}:host .wrapper{filter:drop-shadow(0rem 0.4rem 0.4rem var(--semantic-color-background-surface-bold-pressed))}:host .wrapper .indicator{background-color:var(--semantic-color-text-inverse-on-brand);padding:calc(var(--semantic-spacing-3xs) * 1rem);position:relative;display:flex;flex-direction:column;align-items:center;transition:transform 0.1s ease-in-out}:host .wrapper .indicator:hover{transform:scale(1.1)}:host .wrapper .indicator wink-icon{--wink-icon-color:var(--semantic-color-icon-on-brand);height:auto}:host .indicator{mask:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='109' height='109' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M105.9 20C104.8 11.2 98 4.2 89.2 3.2c0 0-14-2.2-34.7-2.2-20.6 0-34.7 2.2-34.7 2.2-8.8 1-15.6 8-16.7 16.8C3.1 20 1 35.8 1 54.5S3.1 89 3.1 89c1.1 8.8 7.9 15.8 16.7 16.8 0 0 14 2.2 34.7 2.2 20.6 0 34.7-2.2 34.7-2.2 8.8-1.1 15.6-8 16.7-16.8 0 0 2.1-15.8 2.1-34.5S105.9 20 105.9 20' fill-rule='evenodd'/%3E%3C/svg%3E\");mask-size:contain;mask-repeat:no-repeat}";
const WinkIndicatorTelenetStyle0 = indicatorTelenetCss;
const Indicator = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class Indicator extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.direction = INDICATOR_DIRECTIONS.right;
    this.size = _button_types_js__WEBPACK_IMPORTED_MODULE_0__.b.sm;
  }
  iconsNamesMap = new Map([[INDICATOR_DIRECTIONS.left, 'chevron-left-small'], [INDICATOR_DIRECTIONS.right, 'chevron-right-small'], [INDICATOR_DIRECTIONS.up, 'chevron-up-small'], [INDICATOR_DIRECTIONS.down, 'chevron-down-small']]);
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, {
      key: '0bcc73c74dde8f3cfa2fb6baa8e25fa477e4f333'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: '45252ca01701b39273447bd566532dd751708c98',
      class: "wrapper"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: 'ee32f1bce19a43e70632b20179d95b08ae60d997',
      class: "indicator"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: '5d832aa22af22411e1f171d8c9d1f4c5bfc06654',
      appearance: "default",
      size: this.size,
      icon: this.iconsNamesMap.get(this.direction)
    }))));
  }
  static get style() {
    return {
      base: WinkIndicatorBaseStyle0,
      telenet: WinkIndicatorTelenetStyle0
    };
  }
}, [32, "wink-indicator", {
  "direction": [1],
  "size": [1]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-indicator", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-indicator":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Indicator);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}


/***/ }),

/***/ 75098:
/*!*******************************************************!*\
  !*** ./libs/foundation/wink/dist/components/input.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ Input),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _input_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./input.types.js */ 17663);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ 69900);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./form-label.js */ 78529);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _validation_message_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./validation-message.js */ 46024);







const inputBaseCss = ".sr-only.sc-wink-input-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-input-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-input-base-h{display:flex;flex-direction:column;width:100%}.sc-wink-input-base-h .input-wrapper.sc-wink-input-base{display:flex;width:100%}.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base{--wink-icon-bg-color:transparent;--wink-icon-color:var(--semantic-color-text-subtlest);position:relative;width:100%}.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base wink-icon.sc-wink-input-base{position:absolute;top:calc(var(--semantic-spacing-2xs) * 1rem);right:calc(var(--semantic-spacing-2xs) * 1rem);cursor:pointer;pointer-events:none}.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base wink-icon.disabled.sc-wink-input-base{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base input.sc-wink-input-base{font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:calc(var(--semantic-typography-font-size-desktop-sm) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-sm) * 1rem)}.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base input.sc-wink-input-base::-webkit-calendar-picker-indicator{opacity:0}.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base input.sc-wink-input-base::-webkit-datetime-edit-day-field:focus,.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base input.sc-wink-input-base::-webkit-datetime-edit-month-field:focus,.sc-wink-input-base-h .input-wrapper-date.sc-wink-input-base input.sc-wink-input-base::-webkit-datetime-edit-year-field:focus{background-color:var(--semantic-color-background-surface-system-informative)}.sc-wink-input-base-h .input.sc-wink-input-base{width:100%;box-sizing:border-box;border-radius:0;border:calc(var(--wink-input--border-width, var(--semantic-border-md)) * 1rem) solid;border-color:var(--semantic-color-border-input-default);color:var(--semantic-color-text-default);background-color:var(--wink-input--bgc, --semantic-color-background-canvas-default)}.sc-wink-input-base-h .input.sc-wink-input-base,.sc-wink-input-base-h .input-affix.sc-wink-input-base{padding-top:var(--wink-input--pt, calc(var(--semantic-spacing-sm) * 1rem));padding-bottom:var(--wink-input--pb, calc(var(--semantic-spacing-sm) * 1rem));padding-left:calc(var(--semantic-spacing-md) * 1rem);padding-right:calc(var(--semantic-spacing-md) * 1rem);font-size:var(--wink-input--fs, 1.8rem);line-height:var(--wink-input--lh, 2.4rem)}.sc-wink-input-base-h .input-affix.sc-wink-input-base{display:block;min-width:3.2rem;flex-shrink:0;text-align:center;border-radius:0;border:calc(var(--semantic-border-md) * 1rem) solid;border-color:var(--semantic-color-border-input-default);color:var(--semantic-color-text-subtlest);background:var(--semantic-color-border-subtle)}.sc-wink-input-base-h .input-affix-prefix.sc-wink-input-base{border-right:calc(var(--semantic-border-none) * 1rem)}.sc-wink-input-base-h .input-affix-postfix.sc-wink-input-base{border-left:calc(var(--semantic-border-none) * 1rem)}.sc-wink-input-base-h .input.sc-wink-input-base::placeholder{color:var(--semantic-color-text-subtlest)}.sc-wink-input-base-h .input.sc-wink-input-base:hover{border-color:var(--wink-input--hover--bgc, --semantic-color-border-highlight);border:calc(var(--wink-input--hover--border-width, var(--semantic-border-md)) * 1rem) solid}.sc-wink-input-base-h .input.sc-wink-input-base:focus{z-index:1;border-radius:0.1rem;outline-offset:0.1rem;outline:calc(var(--semantic-border-md) * 1rem) solid var(--semantic-color-border-focus);border-color:var(--semantic-color-border-highlight);border:calc(var(--wink-input--active--border-width, var(--semantic-border-md)) * 1rem) solid}.sc-wink-input-base-h .input.sc-wink-input-base:read-only:not(:disabled),.sc-wink-input-base-h .input-affix.input-affix-readonly.sc-wink-input-base{background-color:transparent;border-color:transparent;border-left-width:0;border-right-width:0;padding-left:calc(var(--semantic-spacing-none) * 1rem);padding-right:calc(var(--semantic-spacing-none) * 1rem);-webkit-user-select:none;user-select:none;pointer-events:none}.sc-wink-input-base-h .input-affix.input-affix-readonly.input-affix-prefix.sc-wink-input-base{padding-right:calc(var(--semantic-spacing-xs) * 1rem)}.sc-wink-input-base-h .input-affix.input-affix-readonly.input-affix-postfix.sc-wink-input-base{padding-left:calc(var(--semantic-spacing-xs) * 1rem)}.sc-wink-input-base-h .input.sc-wink-input-base:disabled,.sc-wink-input-base-h .input-affix.input-affix-disabled.sc-wink-input-base{opacity:0.4;cursor:not-allowed;-webkit-user-select:none;user-select:none;background-color:var(--semantic-color-background-surface-neutral-default)}.sc-wink-input-base-h .input.sc-wink-input-base:disabled:hover,.sc-wink-input-base-h .input-affix.input-affix-disabled.sc-wink-input-base:hover{border-color:var(--semantic-color-border-input-default)}.sc-wink-input-base-h .input.invalid.sc-wink-input-base:not(:read-only){border-color:var(--semantic-color-border-error)}.sc-wink-input-base-h .input-with-icon-button.sc-wink-input-base{position:relative;align-items:center;justify-content:center}.sc-wink-input-base-h .input-with-icon-button.input-with-icon-button-left.sc-wink-input-base .input.sc-wink-input-base{padding-left:var(--wink-input--icon-button-left--pl, 4.8rem)}.sc-wink-input-base-h .input-with-icon-button.input-with-icon-button-left.sc-wink-input-base .input-icon-button-left.sc-wink-input-base{left:var(--wink-input--icon-button-left--l, calc(var(--semantic-spacing-xs) * 1rem))}.sc-wink-input-base-h .input-with-icon-button.input-with-icon-button-right.sc-wink-input-base .input.sc-wink-input-base{padding-right:var(--wink-input--icon-button-right--pr, 4.8rem)}.sc-wink-input-base-h .input-with-icon-button.input-with-icon-button-right.sc-wink-input-base .input-icon-button-right.sc-wink-input-base{right:var(--wink-input--icon-button-right--r, calc(var(--semantic-spacing-xs) * 1rem))}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base{position:absolute;top:0;bottom:0;display:flex;align-items:center;justify-content:center;z-index:2}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base{display:flex;cursor:pointer;border-width:0;border-radius:0.4rem;background:transparent;padding:var(--wink-input--icon-button-padding, calc(var(--semantic-spacing-2xs) * 1rem))}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base wink-icon.sc-wink-input-base{--wink-icon-color:var(--wink-input--icon-color, var(--semantic-color-icon-subtle))}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base:hover{background:var(--semantic-color-border-hover)}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base:hover wink-icon.sc-wink-input-base{--wink-icon-color:var(--semantic-color-icon-default)}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base:active{background:var(--wink-input--active--bgc, --semantic-color-background-surface-neutral-pressed)}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base:focus,.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem;z-index:1;border-color:var(--semantic-color-border-button-default);background:var(--wink-input--focus--bgc, var(--semantic-color-background-surface-neutral-pressed))}.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base:focus wink-icon.sc-wink-input-base,.sc-wink-input-base-h .input-icon-button.sc-wink-input-base button.sc-wink-input-base:focus-visible wink-icon.sc-wink-input-base{--wink-icon-color:var(--semantic-color-icon-default-on-action)}.sc-wink-input-base-h wink-form-label.sc-wink-input-base{margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}.sc-wink-input-base-h .label-disabled.sc-wink-input-base{opacity:0.4;cursor:not-allowed;-webkit-user-select:none;user-select:none}.sc-wink-input-base-h .error-msg.sc-wink-input-base{color:var(--semantic-color-text-error);display:flex;align-items:flex-start;margin-top:4px;width:100%;font-size:14px;line-height:20px;font-weight:normal}.sc-wink-input-base-h .error-msg.sc-wink-input-base .error-label.sc-wink-input-base{margin-top:2px}.sc-wink-input-base-h .error-msg.sc-wink-input-base wink-icon.sc-wink-input-base{--wink-icon-color:var(--semantic-color-text-error);margin-right:4px}[appearance=search].sc-wink-input-base-h{--wink-input--icon-color:var(--semantic-color-icon-subtle);--wink-input--bgc:var(--semantic-color-background-surface-bold-default);--wink-input--border-width:calc(var(--semantic-border-none) * 1rem);--wink-input--hover--bgc:var(--semantic-color-background-surface-bold-hovered);--wink-input--hover--border-width:calc(var(--semantic-border-none) * 1rem);--wink-input--active--bgc:var(--semantic-color-background-surface-bold-pressed);--wink-input--active--border-width:calc(var(--semantic-border-none) * 1rem);--wink-input--focus--bgc:var(--semantic-color-background-surface-subtle-pressed)}[size=sm].sc-wink-input-base-h{--wink-input--fs:1.6rem;--wink-input--lh:2.4rem;--wink-input--pt:calc(var(--semantic-spacing-2xs) * 1rem);--wink-input--pb:calc(var(--semantic-spacing-2xs) * 1rem);--wink-input--icon-button-padding:calc(var(--semantic-spacing-3xs) * 1rem);--wink-input--icon-button-left--pl:calc(var(--semantic-spacing-xl) * 1rem);--wink-input--icon-button-left--l:calc(var(--semantic-spacing-3xs) * 1rem);--wink-input--icon-button-right--pr:calc(var(--semantic-spacing-xl) * 1rem);--wink-input--icon-button-right--r:calc(var(--semantic-spacing-3xs) * 1rem)}";
const WinkInputBaseStyle0 = inputBaseCss;
const inputTelenetCss = ".sr-only.sc-wink-input-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-input-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-input-telenet-h{display:flex;flex-direction:column;width:100%}.sc-wink-input-telenet-h .input-wrapper.sc-wink-input-telenet{display:flex;width:100%}.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet{--wink-icon-bg-color:transparent;--wink-icon-color:var(--semantic-color-text-subtlest);position:relative;width:100%}.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet wink-icon.sc-wink-input-telenet{position:absolute;top:calc(var(--semantic-spacing-2xs) * 1rem);right:calc(var(--semantic-spacing-2xs) * 1rem);cursor:pointer;pointer-events:none}.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet wink-icon.disabled.sc-wink-input-telenet{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet input.sc-wink-input-telenet{font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:calc(var(--semantic-typography-font-size-desktop-sm) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-sm) * 1rem)}.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet input.sc-wink-input-telenet::-webkit-calendar-picker-indicator{opacity:0}.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet input.sc-wink-input-telenet::-webkit-datetime-edit-day-field:focus,.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet input.sc-wink-input-telenet::-webkit-datetime-edit-month-field:focus,.sc-wink-input-telenet-h .input-wrapper-date.sc-wink-input-telenet input.sc-wink-input-telenet::-webkit-datetime-edit-year-field:focus{background-color:var(--semantic-color-background-surface-system-informative)}.sc-wink-input-telenet-h .input.sc-wink-input-telenet{width:100%;box-sizing:border-box;border-radius:0;border:calc(var(--wink-input--border-width, var(--semantic-border-md)) * 1rem) solid;border-color:var(--semantic-color-border-input-default);color:var(--semantic-color-text-default);background-color:var(--wink-input--bgc, --semantic-color-background-canvas-default)}.sc-wink-input-telenet-h .input.sc-wink-input-telenet,.sc-wink-input-telenet-h .input-affix.sc-wink-input-telenet{padding-top:var(--wink-input--pt, calc(var(--semantic-spacing-sm) * 1rem));padding-bottom:var(--wink-input--pb, calc(var(--semantic-spacing-sm) * 1rem));padding-left:calc(var(--semantic-spacing-md) * 1rem);padding-right:calc(var(--semantic-spacing-md) * 1rem);font-size:var(--wink-input--fs, 1.8rem);line-height:var(--wink-input--lh, 2.4rem)}.sc-wink-input-telenet-h .input-affix.sc-wink-input-telenet{display:block;min-width:3.2rem;flex-shrink:0;text-align:center;border-radius:0;border:calc(var(--semantic-border-md) * 1rem) solid;border-color:var(--semantic-color-border-input-default);color:var(--semantic-color-text-subtlest);background:var(--semantic-color-border-subtle)}.sc-wink-input-telenet-h .input-affix-prefix.sc-wink-input-telenet{border-right:calc(var(--semantic-border-none) * 1rem)}.sc-wink-input-telenet-h .input-affix-postfix.sc-wink-input-telenet{border-left:calc(var(--semantic-border-none) * 1rem)}.sc-wink-input-telenet-h .input.sc-wink-input-telenet::placeholder{color:var(--semantic-color-text-subtlest)}.sc-wink-input-telenet-h .input.sc-wink-input-telenet:hover{border-color:var(--wink-input--hover--bgc, --semantic-color-border-highlight);border:calc(var(--wink-input--hover--border-width, var(--semantic-border-md)) * 1rem) solid}.sc-wink-input-telenet-h .input.sc-wink-input-telenet:focus{z-index:1;border-radius:0.1rem;outline-offset:0.1rem;outline:calc(var(--semantic-border-md) * 1rem) solid var(--semantic-color-border-focus);border-color:var(--semantic-color-border-highlight);border:calc(var(--wink-input--active--border-width, var(--semantic-border-md)) * 1rem) solid}.sc-wink-input-telenet-h .input.sc-wink-input-telenet:read-only:not(:disabled),.sc-wink-input-telenet-h .input-affix.input-affix-readonly.sc-wink-input-telenet{background-color:transparent;border-color:transparent;border-left-width:0;border-right-width:0;padding-left:calc(var(--semantic-spacing-none) * 1rem);padding-right:calc(var(--semantic-spacing-none) * 1rem);-webkit-user-select:none;user-select:none;pointer-events:none}.sc-wink-input-telenet-h .input-affix.input-affix-readonly.input-affix-prefix.sc-wink-input-telenet{padding-right:calc(var(--semantic-spacing-xs) * 1rem)}.sc-wink-input-telenet-h .input-affix.input-affix-readonly.input-affix-postfix.sc-wink-input-telenet{padding-left:calc(var(--semantic-spacing-xs) * 1rem)}.sc-wink-input-telenet-h .input.sc-wink-input-telenet:disabled,.sc-wink-input-telenet-h .input-affix.input-affix-disabled.sc-wink-input-telenet{opacity:0.4;cursor:not-allowed;-webkit-user-select:none;user-select:none;background-color:var(--semantic-color-background-surface-neutral-default)}.sc-wink-input-telenet-h .input.sc-wink-input-telenet:disabled:hover,.sc-wink-input-telenet-h .input-affix.input-affix-disabled.sc-wink-input-telenet:hover{border-color:var(--semantic-color-border-input-default)}.sc-wink-input-telenet-h .input.invalid.sc-wink-input-telenet:not(:read-only){border-color:var(--semantic-color-border-error)}.sc-wink-input-telenet-h .input-with-icon-button.sc-wink-input-telenet{position:relative;align-items:center;justify-content:center}.sc-wink-input-telenet-h .input-with-icon-button.input-with-icon-button-left.sc-wink-input-telenet .input.sc-wink-input-telenet{padding-left:var(--wink-input--icon-button-left--pl, 4.8rem)}.sc-wink-input-telenet-h .input-with-icon-button.input-with-icon-button-left.sc-wink-input-telenet .input-icon-button-left.sc-wink-input-telenet{left:var(--wink-input--icon-button-left--l, calc(var(--semantic-spacing-xs) * 1rem))}.sc-wink-input-telenet-h .input-with-icon-button.input-with-icon-button-right.sc-wink-input-telenet .input.sc-wink-input-telenet{padding-right:var(--wink-input--icon-button-right--pr, 4.8rem)}.sc-wink-input-telenet-h .input-with-icon-button.input-with-icon-button-right.sc-wink-input-telenet .input-icon-button-right.sc-wink-input-telenet{right:var(--wink-input--icon-button-right--r, calc(var(--semantic-spacing-xs) * 1rem))}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet{position:absolute;top:0;bottom:0;display:flex;align-items:center;justify-content:center;z-index:2}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet{display:flex;cursor:pointer;border-width:0;border-radius:0.4rem;background:transparent;padding:var(--wink-input--icon-button-padding, calc(var(--semantic-spacing-2xs) * 1rem))}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet wink-icon.sc-wink-input-telenet{--wink-icon-color:var(--wink-input--icon-color, var(--semantic-color-icon-subtle))}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet:hover{background:var(--semantic-color-border-hover)}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet:hover wink-icon.sc-wink-input-telenet{--wink-icon-color:var(--semantic-color-icon-default)}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet:active{background:var(--wink-input--active--bgc, --semantic-color-background-surface-neutral-pressed)}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet:focus,.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem;z-index:1;border-color:var(--semantic-color-border-button-default);background:var(--wink-input--focus--bgc, var(--semantic-color-background-surface-neutral-pressed))}.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet:focus wink-icon.sc-wink-input-telenet,.sc-wink-input-telenet-h .input-icon-button.sc-wink-input-telenet button.sc-wink-input-telenet:focus-visible wink-icon.sc-wink-input-telenet{--wink-icon-color:var(--semantic-color-icon-default-on-action)}.sc-wink-input-telenet-h wink-form-label.sc-wink-input-telenet{margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}.sc-wink-input-telenet-h .label-disabled.sc-wink-input-telenet{opacity:0.4;cursor:not-allowed;-webkit-user-select:none;user-select:none}.sc-wink-input-telenet-h .error-msg.sc-wink-input-telenet{color:var(--semantic-color-text-error);display:flex;align-items:flex-start;margin-top:4px;width:100%;font-size:14px;line-height:20px;font-weight:normal}.sc-wink-input-telenet-h .error-msg.sc-wink-input-telenet .error-label.sc-wink-input-telenet{margin-top:2px}.sc-wink-input-telenet-h .error-msg.sc-wink-input-telenet wink-icon.sc-wink-input-telenet{--wink-icon-color:var(--semantic-color-text-error);margin-right:4px}[appearance=search].sc-wink-input-telenet-h{--wink-input--icon-color:var(--semantic-color-icon-subtle);--wink-input--bgc:var(--semantic-color-background-surface-bold-default);--wink-input--border-width:calc(var(--semantic-border-none) * 1rem);--wink-input--hover--bgc:var(--semantic-color-background-surface-bold-hovered);--wink-input--hover--border-width:calc(var(--semantic-border-none) * 1rem);--wink-input--active--bgc:var(--semantic-color-background-surface-bold-pressed);--wink-input--active--border-width:calc(var(--semantic-border-none) * 1rem);--wink-input--focus--bgc:var(--semantic-color-background-surface-subtle-pressed)}[size=sm].sc-wink-input-telenet-h{--wink-input--fs:1.6rem;--wink-input--lh:2.4rem;--wink-input--pt:calc(var(--semantic-spacing-2xs) * 1rem);--wink-input--pb:calc(var(--semantic-spacing-2xs) * 1rem);--wink-input--icon-button-padding:calc(var(--semantic-spacing-3xs) * 1rem);--wink-input--icon-button-left--pl:calc(var(--semantic-spacing-xl) * 1rem);--wink-input--icon-button-left--l:calc(var(--semantic-spacing-3xs) * 1rem);--wink-input--icon-button-right--pr:calc(var(--semantic-spacing-xl) * 1rem);--wink-input--icon-button-right--r:calc(var(--semantic-spacing-3xs) * 1rem)}";
const WinkInputTelenetStyle0 = inputTelenetCss;
const Input = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.proxyCustomElement)(class Input extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.valueChanged = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.createEvent)(this, "valueChanged", 7);
    this.appearance = _input_types_js__WEBPACK_IMPORTED_MODULE_1__.a.default;
    this.value = '';
    this.inputId = undefined;
    this.name = undefined;
    this.type = _input_types_js__WEBPACK_IMPORTED_MODULE_1__.b.text;
    this.placeholder = '';
    this.isRequired = false;
    this.inputModeOption = _input_types_js__WEBPACK_IMPORTED_MODULE_1__.c.text;
    this.autocomplete = _input_types_js__WEBPACK_IMPORTED_MODULE_1__.d.off;
    this.enterkeyhintOption = _input_types_js__WEBPACK_IMPORTED_MODULE_1__.I.none;
    this.isReadonly = false;
    this.isDisabled = false;
    this.isAutofocused = false;
    this.step = undefined;
    this.minValue = undefined;
    this.maxValue = undefined;
    this.error = undefined;
    this.prefixValue = '';
    this.postfixValue = '';
    this.iconLeft = '';
    this.iconRight = '';
    this.showIconRight = true;
    this.inputWidth = 0;
    this.label = '';
    this.helper = '';
    this.optionalText = 'Optional';
    this.size = _input_types_js__WEBPACK_IMPORTED_MODULE_1__.e.md;
  }
  get host() {
    return this;
  }
  valueChanged;
  setValidation(errorMsg) {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (errorMsg) {
        _this.error = errorMsg;
      } else {
        _this.error = '';
      }
    })();
  }
  getLabelId() {
    return this.inputId + ':Label';
  }
  getHelperId() {
    return this.inputId + ':Helper';
  }
  getErrorMsgId() {
    return this.inputId + ':Error';
  }
  getAriaDescribedby() {
    return [this.label && this.getLabelId(), this.helper && this.getHelperId(), this.error && this.getErrorMsgId()].filter(item => typeof item === 'string' && item.trim().length > 0).join(' ');
  }
  get getLabel() {
    if (this.label) {
      return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.Fragment, null, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("label", {
        htmlFor: this.inputId,
        id: this.getLabelId(),
        class: {
          label: true,
          'label-disabled': this.isDisabled
        }
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("wink-form-label", {
        label: this.label,
        helper: this.helper,
        "helper-id": this.getHelperId(),
        "show-optional": !this.isRequired,
        "optional-text": this.optionalText
      })));
    }
  }
  get getPrefix() {
    if (this.prefixValue && !this.iconLeft) {
      return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.Fragment, null, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("div", {
        class: {
          'input-affix input-affix-prefix': true,
          'input-affix-disabled': this.isDisabled,
          'input-affix-readonly': this.isReadonly
        }
      }, this.prefixValue));
    }
  }
  get getPostfix() {
    if (this.postfixValue && !this.iconRight) {
      return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.Fragment, null, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("div", {
        class: {
          'input-affix input-affix-postfix': true,
          'input-affix-disabled': this.isDisabled,
          'input-affix-readonly': this.isReadonly
        }
      }, this.postfixValue));
    }
  }
  getReadOnlyLength(value) {
    if (this.isReadonly && value.length > 0) {
      this.inputWidth = this.type === _input_types_js__WEBPACK_IMPORTED_MODULE_1__.b.date ? value.length + 4 : value.length;
    } else {
      this.inputWidth = 0;
    }
  }
  showSearchBackSpaceIcon(value) {
    if (value.length === 0 && this.appearance === _input_types_js__WEBPACK_IMPORTED_MODULE_1__.a.search) {
      this.showIconRight = false;
    } else {
      this.showIconRight = true;
    }
  }
  handleChange(event) {
    this.value = event.target.value;
    this.showSearchBackSpaceIcon(this.value);
    this.getReadOnlyLength(this.value);
    if (this.valueChanged) {
      this.valueChanged.emit(this.value);
    }
  }
  handleRightIconClick() {
    const inputEl = this.host?.querySelector('input');
    if (inputEl?.classList.contains('input-password')) {
      const rightIconEl = this.host?.querySelector('.input-icon-button-right wink-icon');
      if (inputEl?.type === 'password') {
        inputEl.type = 'text';
        rightIconEl?.setAttribute('icon', 'eye-off');
      } else {
        inputEl.type = 'password';
        rightIconEl?.setAttribute('icon', 'eye');
      }
    }
  }
  getAttributes() {
    return {
      ...{
        id: this.inputId
      },
      ...{
        name: this.name
      },
      ...{
        type: this.type
      },
      ...{
        value: this.value
      },
      ...(this.placeholder && {
        placeholder: this.placeholder
      }),
      ...{
        'input-mode': this.inputModeOption
      },
      ...{
        autocomplete: this.autocomplete
      },
      ...(this.isAutofocused && {
        autofocus: this.isAutofocused
      }),
      ...{
        enterkeyhint: this.enterkeyhintOption
      },
      ...(this.isRequired && {
        required: this.isRequired
      }),
      ...(this.isDisabled && {
        disabled: this.isDisabled
      }),
      ...(this.isReadonly && {
        readonly: this.isReadonly
      }),
      'aria-describedby': this.getAriaDescribedby(),
      'aria-invalid': !!this.error,
      ...(this.minValue !== undefined && {
        min: this.minValue
      }),
      ...(this.maxValue !== undefined && {
        max: this.maxValue
      }),
      ...(this.step && {
        step: this.step
      })
    };
  }
  componentDidRender() {
    this.showSearchBackSpaceIcon(this.value);
    this.getReadOnlyLength(this.value);
    this.inputId = this.inputId?.length > 0 ? this.inputId : (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.U)();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.Host, {
      key: '5261d5629d63c7ead5af380c61590852d0809233'
    }, this.getLabel, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("div", {
      key: 'df2fa871bf2a07bafb301255c85e2706da0f6b51',
      class: {
        'input-wrapper': true,
        'input-with-icon-button input-with-icon-button-left': this.iconLeft?.length > 0,
        'input-with-icon-button input-with-icon-button-right': this.iconRight?.length > 0,
        'input-wrapper-date': this.type === 'date'
      }
    }, this.getPrefix, this.iconLeft?.length > 0 && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("div", {
      class: "input-icon-button input-icon-button-left"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("button", {
      type: "button",
      "aria-label": this.iconLeft,
      class: "input-icon-button-button"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("wink-icon", {
      appearance: "default",
      icon: this.iconLeft,
      size: this.size
    }))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("input", {
      key: '20d0144a5ed31367ba24ada26bcb1f369600f02d',
      onInput: e => this.handleChange(e),
      ...this.getAttributes(),
      class: {
        input: true,
        invalid: !!this.error,
        'input-password': this.type === _input_types_js__WEBPACK_IMPORTED_MODULE_1__.b.password
      },
      style: {
        width: this.isReadonly && this.inputWidth > 0 ? `${this.inputWidth}ch` : ''
      }
    }), this.type === _input_types_js__WEBPACK_IMPORTED_MODULE_1__.b.date && !this.isReadonly && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("wink-icon", {
      class: {
        disabled: this.isDisabled
      },
      icon: "calendar",
      appearance: "transparent"
    }), this.iconRight?.length > 0 && this.showIconRight && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("div", {
      class: "input-icon-button input-icon-button-right"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("button", {
      type: "button",
      "aria-label": this.iconRight,
      class: "input-icon-button-button",
      onClick: () => this.handleRightIconClick()
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("wink-icon", {
      appearance: "default",
      icon: this.iconRight,
      size: this.size
    }))), this.getPostfix), this.error && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("div", {
      id: this.getErrorMsgId(),
      class: "error-msg"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_6__.h)("wink-validation-message", {
      message: this.error
    })));
  }
  static get formAssociated() {
    return true;
  }
  static get style() {
    return {
      base: WinkInputBaseStyle0,
      telenet: WinkInputTelenetStyle0
    };
  }
}, [98, "wink-input", {
  "appearance": [513],
  "value": [1537],
  "inputId": [1, "input-id"],
  "name": [1],
  "type": [1],
  "placeholder": [1],
  "isRequired": [4, "is-required"],
  "inputModeOption": [1, "input-mode-option"],
  "autocomplete": [1],
  "enterkeyhintOption": [1, "enterkeyhint-option"],
  "isReadonly": [4, "is-readonly"],
  "isDisabled": [4, "is-disabled"],
  "isAutofocused": [4, "is-autofocused"],
  "step": [2],
  "minValue": [8, "min-value"],
  "maxValue": [8, "max-value"],
  "error": [1537],
  "prefixValue": [1, "prefix-value"],
  "postfixValue": [1, "postfix-value"],
  "iconLeft": [1, "icon-left"],
  "iconRight": [1, "icon-right"],
  "label": [1],
  "helper": [1],
  "optionalText": [1, "optional-text"],
  "size": [513],
  "showIconRight": [32],
  "inputWidth": [32],
  "setValidation": [64]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-input", "wink-form-label", "wink-icon", "wink-validation-message"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-input":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Input);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_4__.d)();
        }
        break;
      case "wink-validation-message":
        if (!customElements.get(tagName)) {
          (0,_validation_message_js__WEBPACK_IMPORTED_MODULE_5__.d)();
        }
        break;
    }
  });
}


/***/ }),

/***/ 17663:
/*!*************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/input.types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I: () => (/* binding */ INPUT_ENTERKEYHINTS),
/* harmony export */   a: () => (/* binding */ INPUT_APPEARANCES),
/* harmony export */   b: () => (/* binding */ INPUT_TYPES),
/* harmony export */   c: () => (/* binding */ INPUT_MODES),
/* harmony export */   d: () => (/* binding */ INPUT_AUTOCOMPLETES),
/* harmony export */   e: () => (/* binding */ INPUT_SIZES)
/* harmony export */ });
/* harmony import */ var _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.types.js */ 7988);

const INPUT_APPEARANCES = {
  default: 'default',
  search: 'search'
};
const INPUT_SIZES = {
  sm: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.sm,
  md: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.md
};
const INPUT_TYPES = {
  text: 'text',
  password: 'password',
  number: 'number',
  tel: 'tel',
  url: 'url',
  date: 'date',
  time: 'time',
  email: 'email',
  hidden: 'hidden'
};
const INPUT_AUTOCOMPLETES = {
  on: 'on',
  off: 'off',
  name: 'name',
  address: 'address',
  email: 'email',
  username: 'username',
  newPassword: 'new-password',
  currentPassword: 'current-password'
};
const INPUT_MODES = {
  none: 'none',
  text: 'text',
  numeric: 'numeric',
  decimal: 'decimal',
  tel: 'tel',
  email: 'email',
  search: 'search',
  url: 'url'
};
const INPUT_ENTERKEYHINTS = {
  none: 'none',
  enter: 'enter',
  done: 'done',
  go: 'go',
  next: 'next',
  previous: 'previous',
  search: 'search',
  send: 'send'
};


/***/ }),

/***/ 37232:
/*!******************************************************!*\
  !*** ./libs/foundation/wink/dist/components/link.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   L: () => (/* binding */ Link),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _positions_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./positions.types.js */ 46757);
/* harmony import */ var _icon_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.types.js */ 98681);
/* harmony import */ var _targets_types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./targets.types.js */ 83638);




const LINK_APPEARANCES_DEFAULT = {
  default: 'default',
  subtle: 'subtle',
  area: 'area'
};
const LINK_APPEARANCES_SNOWFLAKES = {
  dropdownMenuLink: 'dropdown-menu-link',
  menuSecondary: 'menu-secondary',
  menuBack: 'menu-back'
};
const LINK_APPEARANCES = {
  ...LINK_APPEARANCES_DEFAULT,
  ...LINK_APPEARANCES_SNOWFLAKES
};
const LINK_SIZES = {
  inherit: 'inherit',
  bodyRegular: 'body-regular'
};
const LINK_ICON_POSITIONS = {
  left: _positions_types_js__WEBPACK_IMPORTED_MODULE_0__.P.left,
  right: _positions_types_js__WEBPACK_IMPORTED_MODULE_0__.P.right
};
const linkBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host([icon-appearance=primary]) a ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-default)}:host([icon-appearance=primary]) a:hover ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-hover)}:host([icon-appearance=primary]) a:visited ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-default)}:host([icon-appearance=primary]) a:focus ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-hover)}:host([icon-appearance=primary]) a:active ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-active)}:host([icon-appearance=secondary]) a ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-default)}:host([icon-appearance=secondary]) a:hover ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-hovered)}:host([icon-appearance=secondary]) a:visited ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-default)}:host([icon-appearance=secondary]) a:focus ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-hovered)}:host([icon-appearance=secondary]) a:active ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-pressed)}:host .link{display:inline-block;text-decoration:none;background-color:var(--wink-link-bgcolor--default, var(--semantic-color-background-surface-neutral-default));padding-top:var(--wink-link-padding-top, calc(var(--semantic-spacing-none) * 1rem));padding-bottom:var(--wink-link-padding-bottom, calc(var(--semantic-spacing-none) * 1rem));padding-left:var(--wink-link-padding-left, calc(var(--semantic-spacing-none) * 1rem));padding-right:var(--wink-link-padding-right, calc(var(--semantic-spacing-none) * 1rem));margin-bottom:var(--wink-link-margin-bottom, calc(var(--semantic-spacing-none) * 1rem));border-radius:var(--wink-link-border-radius, 0)}:host .link.font--inherit #link-content{font-size:inherit;line-height:inherit;font-weight:inherit}:host .link #link-content{color:var(--wink-link-color--default, var(--semantic-color-text-default));display:block;text-decoration:underline}:host .link:hover,:host .link:visited:hover{cursor:pointer}:host .link:hover #link-content,:host .link:visited:hover #link-content{color:var(--wink-link-color--hover, var(--semantic-color-text-default));text-decoration:none}:host .link:active #link-content,:host .link:visited:active #link-content{color:var(--wink-link-color--active, var(--semantic-color-text-subtlest))}:host .link:visited #link-content{color:var(--wink-link-color--visited, var(--semantic-color-text-default))}:host .link:focus,:host .link:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .link.disabled,:host .link.subtle.disabled{pointer-events:none;opacity:0.4;cursor:not-allowed;-webkit-user-select:none;user-select:none}:host .link.subtle #link-content{text-decoration:none}:host .link.subtle:hover #link-content{text-decoration:underline}:host .link.link-with-icon{display:flex}:host .link.link-with-icon-left{flex-direction:row}:host .link.link-with-icon-left ::slotted([slot=link-icon]){align-self:start;margin-right:var(--wink-link--with-icon-left-icon--margin-right, calc(var(--semantic-spacing-3xs) * 1rem))}:host .link.link-with-icon-left.link-with-icon-backdrop ::slotted([slot=link-icon]){margin-right:calc(var(--semantic-spacing-md) * 1rem)}:host .link.link-with-icon-right{flex-direction:row-reverse}:host .link.link-with-icon-right ::slotted([slot=link-icon]){margin-left:calc(var(--semantic-spacing-3xs) * 1rem);align-self:start}:host .link.link-with-icon-right.link-with-icon-backdrop ::slotted([slot=link-icon]){margin-left:calc(var(--semantic-spacing-md) * 1rem)}:host .link.area,:host .link.area #link-content{text-decoration:none}:host .link.area:hover,:host .link.area #link-content:hover{text-decoration:none}:host([appearance=dropdown-menu-link]){display:flex}:host([appearance=dropdown-menu-link]) .link{flex:1 0 auto;padding:calc(var(--semantic-spacing-xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem);border-radius:0.4rem}:host([appearance=dropdown-menu-link]) .link #content{font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Regular, Helvetica, Verdana, Arial, sans-serif}:host([appearance=dropdown-menu-link]) .link:hover{background-color:var(--semantic-color-background-surface-neutral-hovered)}:host([appearance=dropdown-menu-link]) .link:active #link-content{font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host([appearance=dropdown-menu-link]) .link #link-content{text-decoration:none}:host([appearance=dropdown-menu-link]) .link.link-with-icon-left.link-with-icon-backdrop ::slotted([slot=link-icon]){margin-right:calc(var(--semantic-spacing-sm) * 1rem)}:host([appearance=dropdown-menu-link].active) .link{background-color:var(--semantic-color-background-surface-neutral-pressed)}:host([appearance=dropdown-menu-link].active) .link #link-content{font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}@media only screen and (min-width: 64em){:host([appearance=menu-secondary]) a ::slotted([slot=link-icon]),:host([appearance=menu-secondary]) :active ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtlest)}:host([appearance=menu-secondary]) a:hover ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-default)}}:host([appearance=menu-secondary]) ::slotted([slot=link-icon]){--wink-link--with-icon-left-icon--margin-right:calc(var(--semantic-spacing-xs) * 1rem)}:host([appearance=menu-secondary]) a:active ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtle)}:host([appearance=menu-secondary]) .link{--wink-link-padding-top:calc(var(--semantic-spacing-xs) * 1rem);--wink-link-padding-bottom:calc(var(--semantic-spacing-xs) * 1rem);text-decoration:none}@media only screen and (min-width: 64em){:host([appearance=menu-secondary]) .link{--wink-link-padding-left:calc(var(--semantic-spacing-xs) * 1rem);--wink-link-padding-right:calc(var(--semantic-spacing-xs) * 1rem);--wink-link-bgcolor--default:var(--semantic-color-background-canvas-default);--wink-link-border-radius:0.4rem}:host([appearance=menu-secondary]) .link.font-body-regular #link-content{font-size:1.4rem;line-height:2rem}}:host([appearance=menu-secondary]) .link #link-content{--wink-link-color--active:var(--semantic-color-text-subtlest);text-decoration:none}@media only screen and (min-width: 64em){:host([appearance=menu-secondary]) .link #link-content{--wink-link-color--default:var(--semantic-color-text-subtlest);--wink-link-color--hover:var(--semantic-color-text-default);--wink-link-color--visited:var(--semantic-color-text-subtlest);--wink-link-color--active:var(--semantic-color-text-subtlest)}}:host([appearance=menu-back]) a ::slotted([slot=link-icon]),:host([appearance=menu-back]) a:hover ::slotted([slot=link-icon]),:host([appearance=menu-back]) a:visited ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtle)}:host([appearance=menu-back]) a:active ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtlest)}:host([appearance=menu-back]) .link{align-items:center;text-decoration:none}:host([appearance=menu-back]) .link #link-content{--wink-link-color--default:var(--semantic-color-text-subtle);--wink-link-color--hover:var(--semantic-color-text-subtle);--wink-link-color--visited:var(--semantic-color-text-subtle);--wink-link-color--active:var(--semantic-color-text-subtlest);text-decoration:none}:host .link.font--body-regular #link-content{font-size:16px;line-height:24px;font-weight:normal}:host .link.font--body-small #link-content{font-size:14px;line-height:20px;font-weight:normal}:host .link.font-caption-bold #link-content{font-size:12px;line-height:28px;font-weight:700}";
const WinkLinkBaseStyle0 = linkBaseCss;
const linkTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host([icon-appearance=primary]) a ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-default)}:host([icon-appearance=primary]) a:hover ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-hover)}:host([icon-appearance=primary]) a:visited ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-default)}:host([icon-appearance=primary]) a:focus ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-hover)}:host([icon-appearance=primary]) a:active ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-action-active)}:host([icon-appearance=secondary]) a ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-default)}:host([icon-appearance=secondary]) a:hover ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-hovered)}:host([icon-appearance=secondary]) a:visited ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-default)}:host([icon-appearance=secondary]) a:focus ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-hovered)}:host([icon-appearance=secondary]) a:active ::slotted([slot=link-icon]){--wink-icon-bg-color:var(--semantic-color-background-surface-bold-pressed)}:host .link{display:inline-block;text-decoration:none;background-color:var(--wink-link-bgcolor--default, var(--semantic-color-background-surface-neutral-default));padding-top:var(--wink-link-padding-top, calc(var(--semantic-spacing-none) * 1rem));padding-bottom:var(--wink-link-padding-bottom, calc(var(--semantic-spacing-none) * 1rem));padding-left:var(--wink-link-padding-left, calc(var(--semantic-spacing-none) * 1rem));padding-right:var(--wink-link-padding-right, calc(var(--semantic-spacing-none) * 1rem));margin-bottom:var(--wink-link-margin-bottom, calc(var(--semantic-spacing-none) * 1rem));border-radius:var(--wink-link-border-radius, 0)}:host .link.font--inherit #link-content{font-size:inherit;line-height:inherit;font-weight:inherit}:host .link #link-content{color:var(--wink-link-color--default, var(--semantic-color-text-default));display:block;text-decoration:underline}:host .link:hover,:host .link:visited:hover{cursor:pointer}:host .link:hover #link-content,:host .link:visited:hover #link-content{color:var(--wink-link-color--hover, var(--semantic-color-text-default));text-decoration:none}:host .link:active #link-content,:host .link:visited:active #link-content{color:var(--wink-link-color--active, var(--semantic-color-text-subtlest))}:host .link:visited #link-content{color:var(--wink-link-color--visited, var(--semantic-color-text-default))}:host .link:focus,:host .link:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .link.disabled,:host .link.subtle.disabled{pointer-events:none;opacity:0.4;cursor:not-allowed;-webkit-user-select:none;user-select:none}:host .link.subtle #link-content{text-decoration:none}:host .link.subtle:hover #link-content{text-decoration:underline}:host .link.link-with-icon{display:flex}:host .link.link-with-icon-left{flex-direction:row}:host .link.link-with-icon-left ::slotted([slot=link-icon]){align-self:start;margin-right:var(--wink-link--with-icon-left-icon--margin-right, calc(var(--semantic-spacing-3xs) * 1rem))}:host .link.link-with-icon-left.link-with-icon-backdrop ::slotted([slot=link-icon]){margin-right:calc(var(--semantic-spacing-md) * 1rem)}:host .link.link-with-icon-right{flex-direction:row-reverse}:host .link.link-with-icon-right ::slotted([slot=link-icon]){margin-left:calc(var(--semantic-spacing-3xs) * 1rem);align-self:start}:host .link.link-with-icon-right.link-with-icon-backdrop ::slotted([slot=link-icon]){margin-left:calc(var(--semantic-spacing-md) * 1rem)}:host .link.area,:host .link.area #link-content{text-decoration:none}:host .link.area:hover,:host .link.area #link-content:hover{text-decoration:none}:host([appearance=dropdown-menu-link]){display:flex}:host([appearance=dropdown-menu-link]) .link{flex:1 0 auto;padding:calc(var(--semantic-spacing-xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem);border-radius:0.4rem}:host([appearance=dropdown-menu-link]) .link #content{font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Regular, Helvetica, Verdana, Arial, sans-serif}:host([appearance=dropdown-menu-link]) .link:hover{background-color:var(--semantic-color-background-surface-neutral-hovered)}:host([appearance=dropdown-menu-link]) .link:active #link-content{font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host([appearance=dropdown-menu-link]) .link #link-content{text-decoration:none}:host([appearance=dropdown-menu-link]) .link.link-with-icon-left.link-with-icon-backdrop ::slotted([slot=link-icon]){margin-right:calc(var(--semantic-spacing-sm) * 1rem)}:host([appearance=dropdown-menu-link].active) .link{background-color:var(--semantic-color-background-surface-neutral-pressed)}:host([appearance=dropdown-menu-link].active) .link #link-content{font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}@media only screen and (min-width: 64em){:host([appearance=menu-secondary]) a ::slotted([slot=link-icon]),:host([appearance=menu-secondary]) :active ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtlest)}:host([appearance=menu-secondary]) a:hover ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-default)}}:host([appearance=menu-secondary]) ::slotted([slot=link-icon]){--wink-link--with-icon-left-icon--margin-right:calc(var(--semantic-spacing-xs) * 1rem)}:host([appearance=menu-secondary]) a:active ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtle)}:host([appearance=menu-secondary]) .link{--wink-link-padding-top:calc(var(--semantic-spacing-xs) * 1rem);--wink-link-padding-bottom:calc(var(--semantic-spacing-xs) * 1rem);text-decoration:none}@media only screen and (min-width: 64em){:host([appearance=menu-secondary]) .link{--wink-link-padding-left:calc(var(--semantic-spacing-xs) * 1rem);--wink-link-padding-right:calc(var(--semantic-spacing-xs) * 1rem);--wink-link-bgcolor--default:var(--semantic-color-background-canvas-default);--wink-link-border-radius:0.4rem}:host([appearance=menu-secondary]) .link.font-body-regular #link-content{font-size:1.4rem;line-height:2rem}}:host([appearance=menu-secondary]) .link #link-content{--wink-link-color--active:var(--semantic-color-text-subtlest);text-decoration:none}@media only screen and (min-width: 64em){:host([appearance=menu-secondary]) .link #link-content{--wink-link-color--default:var(--semantic-color-text-subtlest);--wink-link-color--hover:var(--semantic-color-text-default);--wink-link-color--visited:var(--semantic-color-text-subtlest);--wink-link-color--active:var(--semantic-color-text-subtlest)}}:host([appearance=menu-back]) a ::slotted([slot=link-icon]),:host([appearance=menu-back]) a:hover ::slotted([slot=link-icon]),:host([appearance=menu-back]) a:visited ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtle)}:host([appearance=menu-back]) a:active ::slotted([slot=link-icon]){--wink-icon-color:var(--semantic-color-icon-subtlest)}:host([appearance=menu-back]) .link{align-items:center;text-decoration:none}:host([appearance=menu-back]) .link #link-content{--wink-link-color--default:var(--semantic-color-text-subtle);--wink-link-color--hover:var(--semantic-color-text-subtle);--wink-link-color--visited:var(--semantic-color-text-subtle);--wink-link-color--active:var(--semantic-color-text-subtlest);text-decoration:none}:host .link.font-body-regular #link-content{font-family:TelenetAlbra-Regular, Helvetica, Verdana, Arial, sans-serif;font-size:1.6rem;line-height:2.4rem;font-weight:400}@media only screen and (min-width: 48.0625em){:host .link.font-body-regular #link-content{font-size:1.6rem;line-height:2.4rem}}@media only screen and (min-width: 74.5em){:host .link.font-body-regular #link-content{font-size:1.8rem;line-height:2.8rem}}:host .link.font-body-small #link-content{font-family:TelenetAlbra-Regular, Helvetica, Verdana, Arial, sans-serif;font-size:1.4rem;line-height:2rem;font-weight:400}@media only screen and (min-width: 48.0625em){:host .link.font-body-small #link-content{font-size:1.4rem;line-height:2rem}}@media only screen and (min-width: 74.5em){:host .link.font-body-small #link-content{font-size:1.6rem;line-height:2.4rem}}:host .link.font-caption-bold #link-content{font-family:TelenetAlbra-Bold, Helvetica, Verdana, Arial, sans-serif;font-size:1.2rem;line-height:1.6rem;letter-spacing:0;font-weight:900}@media only screen and (min-width: 48.0625em){:host .link.font-caption-bold #link-content{font-size:1.2rem;line-height:1.6rem;letter-spacing:0}}@media only screen and (min-width: 74.5em){:host .link.font-caption-bold #link-content{font-size:1.4rem;line-height:2rem;letter-spacing:0}}";
const WinkLinkTelenetStyle0 = linkTelenetCss;
const Link = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.proxyCustomElement)(class Link extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.appearance = LINK_APPEARANCES.default;
    this.size = LINK_SIZES.inherit;
    this.icon = undefined;
    this.iconPosition = LINK_ICON_POSITIONS.left;
    this.iconAppearance = _icon_types_js__WEBPACK_IMPORTED_MODULE_1__.b.default;
    this.isDisabled = false;
    this.href = '';
    this.target = _targets_types_js__WEBPACK_IMPORTED_MODULE_2__.T.self;
  }
  getTypeClasses() {
    return this.appearance !== LINK_APPEARANCES.default ? `${this.appearance}` : '';
  }
  hasBackdrop() {
    return this.iconAppearance !== _icon_types_js__WEBPACK_IMPORTED_MODULE_1__.b.default && Object.values(_icon_types_js__WEBPACK_IMPORTED_MODULE_1__.b).includes(this.iconAppearance);
  }
  render() {
    const sizeClasses = `font-${this.size}`;
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.Host, {
      key: 'fc89d77072b84beca652fdc0d403df3a1af2301b'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("a", {
      key: '8337b1fb778c85308de2f1ddcfdca6c97018a2a8',
      class: {
        link: true,
        [sizeClasses]: true,
        [this.getTypeClasses()]: true,
        [`link-with-icon link-with-icon-${this.iconPosition}`]: this.icon !== '',
        'link-with-icon-backdrop': this.hasBackdrop(),
        disabled: this.isDisabled
      },
      href: this.href,
      target: this.target
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      key: 'b6b54ae4531683cfae70d9bba9d7a28c60906ee7',
      name: "link-icon"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      key: '195e537f7baa3c1302ab446cfd41dd1707fb5b73',
      id: "link-content"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      key: 'a8fbb669673e38b0431991ca3b6def423d9483b3'
    }))));
  }
  static get style() {
    return {
      base: WinkLinkBaseStyle0,
      telenet: WinkLinkTelenetStyle0
    };
  }
}, [33, "wink-link", {
  "appearance": [513],
  "size": [1],
  "icon": [1],
  "iconPosition": [1, "icon-position"],
  "iconAppearance": [1, "icon-appearance"],
  "isDisabled": [4, "is-disabled"],
  "href": [1],
  "target": [1]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-link"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-link":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Link);
        }
        break;
    }
  });
}


/***/ }),

/***/ 20462:
/*!**********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/media-query-detector.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   M: () => (/* binding */ MediaQueryDetector)
/* harmony export */ });
const BREAKPOINTS = {
  SM: 576,
  MD: 769,
  LG: 1192
};
const HEADER_BREAKPOINTS = {
  MD: 1024
};
const BREAKPOINT_TYPES = {
  DEFAULT: BREAKPOINTS,
  HEADER: HEADER_BREAKPOINTS
};
class MediaQueryDetector {
  static mediaQueryMatch(size, minOrMax, breakpointType = 'DEFAULT') {
    const breakpoints = BREAKPOINT_TYPES[breakpointType];
    const pixels = minOrMax === 'min' ? breakpoints[size] : breakpoints[size] - 1;
    return window.matchMedia(`(${minOrMax}-width: ${pixels}px)`).matches;
  }
  static get isFromSm() {
    return MediaQueryDetector.mediaQueryMatch('SM', 'min');
  }
  static get isFromMd() {
    return MediaQueryDetector.mediaQueryMatch('MD', 'min');
  }
  static get isFromLg() {
    return MediaQueryDetector.mediaQueryMatch('LG', 'min');
  }
  static get isUntilSm() {
    return MediaQueryDetector.mediaQueryMatch('SM', 'max');
  }
  static get isUntilMd() {
    return MediaQueryDetector.mediaQueryMatch('MD', 'max');
  }
  static get isUntilLg() {
    return MediaQueryDetector.mediaQueryMatch('LG', 'max');
  }
  static get isFromMdHeader() {
    return MediaQueryDetector.mediaQueryMatch('MD', 'min', 'HEADER');
  }
  static get isUntilMdHeader() {
    return MediaQueryDetector.mediaQueryMatch('MD', 'max', 'HEADER');
  }
}


/***/ }),

/***/ 16784:
/*!***********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/paragraph.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ Paragraph),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);

const PARAGRAPH_APPEARANCES = {
  body: 'body',
  caption: 'caption'
};
const PARAGRAPH_SIZES = {
  regular: 'regular',
  small: 'small',
  large: 'large',
  bold: 'bold'
};
const paragraphBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block;width:100%}:host(.font--body-regular){font-size:18px;line-height:28px}:host(.font--body-small){font-size:16px;line-height:24px}:host(.font--body-large){font-size:24px;line-height:36px}:host(.font--caption-bold){font-size:14px;line-height:20px;font-weight:bold}:host(.font--caption-regular){font-size:14px;line-height:20px}:host(.font--caption-small){font-size:12px;line-height:16px}";
const WinkParagraphBaseStyle0 = paragraphBaseCss;
const paragraphTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block;width:100%}:host(.font--body-regular){font-size:18px;line-height:28px}:host(.font--body-small){font-size:16px;line-height:24px}:host(.font--body-large){font-size:24px;line-height:36px}:host(.font--caption-bold){font-size:14px;line-height:20px;font-weight:bold}:host(.font--caption-regular){font-size:14px;line-height:20px}:host(.font--caption-small){font-size:12px;line-height:16px}";
const WinkParagraphTelenetStyle0 = paragraphTelenetCss;
const Paragraph = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.proxyCustomElement)(class Paragraph extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.appearance = PARAGRAPH_APPEARANCES.body;
    this.size = PARAGRAPH_SIZES.regular;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.Host, {
      key: 'f74cebdf05b2f6e4135eb2e9d6f60461612d2e0e',
      class: `font--${this.appearance}-${this.size}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("slot", {
      key: 'e9bb9bcb6965caaad10e97d80c48647bab6b7746'
    }));
  }
  static get style() {
    return {
      base: WinkParagraphBaseStyle0,
      telenet: WinkParagraphTelenetStyle0
    };
  }
}, [33, "wink-paragraph", {
  "appearance": [1],
  "size": [1]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-paragraph"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-paragraph":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Paragraph);
        }
        break;
    }
  });
}


/***/ }),

/***/ 46757:
/*!*****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/positions.types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D: () => (/* binding */ DIRECTIONS),
/* harmony export */   P: () => (/* binding */ POSITIONS_HORIZONTAL)
/* harmony export */ });
const POSITIONS_HORIZONTAL = {
  left: 'left',
  center: 'center',
  right: 'right'
};
const DIRECTIONS = {
  horizontal: 'horizontal',
  vertical: 'vertical'
};


/***/ }),

/***/ 7988:
/*!*************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/sizes.types.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ SIZES)
/* harmony export */ });
const SIZES = {
  sm: 'sm',
  md: 'md',
  lg: 'lg',
  xl: 'xl',
  '3xs': '3xs',
  '2xs': '2xs',
  xs: 'xs',
  s: 's',
  m: 'm',
  l: 'l',
  none: 'none',
  full: 'full'
};


/***/ }),

/***/ 94001:
/*!****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/statuses.types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   S: () => (/* binding */ STATUS_VARIANTS)
/* harmony export */ });
const STATUS_VARIANTS = {
  information: 'information',
  success: 'success',
  error: 'error',
  warning: 'warning'
};


/***/ }),

/***/ 83638:
/*!***************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/targets.types.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ TARGETS)
/* harmony export */ });
const TARGETS = {
  self: '_self',
  blank: '_blank',
  parent: '_parent',
  top: '_top',
  unfencedTop: '_unfencedTop'
};


/***/ }),

/***/ 82637:
/*!*******************************************************!*\
  !*** ./libs/foundation/wink/dist/components/toast.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   T: () => (/* binding */ Toast),
/* harmony export */   a: () => (/* binding */ TOAST_TYPES),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _targets_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./targets.types.js */ 83638);
/* harmony import */ var _icon_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.types.js */ 98681);
/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animation.js */ 8071);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./link.js */ 37232);






const TOAST_TYPES = {
  negative: 'negative',
  positive: 'positive',
  actionable: 'actionable',
  feedback: 'feedback'
};
const toastBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{--semantic-duration-very-fast:100ms;--semantic-duration-fast:200ms;--semantic-duration-medium:300ms;--semantic-duration-slow:400ms;--semantic-duration-very-slow:500ms;--semantic-easing-productive-ease-in:cubic-bezier(0.11, 0, 0.5, 0);--semantic-easing-productive-ease-out:cubic-bezier(0.5, 1, 0.89, 1);--semantic-easing-productive-ease-in-out:cubic-bezier(0.45, 0, 0.55, 1);font-family:TelenetAlbra-Regular, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-size:1.8rem;pointer-events:none;overflow:hidden;display:flex;align-items:center;justify-content:flex-start;background-color:var(--semantic-color-background-canvas-default);color:var(--semantic-color-text-default);animation-name:toastFadeOut;animation-duration:var(--semantic-duration-slow);animation-timing-function:var(--semantic-easing-productive-ease-in-out);animation-fill-mode:forwards;animation-iteration-count:1;height:-moz-fit-content;height:fit-content}@media only screen and (min-width: 36em){:host{width:-moz-fit-content;width:fit-content;justify-content:center}}:host .toast-icon{margin-right:calc(var(--semantic-spacing-sm) * 1rem)}:host .toast-icon-positive{--wink-icon-color:var(--semantic-color-icon-succes)}:host .toast-icon-negative{--wink-icon-color:var(--semantic-color-icon-error)}:host .toast-text{margin:calc(var(--semantic-spacing-xs) * 1rem) calc(var(--semantic-spacing-md) * 1rem) calc(var(--semantic-spacing-3xs) * 1rem) 0}:host .toast-link{--wink-link-color--default:var(--semantic-color-text-default);--wink-link-color--visited:var(--semantic-color-text-default);--wink-link-color--hover:var(--semantic-color-text-default);margin:calc(var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-md) * 1rem) 0 0}:host .toast-close{--wink-icon-color:var(--semantic-color-icon);padding-left:calc(var(--semantic-spacing-md) * 1rem);border-left:0.1rem solid var(--semantic-color-border-button-default);margin-left:auto}@media only screen and (min-width: 48.0625em){:host .toast-close{margin-left:0}}:host([is-open]),:host([is-open=true]){animation-name:toastFadeIn;pointer-events:auto}@keyframes toastFadeIn{from{opacity:0;padding:0 calc(var(--semantic-spacing-md) * 1rem)}to{opacity:1;padding:calc(var(--semantic-spacing-md) * 1rem)}}@keyframes toastFadeOut{0%{opacity:1;max-height:7rem;padding:calc(var(--semantic-spacing-md) * 1rem);margin-top:0}70%{opacity:0}100%{opacity:0;max-height:0;padding:0 calc(var(--semantic-spacing-md) * 1rem);margin-top:-1.6rem;display:none}}@media (prefers-reduced-motion){:host{animation-duration:0}}";
const WinkToastBaseStyle0 = toastBaseCss;
const toastTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{--semantic-duration-very-fast:100ms;--semantic-duration-fast:200ms;--semantic-duration-medium:300ms;--semantic-duration-slow:400ms;--semantic-duration-very-slow:500ms;--semantic-easing-productive-ease-in:cubic-bezier(0.11, 0, 0.5, 0);--semantic-easing-productive-ease-out:cubic-bezier(0.5, 1, 0.89, 1);--semantic-easing-productive-ease-in-out:cubic-bezier(0.45, 0, 0.55, 1);font-family:TelenetAlbra-Regular, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-size:1.8rem;pointer-events:none;overflow:hidden;display:flex;align-items:center;justify-content:flex-start;background-color:var(--semantic-color-background-canvas-default);color:var(--semantic-color-text-default);animation-name:toastFadeOut;animation-duration:var(--semantic-duration-slow);animation-timing-function:var(--semantic-easing-productive-ease-in-out);animation-fill-mode:forwards;animation-iteration-count:1;height:-moz-fit-content;height:fit-content}@media only screen and (min-width: 36em){:host{width:-moz-fit-content;width:fit-content;justify-content:center}}:host .toast-icon{margin-right:calc(var(--semantic-spacing-sm) * 1rem)}:host .toast-icon-positive{--wink-icon-color:var(--semantic-color-icon-succes)}:host .toast-icon-negative{--wink-icon-color:var(--semantic-color-icon-error)}:host .toast-text{margin:calc(var(--semantic-spacing-xs) * 1rem) calc(var(--semantic-spacing-md) * 1rem) calc(var(--semantic-spacing-3xs) * 1rem) 0}:host .toast-link{--wink-link-color--default:var(--semantic-color-text-default);--wink-link-color--visited:var(--semantic-color-text-default);--wink-link-color--hover:var(--semantic-color-text-default);margin:calc(var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-md) * 1rem) 0 0}:host .toast-close{--wink-icon-color:var(--semantic-color-icon);padding-left:calc(var(--semantic-spacing-md) * 1rem);border-left:0.1rem solid var(--semantic-color-border-button-default);margin-left:auto}@media only screen and (min-width: 48.0625em){:host .toast-close{margin-left:0}}:host([is-open]),:host([is-open=true]){animation-name:toastFadeIn;pointer-events:auto}@keyframes toastFadeIn{from{opacity:0;padding:0 calc(var(--semantic-spacing-md) * 1rem)}to{opacity:1;padding:calc(var(--semantic-spacing-md) * 1rem)}}@keyframes toastFadeOut{0%{opacity:1;max-height:7rem;padding:calc(var(--semantic-spacing-md) * 1rem);margin-top:0}70%{opacity:0}100%{opacity:0;max-height:0;padding:0 calc(var(--semantic-spacing-md) * 1rem);margin-top:-1.6rem;display:none}}@media (prefers-reduced-motion){:host{animation-duration:0}}";
const WinkToastTelenetStyle0 = toastTelenetCss;
const Toast = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.proxyCustomElement)(class Toast extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.appearance = TOAST_TYPES.actionable;
    this.text = '';
    this.linkText = 'Open Link';
    this.href = '';
    this.target = _targets_types_js__WEBPACK_IMPORTED_MODULE_0__.T.self;
    this.duration = 6000;
    this.isOpen = false;
    this.theme = 'telenet-light-theme';
    this.currentTheme = 'telenet-light-theme';
  }
  timer = null;
  iconsNamesMap = new Map([[TOAST_TYPES.negative, 'cross-circle-filled'], [TOAST_TYPES.positive, 'check-shape-filled']]);
  watchOpenPropHandler(newValue, oldValue) {
    if (newValue && !oldValue) {
      this.closeToastAfterTimeout();
    }
  }
  watchThemePropHandler(newValue, oldValue) {
    if (newValue !== oldValue) {
      this.changeTheme(newValue);
    }
  }
  handleKeyDown(ev) {
    if (ev.key === 'Escape') {
      this.closeToast();
    }
  }
  componentDidLoad() {
    const currentTheme = localStorage.getItem('currentTheme') || 'telenet-light';
    this.changeTheme(currentTheme + '-theme');
    this.closeToastAfterTimeout();
  }
  changeTheme(newValue) {
    this.theme = newValue.includes('dark') ? newValue.replace('dark', 'light') : newValue.replace('light', 'dark');
  }
  closeToast() {
    this.isOpen = false;
  }
  closeToastAfterTimeout() {
    if (this.appearance !== TOAST_TYPES.actionable && this.duration && this.duration > 0) {
      if (this.timer) {
        clearTimeout(this.timer);
      }
      this.timer = setTimeout(() => {
        this.closeToast();
      }, Number(this.duration));
    }
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.Host, {
      key: '4353ed175ce789298a19e7c9037ea92719db8d47',
      theme: this.theme,
      "aria-hidden": this.isOpen ? 'false' : 'true',
      role: "alert"
    }, (this.appearance === TOAST_TYPES.positive || this.appearance === TOAST_TYPES.negative) && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-icon", {
      class: `toast-icon toast-icon-${this.appearance}`,
      size: _icon_types_js__WEBPACK_IMPORTED_MODULE_1__.I.md,
      icon: this.iconsNamesMap.get(this.appearance)
    }), this.text && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("p", {
      class: "toast-text"
    }, this.text), this.appearance === TOAST_TYPES.actionable && this.href && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-link", {
      appearance: "default",
      icon: "",
      size: "inherit",
      "is-disabled": "false",
      class: "toast-link",
      target: this.target,
      href: this.href
    }, this.linkText), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-button", {
      key: 'dae3eea4b47c3b59e37af642c36fbe3179a132a6',
      element: "button",
      type: "button",
      appearance: "tertiary",
      size: "sm",
      width: "none",
      status: "none",
      icon: "cross",
      "icon-position": "center",
      exportparts: "icon, icon-cross",
      class: "hydrated toast-close",
      "icon-button-aria-label": "close toast",
      onClick: this.closeToast.bind(this)
    }));
  }
  static get watchers() {
    return {
      "isOpen": ["watchOpenPropHandler"],
      "currentTheme": ["watchThemePropHandler"]
    };
  }
  static get style() {
    return {
      base: WinkToastBaseStyle0,
      telenet: WinkToastTelenetStyle0
    };
  }
}, [33, "wink-toast", {
  "appearance": [1],
  "text": [1],
  "linkText": [1, "link-text"],
  "href": [1],
  "target": [1],
  "duration": [2],
  "isOpen": [1540, "is-open"],
  "theme": [1537],
  "currentTheme": [513, "current-theme"]
}, [[1, "keydown", "handleKeyDown"]], {
  "isOpen": ["watchOpenPropHandler"],
  "currentTheme": ["watchThemePropHandler"]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-toast", "wink-animation", "wink-button", "wink-icon", "wink-link"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-toast":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toast);
        }
        break;
      case "wink-animation":
        if (!customElements.get(tagName)) {
          (0,_animation_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
      case "wink-button":
        if (!customElements.get(tagName)) {
          (0,_animation_js__WEBPACK_IMPORTED_MODULE_2__.a)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-link":
        if (!customElements.get(tagName)) {
          (0,_link_js__WEBPACK_IMPORTED_MODULE_4__.d)();
        }
        break;
    }
  });
}


/***/ }),

/***/ 69900:
/*!*******************************************************!*\
  !*** ./libs/foundation/wink/dist/components/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U: () => (/* binding */ UUId)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }
  return getRandomValues(rnds8);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
const UUId = () => v4();


/***/ }),

/***/ 46024:
/*!********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/validation-message.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ ValidationMessage),
/* harmony export */   d: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _statuses_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./statuses.types.js */ 94001);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);



const VALIDATION_TYPES = {
  error: _statuses_types_js__WEBPACK_IMPORTED_MODULE_0__.S.error
};
const validationMessageBaseCss = ".sr-only.sc-wink-validation-message-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-validation-message-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-validation-message-base-h>*.sc-wink-validation-message-base{--wink-icon-color:var(--semantic-color-icon-error);color:var(--semantic-color-text-error);display:flex;flex-wrap:wrap;width:100%;gap:calc(var(--semantic-spacing-3xs) * 1rem);align-items:center;font-size:1.4rem;line-height:2rem;margin-top:calc(var(--semantic-spacing-xs) * 1rem)}.sc-wink-validation-message-base-h .validation-message--error.sc-wink-validation-message-base{--wink-icon-color:var(--semantic-color-icon-error)}";
const WinkValidationMessageBaseStyle0 = validationMessageBaseCss;
const validationMessageTelenetCss = ".sr-only.sc-wink-validation-message-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-validation-message-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-validation-message-telenet-h>*.sc-wink-validation-message-telenet{--wink-icon-color:var(--semantic-color-icon-error);color:var(--semantic-color-text-error);display:flex;flex-wrap:wrap;width:100%;gap:calc(var(--semantic-spacing-3xs) * 1rem);align-items:center;font-size:1.4rem;line-height:2rem;margin-top:calc(var(--semantic-spacing-xs) * 1rem)}.sc-wink-validation-message-telenet-h .validation-message--error.sc-wink-validation-message-telenet{--wink-icon-color:var(--semantic-color-icon-error)}";
const WinkValidationMessageTelenetStyle0 = validationMessageTelenetCss;
const ValidationMessage = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class ValidationMessage extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.message = undefined;
    this.type = VALIDATION_TYPES.error;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: '3ad88915d603ba0b26a3b35bfec69dfeae97635b',
      class: `validation-message--${this.type}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: '8e427aa709ac3bdf6994a7e9a2e690f57fee18cd',
      icon: "error-shape"
    }), this.message);
  }
  static get style() {
    return {
      base: WinkValidationMessageBaseStyle0,
      telenet: WinkValidationMessageTelenetStyle0
    };
  }
}, [34, "wink-validation-message", {
  "message": [1],
  "type": [1]
}]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-validation-message", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-validation-message":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ValidationMessage);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}


/***/ }),

/***/ 17857:
/*!****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-accordion.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkAccordion: () => (/* binding */ WinkAccordion),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _icon_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.types.js */ 98681);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);



const accordionBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}.accordion{font-size:initial;color:var(--semantic-color-text-default);border-bottom:calc(var(--semantic-border-sm) * 1rem) solid var(--semantic-color-border-subtle)}.accordion [role=heading]{font-family:arial, sans-serif;font-size:inherit;margin:0;padding:0}.accordion [role=heading] .accordion-title{display:inline-flex;gap:calc(var(--semantic-spacing-lg) * 1rem)}.accordion-trigger{all:unset;display:flex;justify-content:space-between;align-items:flex-start;gap:calc(var(--semantic-spacing-lg) * 1rem);width:100%;padding:calc(var(--semantic-spacing-lg) * 1rem) 0 calc(var(--semantic-spacing-lg) * 1rem) 0;position:relative;text-align:left;box-sizing:border-box}.accordion-trigger:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}.accordion-trigger[aria-expanded=true] .accordion-icon{transform:rotate(180deg)}.accordion-icon{transition:all 0.3s ease}.accordion .accordion-panel{display:grid;grid-template-rows:1fr;overflow:hidden;transition:all 0.3s ease}.accordion .accordion-panel>div{min-height:0;padding-right:calc(var(--semantic-icon-md) * 1rem)}.accordion .accordion-panel>div.with-icon{padding-left:calc(var(--semantic-spacing-lg) * 1rem + var(--semantic-icon-md) * 1rem)}.accordion .accordion-panel>div::after{content:\"\";display:block;width:100%;height:calc(var(--semantic-spacing-lg) * 1rem)}.accordion .accordion-panel[aria-hidden=false]{grid-template-rows:0fr}";
const WinkAccordionBaseStyle0 = accordionBaseCss;
const accordionTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}.accordion{font-size:1.6rem;color:var(--semantic-color-text-default);border-bottom:calc(var(--semantic-border-sm) * 1rem) solid var(--semantic-color-border-subtle)}.accordion [role=heading]{font-family:telenetalbra-bold, arial, sans-serif;font-size:2rem;margin:0;padding:0}.accordion [role=heading] .accordion-title{display:inline-flex;gap:calc(var(--semantic-spacing-lg) * 1rem)}.accordion-trigger{all:unset;display:flex;justify-content:space-between;align-items:flex-start;gap:calc(var(--semantic-spacing-lg) * 1rem);width:100%;padding:calc(var(--semantic-spacing-lg) * 1rem) 0 calc(var(--semantic-spacing-lg) * 1rem) 0;position:relative;text-align:left;box-sizing:border-box}.accordion-trigger:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}.accordion-trigger[aria-expanded=true] .accordion-icon{transform:rotate(180deg)}.accordion-icon{transition:all 0.3s ease}.accordion .accordion-panel{display:grid;grid-template-rows:1fr;overflow:hidden;transition:all 0.3s ease}.accordion .accordion-panel>div{min-height:0;padding-right:calc(var(--semantic-icon-md) * 1rem)}.accordion .accordion-panel>div.with-icon{padding-left:calc(var(--semantic-spacing-lg) * 1rem + var(--semantic-icon-md) * 1rem)}.accordion .accordion-panel>div::after{content:\"\";display:block;width:100%;height:calc(var(--semantic-spacing-lg) * 1rem)}.accordion .accordion-panel[aria-hidden=false]{grid-template-rows:0fr}";
const WinkAccordionTelenetStyle0 = accordionTelenetCss;
const Accordion = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class Accordion extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.heading = '';
    this.icon = '';
    this.isExpanded = false;
  }
  componentDidLoad() {
    if (!this.isExpanded) this.activeContentPanel.style.setProperty('display', 'none');
  }
  activeContentPanel;
  get dynamicIdBasedOnTitle() {
    return this.heading.replace(/\s/g, '-').substring(0, 7);
  }
  onButtonClick = () => {
    this.isExpanded = !this.isExpanded;
  };
  panelTransitionStart = () => {
    if (this.isExpanded) {
      this.activeContentPanel.style.removeProperty('display');
    }
  };
  panelTransitionEnd = () => {
    if (!this.isExpanded) {
      this.activeContentPanel.style.setProperty('display', 'none');
    }
  };
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, {
      key: 'fee3ec6dec5147e0d4c41a93a2db575842d745b6'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: 'fd8610b0544e355d089da8d35a9ce2e729e1662d',
      id: "accordion",
      class: "accordion"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: '0c13e9249ca39c9e3d0dcb2186d4cf3f0dbdee89',
      role: "heading",
      "aria-level": "5"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("button", {
      key: '7fa30a0c5c299f4743acd0859fb32340241a3ac3',
      class: "accordion-trigger",
      onClick: this.onButtonClick,
      type: "button",
      "aria-expanded": `${this.isExpanded}`,
      "aria-controls": `section-${this.dynamicIdBasedOnTitle}`,
      id: "accordion1id"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: '08027ba23e928a92b70dc5d55d552a2a9ee2b563',
      class: "accordion-title"
    }, !!this.icon && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      appearance: "default",
      icon: this.icon,
      size: _icon_types_js__WEBPACK_IMPORTED_MODULE_0__.I.md
    }), this.heading), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: 'b4922d586acbdfec71878f30c5081cfd632c1fcb',
      class: "accordion-icon",
      appearance: "default",
      icon: "chevron-down",
      size: _icon_types_js__WEBPACK_IMPORTED_MODULE_0__.I.md
    }))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: '69be91831b0f460e2ee1662cd64a769cddcdd80b',
      id: `section-${this.dynamicIdBasedOnTitle}`,
      class: "accordion-panel",
      role: "region",
      "aria-labelledby": "accordion1id",
      "aria-hidden": `${this.isExpanded}`,
      hidden: !this.isExpanded,
      onTransitionEnd: this.panelTransitionEnd,
      onTransitionStart: this.panelTransitionStart
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: 'e28dac024655d4487c029a502b1963db59a5bbac',
      id: "content",
      class: `${this.icon ? 'with-icon' : ''}`,
      ref: el => this.activeContentPanel = el
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("slot", {
      key: 'e7262f515952b7dafff1b3b715cf135fceb9e867'
    })))));
  }
  static get style() {
    return {
      base: WinkAccordionBaseStyle0,
      telenet: WinkAccordionTelenetStyle0
    };
  }
}, [33, "wink-accordion", {
  "heading": [1],
  "icon": [1],
  "isExpanded": [1540, "is-expanded"]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-accordion", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-accordion":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Accordion);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}
const WinkAccordion = Accordion;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 70405:
/*!****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-animation.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkAnimation: () => (/* binding */ WinkAnimation),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animation.js */ 8071);

const WinkAnimation = _animation_js__WEBPACK_IMPORTED_MODULE_0__.A;
const defineCustomElement = _animation_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 91318:
/*!*************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-avatar.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkAvatar: () => (/* binding */ WinkAvatar),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.types.js */ 7988);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);



const AVATAR_SIZES = {
  sm: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.sm,
  md: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.md,
  lg: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.lg,
  xl: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.xl
};
const avatarBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block;position:relative}:host img{object-fit:cover;object-position:center}:host([size=sm]) img{height:2.4rem;width:2.4rem}:host([size=md]) img{height:4rem;width:4rem}:host([size=lg]) img{height:4.8rem;width:4.8rem}:host([size=xl]) img{height:7.2rem;width:7.2rem}";
const WinkAvatarBaseStyle0 = avatarBaseCss;
const avatarTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block;position:relative}:host img{object-fit:cover;object-position:center}:host([size=sm]) img{height:2.4rem;width:2.4rem}:host([size=md]) img{height:4rem;width:4rem}:host([size=lg]) img{height:4.8rem;width:4.8rem}:host([size=xl]) img{height:7.2rem;width:7.2rem}:host img{mask:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='109' height='109' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M105.9 20C104.8 11.2 98 4.2 89.2 3.2c0 0-14-2.2-34.7-2.2-20.6 0-34.7 2.2-34.7 2.2-8.8 1-15.6 8-16.7 16.8C3.1 20 1 35.8 1 54.5S3.1 89 3.1 89c1.1 8.8 7.9 15.8 16.7 16.8 0 0 14 2.2 34.7 2.2 20.6 0 34.7-2.2 34.7-2.2 8.8-1.1 15.6-8 16.7-16.8 0 0 2.1-15.8 2.1-34.5S105.9 20 105.9 20' fill-rule='evenodd'/%3E%3C/svg%3E\");mask-size:contain;mask-repeat:no-repeat}";
const WinkAvatarTelenetStyle0 = avatarTelenetCss;
const Avatar = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class Avatar extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.src = undefined;
    this.size = AVATAR_SIZES.md;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, {
      key: '0696513c7ab31d5f5a435b02bea52d4e9824b87b'
    }, this.src?.length > 0 ? (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("img", {
      src: this.src,
      alt: "avatar image"
    }) : (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      appearance: "secondary",
      icon: "user",
      size: this.size
    }));
  }
  static get style() {
    return {
      base: WinkAvatarBaseStyle0,
      telenet: WinkAvatarTelenetStyle0
    };
  }
}, [33, "wink-avatar", {
  "src": [1],
  "size": [1]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-avatar", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-avatar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Avatar);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}
const WinkAvatar = Avatar;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 94870:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-badge.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkBadge: () => (/* binding */ WinkBadge),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.types.js */ 7988);


const BADGE_SIZES = {
  sm: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.sm,
  md: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.md,
  lg: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.lg
};
const BADGE_COLORS = {
  darkBrown: 'darkBrown',
  white: 'white',
  yellow: 'yellow',
  lemon: 'lemon',
  brightBlue: 'brightBlue',
  jeansBlue: 'jeansBlue',
  lila: 'lila',
  olivine: 'olivine',
  turquoise: 'turquoise',
  watermelon: 'watermelon'
};
const badgeBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block;padding:calc(var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-xs) * 1rem);background-color:#009793;color:#ffffff;font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Bold, Arial, sans-serif}:host([size=sm]){font-size:1.4rem;line-height:2rem}:host([size=md]){font-size:1.6rem;line-height:2.4rem}:host([size=lg]){font-size:2.4rem;line-height:3.2rem}";
const WinkBadgeBaseStyle0 = badgeBaseCss;
const badgeTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block;padding:calc(var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-xs) * 1rem);background-color:var(--semantic-color-background-surface-highlight-7);color:var(--semantic-color-text-inverse-on-brand);font-size:1.6rem;line-height:2.4rem;font-family:TelenetAlbra-Bold, Arial, sans-serif}:host([size=sm]){font-size:1.4rem;line-height:2rem}:host([size=md]){font-size:1.6rem;line-height:2.4rem}:host([size=lg]){font-size:2.4rem;line-height:3.2rem}:host([background=dark-brown]){background-color:var(--semantic-color-background-surface-highlight-7);color:var(--semantic-color-text-inverse-on-brand)}:host([background=white]){background-color:var(--semantic-color-background-surface-highlight-8);color:var(--semantic-color-text-default)}:host([background=yellow]){background-color:var(--semantic-color-background-canvas-brand);color:var(--semantic-color-text-default)}:host([background=lemon]){background-color:var(--semantic-color-background-canvas-accent);color:var(--semantic-color-text-default)}:host([background=bright-blue]){background-color:var(--semantic-color-background-surface-highlight-1);color:var(--semantic-color-text-default)}:host([background=jeans-blue]){background-color:var(--semantic-color-background-surface-highlight-4);color:var(--semantic-color-text-default)}:host([background=lila]){background-color:var(--semantic-color-background-surface-highlight-2);color:var(--semantic-color-text-default)}:host([background=olivine]){background-color:var(--semantic-color-background-surface-highlight-6);color:var(--semantic-color-text-default)}:host([background=turquoise]){background-color:var(--semantic-color-background-surface-highlight-4);color:var(--semantic-color-text-default)}:host([background=watermelon]){background-color:var(--semantic-color-background-surface-highlight-3);color:var(--semantic-color-text-default)}";
const WinkBadgeTelenetStyle0 = badgeTelenetCss;
const Badge = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class Badge extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.text = '';
    this.size = BADGE_SIZES.md;
    this.background = BADGE_COLORS.darkBrown;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: 'd5c1a7fe17540563ef8fde972b7531e302193dd5'
    }, this.text);
  }
  static get style() {
    return {
      base: WinkBadgeBaseStyle0,
      telenet: WinkBadgeTelenetStyle0
    };
  }
}, [33, "wink-badge", {
  "text": [1],
  "size": [1],
  "background": [1]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-badge"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-badge":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Badge);
        }
        break;
    }
  });
}
const WinkBadge = Badge;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 78323:
/*!*************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-button.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkButton: () => (/* binding */ WinkButton),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./animation.js */ 8071);

const WinkButton = _animation_js__WEBPACK_IMPORTED_MODULE_0__.B;
const defineCustomElement = _animation_js__WEBPACK_IMPORTED_MODULE_0__.a;


/***/ }),

/***/ 69904:
/*!**********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-check-box-group.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkCheckBoxGroup: () => (/* binding */ WinkCheckBoxGroup),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _positions_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./positions.types.js */ 46757);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./form-label.js */ 78529);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _validation_message_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validation-message.js */ 46024);






const checkBoxGroupBaseCss = ".sr-only.sc-wink-check-box-group-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-check-box-group-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-check-box-group-base-h{display:block}.sc-wink-check-box-group-base-h fieldset.sc-wink-check-box-group-base{margin:0;padding:0;border:0}.sc-wink-check-box-group-base-h legend.sc-wink-check-box-group-base{margin-bottom:calc(var(--semantic-spacing-xs) * 1rem);display:flex;width:100%}.sc-wink-check-box-group-base-h .check-box-group--horizontal.sc-wink-check-box-group-base,.sc-wink-check-box-group-base-h .check-box-group--vertical.sc-wink-check-box-group-base{display:inline-flex;flex-wrap:wrap}.sc-wink-check-box-group-base-h .check-box-group--vertical.sc-wink-check-box-group-base{flex-direction:column;gap:calc(var(--semantic-spacing-md) * 1rem)}.sc-wink-check-box-group-base-h .check-box-group--horizontal.sc-wink-check-box-group-base{flex-direction:row;gap:calc(var(--semantic-spacing-xl) * 1rem)}";
const WinkCheckBoxGroupBaseStyle0 = checkBoxGroupBaseCss;
const checkBoxGroupTelenetCss = ".sr-only.sc-wink-check-box-group-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-check-box-group-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-check-box-group-telenet-h{display:block}.sc-wink-check-box-group-telenet-h fieldset.sc-wink-check-box-group-telenet{margin:0;padding:0;border:0}.sc-wink-check-box-group-telenet-h legend.sc-wink-check-box-group-telenet{margin-bottom:calc(var(--semantic-spacing-xs) * 1rem);display:flex;width:100%}.sc-wink-check-box-group-telenet-h .check-box-group--horizontal.sc-wink-check-box-group-telenet,.sc-wink-check-box-group-telenet-h .check-box-group--vertical.sc-wink-check-box-group-telenet{display:inline-flex;flex-wrap:wrap}.sc-wink-check-box-group-telenet-h .check-box-group--vertical.sc-wink-check-box-group-telenet{flex-direction:column;gap:calc(var(--semantic-spacing-md) * 1rem)}.sc-wink-check-box-group-telenet-h .check-box-group--horizontal.sc-wink-check-box-group-telenet{flex-direction:row;gap:calc(var(--semantic-spacing-xl) * 1rem)}";
const WinkCheckBoxGroupTelenetStyle0 = checkBoxGroupTelenetCss;
const CheckBoxGroup = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.proxyCustomElement)(class CheckBoxGroup extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.label = '';
    this.helper = '';
    this.direction = _positions_types_js__WEBPACK_IMPORTED_MODULE_1__.D.vertical;
    this.error = undefined;
    this.isRequired = false;
    this.optionalText = 'Optioneel';
  }
  internals;
  setValidation(errorMsg) {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (errorMsg) {
        _this.error = errorMsg;
      } else {
        _this.error = '';
      }
    })();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("fieldset", {
      key: 'd7f5fa5db666b4c44c65794b26d89558fc95e00c'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("legend", {
      key: 'c123bc97caf59f4e07715fd3fb5567bbdbf56096',
      class: "check-box-group__wrapper"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-form-label", {
      key: 'e321c64e5cf4cde27ebbe86779999826a3619c32',
      label: this.label,
      helper: this.helper,
      "show-optional": !this.isRequired,
      "optional-text": this.optionalText
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      key: 'ca479c96280af57731b88bc4aa0b2fbfee0e829a',
      class: `check-box-group--${this.direction}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("slot", {
      key: '245b88689fd91bfe99bb6570a763207b30fe2438'
    })), this.error && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-validation-message", {
      message: this.error,
      type: "error"
    }));
  }
  static get style() {
    return {
      base: WinkCheckBoxGroupBaseStyle0,
      telenet: WinkCheckBoxGroupTelenetStyle0
    };
  }
}, [38, "wink-check-box-group", {
  "label": [1],
  "helper": [1],
  "direction": [1],
  "error": [1537],
  "isRequired": [4, "is-required"],
  "optionalText": [1, "optional-text"],
  "setValidation": [64]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-check-box-group", "wink-form-label", "wink-icon", "wink-validation-message"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-check-box-group":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, CheckBoxGroup);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-validation-message":
        if (!customElements.get(tagName)) {
          (0,_validation_message_js__WEBPACK_IMPORTED_MODULE_4__.d)();
        }
        break;
    }
  });
}
const WinkCheckBoxGroup = CheckBoxGroup;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 11597:
/*!****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-check-box.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkCheckBox: () => (/* binding */ WinkCheckBox),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./form-label.js */ 78529);


const checkBoxBaseCss = ".sr-only.sc-wink-check-box-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-check-box-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-check-box-base-h{display:block}.sc-wink-check-box-base-h label.sc-wink-check-box-base{display:flex;align-items:center;justify-content:flex-start;cursor:pointer;padding:0}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base{display:inline-block;flex-shrink:0;align-self:flex-start;appearance:none;background-color:var(--semantic-color-background-surface-neutral-default);cursor:pointer;width:2rem;height:2rem;border:0.2rem solid var(--semantic-color-border-form-default);padding:0;margin:0 calc(var(--semantic-spacing-xs) * 1rem) 0 0;color:var(--semantic-color-border-form-selected);border-radius:0;box-sizing:content-box}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base::before{content:\"\";position:absolute;box-sizing:border-box}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:hover{border:0.2rem solid var(--semantic-color-border-highlight)}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:checked{background:var(--semantic-color-background-surface-action-default);border-color:var(--semantic-color-border-form-selected)}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:checked::before{width:1.2rem;height:1.2rem;margin-top:0.4rem;margin-left:0.4rem;background-size:cover;background-image:url(\"data:image/svg+xml,%3Csvg width='10' height='10' viewBox='0 0 10 10' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M8.99485 0.631188C9.47477 0.904479 9.64228 1.51508 9.36899 1.99501L5.38288 8.99501C5.22451 9.27313 4.94257 9.45864 4.62448 9.49404C4.30639 9.52943 3.99058 9.41043 3.77494 9.17393L0.761051 5.86837C0.388947 5.46026 0.418139 4.82777 0.826253 4.45566C1.23437 4.08356 1.86686 4.11275 2.23896 4.52086L4.32579 6.80964L7.63102 1.00533C7.90431 0.525407 8.51492 0.357896 8.99485 0.631188Z' fill='%23291D18'/%3E%3C/svg%3E%0A\")}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:focus{border-color:var(--semantic-color-border-form-default)}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:focus:checked{border-color:var(--semantic-color-border-form-selected)}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:focus,.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:focus:checked{outline:0.2rem solid var(--semantic-color-border-focus);outline-offset:0.2rem}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:invalid,.sc-wink-check-box-base-h input[type=checkbox][aria-invalid].sc-wink-check-box-base,.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:invalid:checked,.sc-wink-check-box-base-h input[type=checkbox][aria-invalid].sc-wink-check-box-base:checked,.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:invalid:hover,.sc-wink-check-box-base-h input[type=checkbox][aria-invalid].sc-wink-check-box-base:hover,.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:invalid:checked:hover,.sc-wink-check-box-base-h input[type=checkbox][aria-invalid].sc-wink-check-box-base:checked:hover,.sc-wink-check-box-base-h input[type=checkbox][aria-invalid].sc-wink-check-box-base:disabled:hover{border-color:var(--semantic-color-border-error)}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:invalid:checked,.sc-wink-check-box-base-h input[type=checkbox][aria-invalid].sc-wink-check-box-base:checked{background-color:var(--semantic-color-background-surface-neutral-default)}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:invalid:checked::before,.sc-wink-check-box-base-h input[type=checkbox][aria-invalid].sc-wink-check-box-base:checked::before{background-image:url(\"data:image/svg+xml,%3Csvg width='10' height='10' viewBox='0 0 10 10' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M8.99485 0.631188C9.47477 0.904479 9.64228 1.51508 9.36899 1.99501L5.38288 8.99501C5.22451 9.27313 4.94257 9.45864 4.62448 9.49404C4.30639 9.52943 3.99058 9.41043 3.77494 9.17393L0.761051 5.86837C0.388947 5.46026 0.418139 4.82777 0.826253 4.45566C1.23437 4.08356 1.86686 4.11275 2.23896 4.52086L4.32579 6.80964L7.63102 1.00533C7.90431 0.525407 8.51492 0.357896 8.99485 0.631188Z' fill='%23DE350B'/%3E%3C/svg%3E%0A\")}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:disabled,.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:disabled~*.sc-wink-check-box-base{opacity:calc((var(--semantic-opacity-disabled)) / 10);cursor:not-allowed}.sc-wink-check-box-base-h input[type=checkbox].sc-wink-check-box-base:disabled:hover{border:0.2rem solid #766f6b}";
const WinkCheckBoxBaseStyle0 = checkBoxBaseCss;
const checkBoxTelenetCss = ".sr-only.sc-wink-check-box-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-check-box-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-check-box-telenet-h{display:block}.sc-wink-check-box-telenet-h label.sc-wink-check-box-telenet{display:flex;align-items:center;justify-content:flex-start;cursor:pointer;padding:0}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet{display:inline-block;flex-shrink:0;align-self:flex-start;appearance:none;background-color:var(--semantic-color-background-surface-neutral-default);cursor:pointer;width:2rem;height:2rem;border:0.2rem solid var(--semantic-color-border-form-default);padding:0;margin:0 calc(var(--semantic-spacing-xs) * 1rem) 0 0;color:var(--semantic-color-border-form-selected);border-radius:0;box-sizing:content-box}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet::before{content:\"\";position:absolute;box-sizing:border-box}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:hover{border:0.2rem solid var(--semantic-color-border-highlight)}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:checked{background:var(--semantic-color-background-surface-action-default);border-color:var(--semantic-color-border-form-selected)}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:checked::before{width:1.2rem;height:1.2rem;margin-top:0.4rem;margin-left:0.4rem;background-size:cover;background-image:url(\"data:image/svg+xml,%3Csvg width='10' height='10' viewBox='0 0 10 10' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M8.99485 0.631188C9.47477 0.904479 9.64228 1.51508 9.36899 1.99501L5.38288 8.99501C5.22451 9.27313 4.94257 9.45864 4.62448 9.49404C4.30639 9.52943 3.99058 9.41043 3.77494 9.17393L0.761051 5.86837C0.388947 5.46026 0.418139 4.82777 0.826253 4.45566C1.23437 4.08356 1.86686 4.11275 2.23896 4.52086L4.32579 6.80964L7.63102 1.00533C7.90431 0.525407 8.51492 0.357896 8.99485 0.631188Z' fill='%23291D18'/%3E%3C/svg%3E%0A\")}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:focus{border-color:var(--semantic-color-border-form-default)}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:focus:checked{border-color:var(--semantic-color-border-form-selected)}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:focus,.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:focus:checked{outline:0.2rem solid var(--semantic-color-border-focus);outline-offset:0.2rem}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:invalid,.sc-wink-check-box-telenet-h input[type=checkbox][aria-invalid].sc-wink-check-box-telenet,.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:invalid:checked,.sc-wink-check-box-telenet-h input[type=checkbox][aria-invalid].sc-wink-check-box-telenet:checked,.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:invalid:hover,.sc-wink-check-box-telenet-h input[type=checkbox][aria-invalid].sc-wink-check-box-telenet:hover,.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:invalid:checked:hover,.sc-wink-check-box-telenet-h input[type=checkbox][aria-invalid].sc-wink-check-box-telenet:checked:hover,.sc-wink-check-box-telenet-h input[type=checkbox][aria-invalid].sc-wink-check-box-telenet:disabled:hover{border-color:var(--semantic-color-border-error)}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:invalid:checked,.sc-wink-check-box-telenet-h input[type=checkbox][aria-invalid].sc-wink-check-box-telenet:checked{background-color:var(--semantic-color-background-surface-neutral-default)}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:invalid:checked::before,.sc-wink-check-box-telenet-h input[type=checkbox][aria-invalid].sc-wink-check-box-telenet:checked::before{background-image:url(\"data:image/svg+xml,%3Csvg width='10' height='10' viewBox='0 0 10 10' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M8.99485 0.631188C9.47477 0.904479 9.64228 1.51508 9.36899 1.99501L5.38288 8.99501C5.22451 9.27313 4.94257 9.45864 4.62448 9.49404C4.30639 9.52943 3.99058 9.41043 3.77494 9.17393L0.761051 5.86837C0.388947 5.46026 0.418139 4.82777 0.826253 4.45566C1.23437 4.08356 1.86686 4.11275 2.23896 4.52086L4.32579 6.80964L7.63102 1.00533C7.90431 0.525407 8.51492 0.357896 8.99485 0.631188Z' fill='%23DE350B'/%3E%3C/svg%3E%0A\")}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:disabled,.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:disabled~*.sc-wink-check-box-telenet{opacity:calc((var(--semantic-opacity-disabled)) / 10);cursor:not-allowed}.sc-wink-check-box-telenet-h input[type=checkbox].sc-wink-check-box-telenet:disabled:hover{border:0.2rem solid #766f6b}";
const WinkCheckBoxTelenetStyle0 = checkBoxTelenetCss;
const CheckBox = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class CheckBox extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.label = '';
    this.helper = '';
    this.checkboxId = '';
    this.name = '';
    this.checked = false;
    this.error = false;
    this.disabled = false;
  }
  internals;
  get host() {
    return this;
  }
  handleKeyDown = e => {
    if (e.key === 'Enter') {
      this.host?.querySelector('input')?.click();
    }
  };
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("label", {
      key: '05799f25e823d41da196068d0518f459d092a3dd'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("input", {
      key: '424783c05fa92dbb1f5be256b4e3e39954ba1670',
      type: "checkbox",
      checked: this.checked,
      disabled: this.disabled,
      "aria-invalid": this.error,
      id: this.checkboxId,
      name: this.name,
      value: this.label,
      onKeyDown: this.handleKeyDown
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("wink-form-label", {
      key: '9f930c283f86e38f1ad55a1c5f0fd298f0856bea',
      label: this.label,
      helper: this.helper,
      rendition: _form_label_js__WEBPACK_IMPORTED_MODULE_0__.F.subComponent
    }));
  }
  static get style() {
    return {
      base: WinkCheckBoxBaseStyle0,
      telenet: WinkCheckBoxTelenetStyle0
    };
  }
}, [34, "wink-check-box", {
  "label": [1],
  "helper": [1],
  "checkboxId": [1, "checkbox-id"],
  "name": [1],
  "checked": [516],
  "error": [4],
  "disabled": [4]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-check-box", "wink-form-label"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-check-box":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, CheckBox);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_0__.d)();
        }
        break;
    }
  });
}
const WinkCheckBox = CheckBox;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 23443:
/*!*******************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-column-count.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkColumnCount: () => (/* binding */ WinkColumnCount),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);

const columnCountBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host .cols{column-count:4;column-width:27rem;column-gap:calc(var(--semantic-spacing-lg) * 1rem)}:host .cols.cols-count-1{column-count:1}:host .cols.cols-count-2{column-count:2}:host .cols.cols-count-3{column-count:3}:host .cols ::slotted(*){display:block;break-inside:avoid;margin-bottom:calc(var(--semantic-spacing-lg) * 1rem)}";
const WinkColumnCountBaseStyle0 = columnCountBaseCss;
const columnCountTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host .cols{column-count:4;column-width:27rem;column-gap:calc(var(--semantic-spacing-lg) * 1rem)}:host .cols.cols-count-1{column-count:1}:host .cols.cols-count-2{column-count:2}:host .cols.cols-count-3{column-count:3}:host .cols ::slotted(*){display:block;break-inside:avoid;margin-bottom:calc(var(--semantic-spacing-lg) * 1rem)}";
const WinkColumnCountTelenetStyle0 = columnCountTelenetCss;
const ColumnCount = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.proxyCustomElement)(class ColumnCount extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.colsCount = 4;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.Host, {
      key: 'b53b2099581d0bb5b0ff1a70816ddb9d8be1ab61'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("div", {
      key: 'f3c57f327fe321ed194731f23086b790fbab268f',
      class: {
        cols: true,
        [`cols-count-${this.colsCount}`]: true
      }
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)("slot", {
      key: 'e1908de58c90848196e9c128441872357eb5b33d'
    })));
  }
  static get style() {
    return {
      base: WinkColumnCountBaseStyle0,
      telenet: WinkColumnCountTelenetStyle0
    };
  }
}, [33, "wink-column-count", {
  "colsCount": [2, "cols-count"]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-column-count"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-column-count":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ColumnCount);
        }
        break;
    }
  });
}
const WinkColumnCount = ColumnCount;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 96589:
/*!***************************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-customer-orientation.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkCustomerOrientation: () => (/* binding */ WinkCustomerOrientation),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _dropdown_menu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dropdown-menu.js */ 84878);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./link.js */ 37232);




const customerOrientationBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem)}";
const WinkCustomerOrientationBaseStyle0 = customerOrientationBaseCss;
const customerOrientationTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem)}";
const WinkCustomerOrientationTelenetStyle0 = customerOrientationTelenetCss;
const CustomerOrientation = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.proxyCustomElement)(class CustomerOrientation extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.Host, {
      key: '542153bceb3a8be168fb0c69e37ec0167710e5fb'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-dropdown-menu", {
      key: '21cb755809796f4d3766e2a6c0ee3c50cd20c1b0',
      heading: "Particulieren",
      "item-selected": "Particulieren",
      "list-position": "left"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-link", {
      key: '5c9e70a069d0248563578b6786be30e2a31f7b6f',
      appearance: "dropdown-menu-link"
    }, "Particulieren"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-link", {
      key: '89f5e576d2d18090b4b065824188a4965fc3d07d',
      appearance: "dropdown-menu-link"
    }, "Zelfstandigen"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-link", {
      key: 'd8dc29f6faf20f6730897eb5a98cce43a1777041',
      appearance: "dropdown-menu-link"
    }, "Bedrijven")), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-dropdown-menu", {
      key: 'cfaca4e27040ca50940672c7e4ca2cd71fb031fe',
      heading: "Alle websites",
      "item-selected": "Alle websites",
      "list-position": "left"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-link", {
      key: 'cfa23a104b7e94f53159bd213535b453ec3cb338',
      appearance: "dropdown-menu-link"
    }, "Alle websites"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-link", {
      key: '7ba33ff27fdd1cb7b9038388fc7342a646137f05',
      appearance: "dropdown-menu-link"
    }, "Play sports"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-link", {
      key: '007d2ff70e8dbab97245579b06b7dc914d744861',
      appearance: "dropdown-menu-link"
    }, "Telenet-apps")));
  }
  static get style() {
    return {
      base: WinkCustomerOrientationBaseStyle0,
      telenet: WinkCustomerOrientationTelenetStyle0
    };
  }
}, [33, "wink-customer-orientation"]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-customer-orientation", "wink-dropdown-menu", "wink-icon", "wink-link"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-customer-orientation":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, CustomerOrientation);
        }
        break;
      case "wink-dropdown-menu":
        if (!customElements.get(tagName)) {
          (0,_dropdown_menu_js__WEBPACK_IMPORTED_MODULE_0__.d)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
      case "wink-link":
        if (!customElements.get(tagName)) {
          (0,_link_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
    }
  });
}
const WinkCustomerOrientation = CustomerOrientation;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 35815:
/*!********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-dropdown-menu.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkDropdownMenu: () => (/* binding */ WinkDropdownMenu),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _dropdown_menu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dropdown-menu.js */ 84878);

const WinkDropdownMenu = _dropdown_menu_js__WEBPACK_IMPORTED_MODULE_0__.D;
const defineCustomElement = _dropdown_menu_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 83167:
/*!*************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-flyout.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkFlyout: () => (/* binding */ WinkFlyout),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _media_query_detector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-query-detector.js */ 20462);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./link.js */ 37232);




const flyoutBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}@keyframes fadeIn{from{opacity:0}to{opacity:1}}:host{display:grid;grid-template-rows:var(--host-grid-template-rows, 0fr);background:var(--semantic-color-background-canvas-default);overflow:hidden;opacity:var(--host-opacity, 0);z-index:var(--host-z-index, 0);transition:all 0.3s ease}@media only screen and (max-width: calc(64em - 1px)){:host{display:none}}@media only screen and (max-width: calc(64em - 1px)){:host .container{display:contents}}@media only screen and (min-width: 64em){:host .container{min-height:0}}:host .content{display:grid;gap:calc(var(--semantic-spacing-lg) * 1rem);grid-auto-columns:1fr}@media only screen and (min-width: 64em){:host .content{grid-auto-flow:column;padding:4rem 0 1.6rem}}:host wink-link[appearance=menu-back]{display:block;position:sticky;top:0;background-color:#f8f8f8}@media only screen and (min-width: 64em){:host wink-link[appearance=menu-back]{display:none}}:host([open]){--host-grid-template-rows:1fr;--host-opacity:1;--host-z-index:1}@media only screen and (max-width: calc(64em - 1px)){:host([open]){display:contents}}";
const WinkFlyoutBaseStyle0 = flyoutBaseCss;
const flyoutTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}@keyframes fadeIn{from{opacity:0}to{opacity:1}}:host{display:grid;grid-template-rows:var(--host-grid-template-rows, 0fr);background:var(--semantic-color-background-canvas-default);overflow:hidden;opacity:var(--host-opacity, 0);z-index:var(--host-z-index, 0);transition:all 0.3s ease}@media only screen and (max-width: calc(64em - 1px)){:host{display:none}}@media only screen and (max-width: calc(64em - 1px)){:host .container{display:contents}}@media only screen and (min-width: 64em){:host .container{min-height:0}}:host .content{display:grid;gap:calc(var(--semantic-spacing-lg) * 1rem);grid-auto-columns:1fr}@media only screen and (min-width: 64em){:host .content{grid-auto-flow:column;padding:4rem 0 1.6rem}}:host wink-link[appearance=menu-back]{display:block;position:sticky;top:0;background-color:#f8f8f8}@media only screen and (min-width: 64em){:host wink-link[appearance=menu-back]{display:none}}:host([open]){--host-grid-template-rows:1fr;--host-opacity:1;--host-z-index:1}@media only screen and (max-width: calc(64em - 1px)){:host([open]){display:contents}}";
const WinkFlyoutTelenetStyle0 = flyoutTelenetCss;
const Flyout = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.proxyCustomElement)(class Flyout extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.flyoutBackLinkClicked = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.createEvent)(this, "flyoutBackLinkClicked", 7);
    this.flyoutId = undefined;
    this.activeId = undefined;
    this.backLabel = undefined;
    this.isFlyoutOpen = false;
    this.focusableElements = [];
    this.focusedElementTracker = 0;
  }
  get host() {
    return this;
  }
  flyoutBackLinkClicked;
  handleMainNavigationItemClicked(event) {
    this.activeId = event.detail.index;
    this.backLabel = event.detail.name;
    this.isFlyoutOpen = this.flyoutId === this.activeId;
    if (event.detail.eventType === 'mouse') {
      return;
    }
    if (this.shouldFetchFocusableElements()) {
      this.getAllFocusableElements();
    } else {
      this.resetFocusableElements();
    }
    this.focusOnElement();
  }
  shouldFetchFocusableElements() {
    return !this.focusableElements.length && _media_query_detector_js__WEBPACK_IMPORTED_MODULE_0__.M.isFromMdHeader && this.isFlyoutOpen && !this.host.getAttribute('slot')?.includes('mobile');
  }
  resetFocusableElements() {
    this.focusableElements = [];
    this.focusedElementTracker = 0;
  }
  focusOnElement() {
    if (this.focusableElements.length) {
      this.focusableElements[this.focusedElementTracker].focus();
    }
  }
  getAllFocusableElements() {
    const focusableQuery = 'a, button, [tabindex]:not([tabindex="-1"])';
    this.host.querySelectorAll('wink-navigation-list')?.forEach(list => {
      list.shadowRoot.querySelectorAll('wink-navigation-list-item').forEach(item => {
        this.focusableElements.push(item.shadowRoot.querySelector(focusableQuery));
      });
    });
  }
  handleKeyDown(e) {
    const {
      code,
      shiftKey
    } = e;
    const {
      length
    } = this.focusableElements;
    if (code === 'Escape') {
      this.closeFlyout();
      this.resetFlyout();
    }
    if (code === 'ArrowDown' || code === 'ArrowUp' || code === 'Tab') {
      e.preventDefault();
      this.focusedElementTracker += code === 'ArrowDown' || code === 'Tab' && !shiftKey ? 1 : -1;
      this.focusedElementTracker = (this.focusedElementTracker + length) % length;
      this.focusableElements[this.focusedElementTracker].focus();
    }
  }
  resetFlyout() {
    this.activeId = undefined;
    this.isFlyoutOpen = false;
    this.focusableElements = [];
    this.focusedElementTracker = 0;
  }
  closeFlyout() {
    this.resetFlyout();
    this.flyoutBackLinkClicked?.emit({
      eventType: 'keyboard'
    });
  }
  handleFlyoutMouseLeave() {
    if (_media_query_detector_js__WEBPACK_IMPORTED_MODULE_0__.M.isUntilMdHeader) {
      return;
    }
    this.resetFlyout();
    this.flyoutBackLinkClicked?.emit({
      eventType: 'mouse'
    });
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.Host, {
      key: 'b3f8de09ea87e0737c3e2afc3e1187a048a80e1a',
      id: `flyout-${this.flyoutId}`,
      tabindex: "-1",
      "aria-label": this.flyoutId === this.activeId ? this.backLabel : ' ',
      onMouseLeave: this.handleFlyoutMouseLeave.bind(this),
      open: this.isFlyoutOpen
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      key: '05db9b329e56b761af5d89c94c2b8f4232f3da69',
      class: "container"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      key: '029ad3b6f9e9209d502a89316276604c35f56e6b',
      class: "content"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-link", {
      key: '06a63c15351212b1bd808ad3f3e1cc36930d19f3',
      onClick: this.closeFlyout.bind(this),
      appearance: "menu-back",
      icon: "arrow-left",
      size: "caption-bold",
      "icon-position": "left",
      "icon-appearance": "default",
      "is-disabled": "false",
      href: "#"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-icon", {
      key: '4fb7df087966f6cb30f105f69c021c777d55c997',
      slot: "link-icon",
      appearance: "default",
      icon: "arrow-left",
      size: "md",
      exportparts: "icon, icon-arrow-left"
    }), this.backLabel), Array.from({
      length: 4
    }).map((_, index) => (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      name: `col-${index + 1}`
    })))));
  }
  static get style() {
    return {
      base: WinkFlyoutBaseStyle0,
      telenet: WinkFlyoutTelenetStyle0
    };
  }
}, [33, "wink-flyout", {
  "flyoutId": [2, "flyout-id"],
  "activeId": [32],
  "backLabel": [32],
  "isFlyoutOpen": [32],
  "focusableElements": [32],
  "focusedElementTracker": [32]
}, [[4, "mainNavigationItemClicked", "handleMainNavigationItemClicked"], [0, "keydown", "handleKeyDown"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-flyout", "wink-icon", "wink-link"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-flyout":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Flyout);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
      case "wink-link":
        if (!customElements.get(tagName)) {
          (0,_link_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
    }
  });
}
const WinkFlyout = Flyout;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 7823:
/*!*****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-form-label.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkFormLabel: () => (/* binding */ WinkFormLabel),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./form-label.js */ 78529);

const WinkFormLabel = _form_label_js__WEBPACK_IMPORTED_MODULE_0__.a;
const defineCustomElement = _form_label_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 34605:
/*!********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-global-header.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkGlobalHeader: () => (/* binding */ WinkGlobalHeader),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.js */ 45477);


const globalHeaderBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{--wink-logo-width:4rem;--wink-dropdown-font-size:1.4rem;--wink-dropdown-bg-color:var(--semantic-color-background-canvas-default);--wink-dropdown-color:var(--semantic-color-text-subtlest);display:flex;flex-direction:column;align-content:stretch;gap:calc(var(--semantic-spacing-xs) * 1rem);position:relative;max-width:113.2rem;margin:auto;box-sizing:border-box;z-index:99999;isolation:isolate}@media only screen and (max-width: calc(64em - 1px)){:host{--wink-button--sm-fs:1.4rem;--wink-button--sm-lh:2rem}}@media only screen and (min-width: 64em){:host{--wink-button--sm-fs:1.6rem;--wink-button--sm-lh:2.4rem}}:host .mobile-row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;align-items:center;align-content:center;gap:1.6rem;position:fixed;top:0;left:0;right:0;z-index:100;height:4rem;padding:1.2rem 1.6rem;border-bottom:1px solid var(--semantic-color-border-subtle)}:host .mobile-row:has(input.mobile-hamburger-button:checked){background:var(--semantic-color-background-surface-subtle-default);border-bottom:none}:host .mobile-row .mobile-row-right{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;align-content:center;gap:1.6rem}:host .mobile-row .mobile-row-right ::slotted([slot=main-navigation]){display:contents}:host .mobile-row .mobile-row-right:has(input.mobile-hamburger-button:checked) ::slotted([slot=mobile-search]),:host .mobile-row .mobile-row-right:has(input.mobile-hamburger-button:checked) ::slotted([slot=mobile-customer-zone]){display:none}:host .mobile-row .mobile-hamburger{position:relative;width:4rem;height:4rem}:host .mobile-row .mobile-hamburger .mobile-hamburger-button{display:block;width:4rem;height:4rem;position:absolute;top:0;left:0;cursor:pointer;-webkit-touch-callout:none}:host .mobile-row .mobile-hamburger input.mobile-hamburger-button{margin:0;z-index:1000;opacity:0}:host .mobile-row .mobile-hamburger wink-icon.mobile-hamburger-button{z-index:500}:host .mobile-row .mobile-hamburger wink-icon.open{display:block}:host .mobile-row .mobile-hamburger wink-icon.close{display:none}:host .mobile-row .mobile-hamburger .mobile-fly-out{display:none}:host .mobile-row .mobile-hamburger input:checked~wink-icon.open{display:none}:host .mobile-row .mobile-hamburger input:checked~wink-icon.close{display:block}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out{display:flex;flex-direction:column;justify-content:space-between;position:fixed;top:0;left:0;right:0;bottom:0;z-index:200;animation:growDown 300ms ease-in-out forwards;transform-origin:top right;background:var(--semantic-color-background-surface-subtle-default);padding:2.4rem 1.6rem;overflow:auto;margin-top:6.4rem}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top{display:grid;grid-auto-flow:column;overflow-x:hidden;overflow-y:auto;isolation:isolate}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top>*{grid-area:1/1/2/2;background-color:#f8f8f8}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top-main{display:flex;flex-direction:column;gap:2.4rem;position:relative;overflow:auto;animation:1s fadeIn;animation-fill-mode:forwards;visibility:hidden}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top-sub-nav{z-index:1;transform:translateX(110%);transition:0.3s}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top-sub-nav[open]{transform:translateX(0%)}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-bottom{display:flex;flex-direction:row;gap:1.6rem;animation:1s fadeIn;animation-fill-mode:forwards;visibility:hidden}@keyframes growDown{0%{transform:scaleY(0)}80%{transform:scaleY(1.1)}100%{transform:scaleY(1)}}@keyframes fadeIn{0%{opacity:0}100%{visibility:visible;opacity:1}}:host .mobile-row ::slotted([slot=mobile-brand]){z-index:500}:host .top-row,:host .bottom-row{display:none}:host .top-row,:host .bottom-row,:host .mobile-row{justify-content:space-between;gap:calc(var(--semantic-spacing-xs) * 1rem)}:host .flyout-container{display:contents}@media only screen and (min-width: 48.0625em){:host .flyout-container{display:grid;position:absolute;top:100%;left:0;right:0;max-width:113.2rem;background:var(--semantic-color-background-canvas-default);transition:all 0.3s ease}:host .flyout-container>::slotted([slot=flyout]){grid-area:1/1/2/2}:host .flyout-container::after{content:\"\";position:absolute;width:100vw;height:100%;left:50%;top:var(--after-top, 0);transform:translateX(-50%);background:var(--semantic-color-background-canvas-default);border-bottom:0.1rem solid var(--semantic-color-border-subtle);z-index:var(--pannel-after-z-index, -3)}}:host ::slotted([slot=main-navigation]),:host ::slotted([slot=customer-orientation]){margin-right:auto}:host ::slotted([slot=search]){margin-left:auto}@media only screen and (min-width: 64em){:host ::slotted([slot=search]){width:160px}}:host ::slotted([slot=brand]){padding:calc(var(--semantic-spacing-xs) * 1rem) 0}@media only screen and (min-width: 64em){:host{--wink-logo-width:4.8rem}:host ::slotted([slot=main-navigation]){display:contents;margin-right:auto}:host .mobile-row{display:none}:host .top-row,:host .bottom-row{display:flex;align-items:center}}:host(.compact){flex-direction:row-reverse}:host(.compact) .bottom-row{flex-grow:1}:host(.minimal) .mobile-hamburger{position:relative;width:auto;height:auto}:host(.minimal) .mobile-hamburger .mobile-hamburger-button.open{display:none}:host(.minimal) .mobile-hamburger .mobile-fly-out{display:block}";
const WinkGlobalHeaderBaseStyle0 = globalHeaderBaseCss;
const globalHeaderTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{--wink-logo-width:4rem;--wink-dropdown-font-size:1.4rem;--wink-dropdown-bg-color:var(--semantic-color-background-canvas-default);--wink-dropdown-color:var(--semantic-color-text-subtlest);display:flex;flex-direction:column;align-content:stretch;gap:calc(var(--semantic-spacing-xs) * 1rem);position:relative;max-width:113.2rem;margin:auto;box-sizing:border-box;z-index:99999;isolation:isolate}@media only screen and (max-width: calc(64em - 1px)){:host{--wink-button--sm-fs:1.4rem;--wink-button--sm-lh:2rem}}@media only screen and (min-width: 64em){:host{--wink-button--sm-fs:1.6rem;--wink-button--sm-lh:2.4rem}}:host .mobile-row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;align-items:center;align-content:center;gap:1.6rem;position:fixed;top:0;left:0;right:0;z-index:100;height:4rem;padding:1.2rem 1.6rem;border-bottom:1px solid var(--semantic-color-border-subtle)}:host .mobile-row:has(input.mobile-hamburger-button:checked){background:var(--semantic-color-background-surface-subtle-default);border-bottom:none}:host .mobile-row .mobile-row-right{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;align-content:center;gap:1.6rem}:host .mobile-row .mobile-row-right ::slotted([slot=main-navigation]){display:contents}:host .mobile-row .mobile-row-right:has(input.mobile-hamburger-button:checked) ::slotted([slot=mobile-search]),:host .mobile-row .mobile-row-right:has(input.mobile-hamburger-button:checked) ::slotted([slot=mobile-customer-zone]){display:none}:host .mobile-row .mobile-hamburger{position:relative;width:4rem;height:4rem}:host .mobile-row .mobile-hamburger .mobile-hamburger-button{display:block;width:4rem;height:4rem;position:absolute;top:0;left:0;cursor:pointer;-webkit-touch-callout:none}:host .mobile-row .mobile-hamburger input.mobile-hamburger-button{margin:0;z-index:1000;opacity:0}:host .mobile-row .mobile-hamburger wink-icon.mobile-hamburger-button{z-index:500}:host .mobile-row .mobile-hamburger wink-icon.open{display:block}:host .mobile-row .mobile-hamburger wink-icon.close{display:none}:host .mobile-row .mobile-hamburger .mobile-fly-out{display:none}:host .mobile-row .mobile-hamburger input:checked~wink-icon.open{display:none}:host .mobile-row .mobile-hamburger input:checked~wink-icon.close{display:block}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out{display:flex;flex-direction:column;justify-content:space-between;position:fixed;top:0;left:0;right:0;bottom:0;z-index:200;animation:growDown 300ms ease-in-out forwards;transform-origin:top right;background:var(--semantic-color-background-surface-subtle-default);padding:2.4rem 1.6rem;overflow:auto;margin-top:6.4rem}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top{display:grid;grid-auto-flow:column;overflow-x:hidden;overflow-y:auto;isolation:isolate}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top>*{grid-area:1/1/2/2;background-color:#f8f8f8}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top-main{display:flex;flex-direction:column;gap:2.4rem;position:relative;overflow:auto;animation:1s fadeIn;animation-fill-mode:forwards;visibility:hidden}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top-sub-nav{z-index:1;transform:translateX(110%);transition:0.3s}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-top-sub-nav[open]{transform:translateX(0%)}:host .mobile-row .mobile-hamburger input:checked~.mobile-fly-out .mobile-fly-out-bottom{display:flex;flex-direction:row;gap:1.6rem;animation:1s fadeIn;animation-fill-mode:forwards;visibility:hidden}@keyframes growDown{0%{transform:scaleY(0)}80%{transform:scaleY(1.1)}100%{transform:scaleY(1)}}@keyframes fadeIn{0%{opacity:0}100%{visibility:visible;opacity:1}}:host .mobile-row ::slotted([slot=mobile-brand]){z-index:500}:host .top-row,:host .bottom-row{display:none}:host .top-row,:host .bottom-row,:host .mobile-row{justify-content:space-between;gap:calc(var(--semantic-spacing-xs) * 1rem)}:host .flyout-container{display:contents}@media only screen and (min-width: 48.0625em){:host .flyout-container{display:grid;position:absolute;top:100%;left:0;right:0;max-width:113.2rem;background:var(--semantic-color-background-canvas-default);transition:all 0.3s ease}:host .flyout-container>::slotted([slot=flyout]){grid-area:1/1/2/2}:host .flyout-container::after{content:\"\";position:absolute;width:100vw;height:100%;left:50%;top:var(--after-top, 0);transform:translateX(-50%);background:var(--semantic-color-background-canvas-default);border-bottom:0.1rem solid var(--semantic-color-border-subtle);z-index:var(--pannel-after-z-index, -3)}}:host ::slotted([slot=main-navigation]),:host ::slotted([slot=customer-orientation]){margin-right:auto}:host ::slotted([slot=search]){margin-left:auto}@media only screen and (min-width: 64em){:host ::slotted([slot=search]){width:160px}}:host ::slotted([slot=brand]){padding:calc(var(--semantic-spacing-xs) * 1rem) 0}@media only screen and (min-width: 64em){:host{--wink-logo-width:4.8rem}:host ::slotted([slot=main-navigation]){display:contents;margin-right:auto}:host .mobile-row{display:none}:host .top-row,:host .bottom-row{display:flex;align-items:center}}:host(.compact){flex-direction:row-reverse}:host(.compact) .bottom-row{flex-grow:1}:host(.minimal) .mobile-hamburger{position:relative;width:auto;height:auto}:host(.minimal) .mobile-hamburger .mobile-hamburger-button.open{display:none}:host(.minimal) .mobile-hamburger .mobile-fly-out{display:block}";
const WinkGlobalHeaderTelenetStyle0 = globalHeaderTelenetCss;
const GlobalHeader = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class GlobalHeader extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.hasCustomerOrientation = false;
    this.hasIntentBar = false;
    this.hasCustomerZone = false;
    this.hasLanguage = false;
    this.hasBrand = false;
    this.hasMainNavigation = false;
    this.hasSearch = false;
    this.hasCallToAction = false;
    this.hasTopNavigation = false;
    this.hasMobileCustomerOrientation = false;
    this.hasMobileIntentBar = false;
    this.hasMobileCustomerZone = false;
    this.hasMobileLanguage = false;
    this.hasMobileBrand = false;
    this.hasMobileMainNavigation = false;
    this.hasMobileSearch = false;
    this.hasMobileCallToAction = false;
    this.IsMobileMinimal = false;
    this.hasFlyout = false;
    this.hasMobileFlyout = false;
    this.isSubNavOpen = false;
  }
  get host() {
    return this;
  }
  handleMainNavigationItemClicked(event) {
    if (this.host.querySelector(`[slot="mobile-flyout"][flyout-id="${event.detail.index}"]`)) {
      this.isSubNavOpen = true;
      return;
    }
    this.isSubNavOpen = false;
  }
  handleFlyoutBackLinkClicked() {
    this.isSubNavOpen = false;
  }
  componentWillLoad() {
    this.hasCustomerOrientation = !!this.host.querySelector('[slot="customer-orientation"]');
    this.hasIntentBar = !!this.host.querySelector('[slot="intent-bar"]');
    this.hasCustomerZone = !!this.host.querySelector('[slot="customer-zone"]');
    this.hasLanguage = !!this.host.querySelector('[slot="language"]');
    this.hasBrand = !!this.host.querySelector('[slot="brand"]');
    this.hasMainNavigation = !!this.host.querySelector('[slot="main-navigation"]');
    this.hasSearch = !!this.host.querySelector('[slot="search"]');
    this.hasCallToAction = !!this.host.querySelector('[slot="call-to-action"]');
    this.hasMobileCustomerOrientation = !!this.host.querySelector('[slot="mobile-customer-orientation"]');
    this.hasMobileIntentBar = !!this.host.querySelector('[slot="mobile-intent-bar"]');
    this.hasMobileCustomerZone = !!this.host.querySelector('[slot="mobile-customer-zone"]');
    this.hasMobileLanguage = !!this.host.querySelector('[slot="mobile-language"]');
    this.hasMobileBrand = !!this.host.querySelector('[slot="mobile-brand"]');
    this.hasMobileMainNavigation = !!this.host.querySelector('[slot="mobile-main-navigation"]');
    this.hasMobileSearch = !!this.host.querySelector('[slot="mobile-search"]');
    this.hasMobileCallToAction = !!this.host.querySelector('[slot="mobile-call-to-action"]');
    this.hasFlyout = !!this.host.querySelector('[slot="flyout"]');
    this.hasMobileFlyout = !!this.host.querySelector('[slot="mobile-flyout"]');
    this.hasTopNavigation = this.hasCustomerOrientation || this.hasIntentBar || this.hasCustomerZone;
    this.IsMobileMinimal = this.hasMobileLanguage && !this.hasMobileCustomerOrientation && !this.hasMobileIntentBar && !this.hasMobileCustomerZone && !this.hasMobileMainNavigation && !this.hasMobileSearch && !this.hasMobileCallToAction;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: 'c1cce354d43a28632479da8ed8722a8eb71d4887',
      class: {
        compact: !this.hasTopNavigation,
        minimal: this.IsMobileMinimal
      }
    }, this.hasTopNavigation && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "top-row"
    }, this.hasCustomerOrientation && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "customer-orientation"
    }), this.hasIntentBar && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "intent-bar"
    }), this.hasCustomerZone && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "customer-zone"
    }), this.hasLanguage && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "language"
    })), (this.hasBrand || this.hasMainNavigation || this.hasSearch || this.hasCallToAction) && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "bottom-row"
    }, this.hasBrand && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "brand"
    }), this.hasMainNavigation && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "main-navigation"
    }), this.hasSearch && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "search"
    }), this.hasCallToAction && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "call-to-action"
    }), !this.hasTopNavigation && this.hasLanguage && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "language"
    }), this.hasFlyout && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "flyout-container"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "flyout"
    }))), this.hasMobileBrand && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-row"
    }, this.hasMobileBrand && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-brand"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-row-right"
    }, this.hasMobileCustomerZone && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-customer-zone"
    }), this.hasMobileSearch && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-search"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-hamburger"
    }, !this.IsMobileMinimal && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("input", {
      type: "checkbox",
      class: "mobile-hamburger-button"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("wink-icon", {
      appearance: "transparent",
      icon: "hamburger-menu",
      size: "md",
      class: "mobile-hamburger-button open"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("wink-icon", {
      appearance: "secondary",
      icon: "cross",
      size: "md",
      class: "mobile-hamburger-button close"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-fly-out"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-fly-out-top"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-fly-out-top-main"
    }, this.hasMobileMainNavigation && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-main-navigation"
    }), this.hasMobileCallToAction && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-call-to-action"
    }), this.hasMobileIntentBar && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-intent-bar"
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-fly-out-top-sub-nav",
      open: this.isSubNavOpen
    }, this.hasMobileFlyout && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-flyout"
    }))), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "mobile-fly-out-bottom"
    }, this.hasMobileCustomerOrientation && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-customer-orientation"
    }), this.hasMobileLanguage && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      name: "mobile-language"
    })))))));
  }
  static get style() {
    return {
      base: WinkGlobalHeaderBaseStyle0,
      telenet: WinkGlobalHeaderTelenetStyle0
    };
  }
}, [33, "wink-global-header", {
  "hasCustomerOrientation": [32],
  "hasIntentBar": [32],
  "hasCustomerZone": [32],
  "hasLanguage": [32],
  "hasBrand": [32],
  "hasMainNavigation": [32],
  "hasSearch": [32],
  "hasCallToAction": [32],
  "hasTopNavigation": [32],
  "hasMobileCustomerOrientation": [32],
  "hasMobileIntentBar": [32],
  "hasMobileCustomerZone": [32],
  "hasMobileLanguage": [32],
  "hasMobileBrand": [32],
  "hasMobileMainNavigation": [32],
  "hasMobileSearch": [32],
  "hasMobileCallToAction": [32],
  "IsMobileMinimal": [32],
  "hasFlyout": [32],
  "hasMobileFlyout": [32],
  "isSubNavOpen": [32]
}, [[4, "mainNavigationItemClicked", "handleMainNavigationItemClicked"], [4, "flyoutBackLinkClicked", "handleFlyoutBackLinkClicked"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-global-header", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-global-header":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, GlobalHeader);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_0__.d)();
        }
        break;
    }
  });
}
const WinkGlobalHeader = GlobalHeader;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 48426:
/*!***********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-icon.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkIcon: () => (/* binding */ WinkIcon),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.js */ 45477);

const WinkIcon = _icon_js__WEBPACK_IMPORTED_MODULE_0__.I;
const defineCustomElement = _icon_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 3890:
/*!**********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-img.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkImg: () => (/* binding */ WinkImg),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _breakpoints_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./breakpoints.types.js */ 69214);


const LOADING_TYPES = {
  lazy: 'lazy',
  eager: 'eager'
};
const imageBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host,:host picture,:host img{display:block;max-width:100%}";
const WinkImgBaseStyle0 = imageBaseCss;
const imageTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host,:host picture,:host img{display:block;max-width:100%}";
const WinkImgTelenetStyle0 = imageTelenetCss;
const Image = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class Image extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.srcDesktop = '';
    this.srcTablet = undefined;
    this.srcMobile = undefined;
    this.alt = undefined;
    this.loading = LOADING_TYPES.lazy;
  }
  render() {
    const altText = this.srcDesktop?.length > 0 && this.alt ? this.alt : `Image of ${window.location.host}`;
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: 'fe639502fea474f48d8d5d20d1225f54b01274fe'
    }, this.srcDesktop ? (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("picture", null, this.srcMobile && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("source", {
      srcSet: this.srcMobile,
      media: _breakpoints_types_js__WEBPACK_IMPORTED_MODULE_0__.B.mobile
    }), this.srcTablet && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("source", {
      srcSet: this.srcTablet,
      media: _breakpoints_types_js__WEBPACK_IMPORTED_MODULE_0__.B.tablet
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("img", {
      src: this.srcDesktop,
      alt: altText,
      loading: this.loading
    })) : (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("p", null, "Please set src "));
  }
  static get style() {
    return {
      base: WinkImgBaseStyle0,
      telenet: WinkImgTelenetStyle0
    };
  }
}, [33, "wink-img", {
  "srcDesktop": [513, "src-desktop"],
  "srcTablet": [1, "src-tablet"],
  "srcMobile": [1, "src-mobile"],
  "alt": [1],
  "loading": [1]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-img"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-img":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Image);
        }
        break;
    }
  });
}
const WinkImg = Image;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 82863:
/*!****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-indicator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkIndicator: () => (/* binding */ WinkIndicator),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _indicator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./indicator.js */ 19766);

const WinkIndicator = _indicator_js__WEBPACK_IMPORTED_MODULE_0__.I;
const defineCustomElement = _indicator_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 47598:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-input.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkInput: () => (/* binding */ WinkInput),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input.js */ 75098);

const WinkInput = _input_js__WEBPACK_IMPORTED_MODULE_0__.I;
const defineCustomElement = _input_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 34913:
/*!*****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-intent-bar.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkIntentBar: () => (/* binding */ WinkIntentBar),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./link.js */ 37232);



const intentBarBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;flex-direction:column;gap:calc(var(--semantic-spacing-xs) * 1rem)}@media only screen and (min-width: 64em){:host{flex-direction:row;align-items:center}}@media only screen and (max-width: calc(64em - 1px)){:host{width:100%}}:host wink-link{display:inline-flex}";
const WinkIntentBarBaseStyle0 = intentBarBaseCss;
const intentBarTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;flex-direction:column;gap:calc(var(--semantic-spacing-xs) * 1rem)}@media only screen and (min-width: 64em){:host{flex-direction:row;align-items:center}}@media only screen and (max-width: calc(64em - 1px)){:host{width:100%}}:host wink-link{display:inline-flex}";
const WinkIntentBarTelenetStyle0 = intentBarTelenetCss;
const IntentBar = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class IntentBar extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, {
      key: 'ad81ae8f5475d75afa096d7277bdb374c43d872b'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-link", {
      key: '6358eca3fac1768438f7aa5be54c1b0717116821',
      appearance: "menu-secondary",
      icon: "headset",
      size: "body-regular",
      "icon-position": "left",
      "icon-appearance": "default",
      href: "#"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: '80dc31c9b6d4b24ee8424677930b3eedc7fa0df1',
      slot: "link-icon",
      appearance: "default",
      icon: "message-question",
      size: "sm"
    }), "Hulp"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-link", {
      key: '1352400e684bfe850700388ed0f70cf861d2cc94',
      appearance: "menu-secondary",
      icon: "headset",
      size: "body-regular",
      "icon-position": "left",
      "icon-appearance": "default",
      href: "#"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: 'f676342f8fa08dd90bfe55b57b8e6cf9172ae094',
      slot: "link-icon",
      appearance: "default",
      icon: "headset",
      size: "sm"
    }), "Contact"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-link", {
      key: '84284ff0a689bba582e80220e0432d347bcec46c',
      appearance: "menu-secondary",
      icon: "headset",
      size: "body-regular",
      "icon-position": "left",
      "icon-appearance": "default",
      href: "#"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: 'f560f8b4cb6f5cc6cde267e6db108d4c7096daf8',
      slot: "link-icon",
      appearance: "default",
      icon: "email",
      size: "sm"
    }), "Webmail"));
  }
  static get style() {
    return {
      base: WinkIntentBarBaseStyle0,
      telenet: WinkIntentBarTelenetStyle0
    };
  }
}, [33, "wink-intent-bar"]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-intent-bar", "wink-icon", "wink-link"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-intent-bar":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, IntentBar);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_0__.d)();
        }
        break;
      case "wink-link":
        if (!customElements.get(tagName)) {
          (0,_link_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}
const WinkIntentBar = IntentBar;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 61295:
/*!***********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-link.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkLink: () => (/* binding */ WinkLink),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./link.js */ 37232);

const WinkLink = _link_js__WEBPACK_IMPORTED_MODULE_0__.L;
const defineCustomElement = _link_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 63615:
/*!***********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-logo.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkLogo: () => (/* binding */ WinkLogo),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _breakpoints_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./breakpoints.types.js */ 69214);
/* harmony import */ var _targets_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./targets.types.js */ 83638);




/* eslint sonarjs/no-duplicate-string: 0 */
const createNewLogo = (desktopSrc, mobileSrc, categoryText, altText) => {
  const logoFolder = '../assets/shared/logos/' + categoryText + '/';
  return {
    desktop: desktopSrc && logoFolder + desktopSrc,
    mobile: mobileSrc && logoFolder + mobileSrc,
    category: categoryText,
    alt: altText
  };
};
const logos = {
  'telenet-yellow': createNewLogo('telenet-yellow.svg', 'telenet-yellow.svg', 'telenet', 'logo telenet'),
  'telenet-color': createNewLogo('telenet-color.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-yellow': createNewLogo('telenet-brussels-yellow.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-color': createNewLogo('telenet-brussels-color.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-white': createNewLogo('telenet-brussels-white.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-yellow-sm': createNewLogo('telenet-brussels-yellow-sm.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-color-sm': createNewLogo('telenet-brussels-color-sm.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-white-sm': createNewLogo('telenet-brussels-white-sm.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-yellow-vertical': createNewLogo('telenet-brussels-yellow-vertical.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-color-vertical': createNewLogo('telenet-brussels-color-vertical.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-brussels-white-vertical': createNewLogo('telenet-brussels-white-vertical.svg', undefined, 'telenet', 'logo telenet'),
  'telenet-business-yellow': createNewLogo('telenet-business-yellow.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-color': createNewLogo('telenet-business-color.svg', undefined, 'telenet', ' logo telenet business'),
  'telenet-business-white': createNewLogo('telenet-business-white.svg', undefined, 'telenet', ' logo telenet business '),
  'telenet-business-yellow-sm': createNewLogo('telenet-business-yellow-sm.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-color-sm': createNewLogo('telenet-business-color-sm.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-white-sm': createNewLogo('telenet-business-white-sm.svg', undefined, 'telenet', 'logo telenet business '),
  'telenet-business-yellow-vertical': createNewLogo('telenet-business-yellow-vertical.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-color-vertical': createNewLogo('telenet-business-color-vertical.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-white-vertical': createNewLogo('telenet-business-white-vertical.svg', undefined, 'telenet', 'logo telenet business '),
  'telenet-business-brussels-yellow': createNewLogo('telenet-business-brussels-yellow.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-brussels-color': createNewLogo('telenet-business-brussels-color.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-brussels-white': createNewLogo('telenet-business-brussels-white.svg', undefined, 'telenet', 'logo telenet business '),
  'telenet-business-brussels-yellow-vertical': createNewLogo('telenet-business-brussels-yellow-vertical.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-brussels-color-vertical': createNewLogo('telenet-business-brussels-color-vertical.svg', undefined, 'telenet', 'logo telenet business'),
  'telenet-business-brussels-white-vertical': createNewLogo('telenet-business-brussels-white-vertical.svg', undefined, 'telenet', 'logo telenet business '),
  'telenet-business-partner-yellow': createNewLogo('telenet-business-partner-yellow.svg', undefined, 'telenet', 'logo telenet business partner'),
  'telenet-business-partner-color': createNewLogo('telenet-business-partner-color.svg', undefined, 'telenet', 'logo telenet business partner'),
  'telenet-business-partner-white': createNewLogo('telenet-business-partner-white.svg', undefined, 'telenet', 'logo telenet business partner '),
  'telenet-netweters-yellow': createNewLogo('telenet-netweters-yellow.svg', undefined, 'telenet', 'logo de netweter'),
  'telenet-netweters-color': createNewLogo('telenet-netweters-color.svg', undefined, 'telenet', 'logo de netweters'),
  'telenet-netweters-white': createNewLogo('telenet-netweters-white.svg', undefined, 'telenet', 'logo de netweters '),
  'telenet-netweters-yellow-vertical': createNewLogo('telenet-netweters-yellow-vertical.svg', undefined, 'telenet', 'logo de netweters'),
  'telenet-netweters-color-vertical': createNewLogo('telenet-netweters-color-vertical.svg', undefined, 'telenet', 'logo de netweters'),
  'telenet-netweters-white-vertical': createNewLogo('telenet-netweters-white-vertical.svg', undefined, 'telenet', 'logo de netweters '),
  'telenet-tv-yellow': createNewLogo('telenet-tv-yellow.svg', undefined, 'telenet', 'logo telenet-tv'),
  'telenet-tv-flow-yellow': createNewLogo('telenet-tv-flow-yellow.svg', undefined, 'telenet', 'logo telenet-tv flow'),
  'telenet-tv-flow-white': createNewLogo('telenet-tv-flow-white.svg', undefined, 'telenet', 'logo telenet-tv flow '),
  'telenet-tv-iconic-yellow': createNewLogo('telenet-tv-iconic-yellow.svg', undefined, 'telenet', 'logo telenet-tv iconic'),
  'telenet-tv-iconic-white': createNewLogo('telenet-tv-iconic-white.svg', undefined, 'telenet', 'logo telenet-tv iconic '),
  'telenet-tv-yellow-yellow': createNewLogo('telenet-tv-yelo-yellow.svg', undefined, 'telenet', 'logo telenet-tv yellow'),
  'telenet-tv-yellow-white': createNewLogo('telenet-tv-yelo-white.svg', undefined, 'telenet', 'logo telenet-tv yellow '),
  base: createNewLogo('base.svg', undefined, 'base', 'logo base'),
  'base-white': createNewLogo('base-white.svg', undefined, 'base', 'logo base'),
  'base-alt': createNewLogo('base-alt.svg', undefined, 'base', 'logo base'),
  'base-alt-white': createNewLogo('base-alt-white.svg', undefined, 'base', 'logo base'),
  goplay: createNewLogo('goplay.svg', undefined, 'entertainment-play', 'logo goplay'),
  play4: createNewLogo('play4.svg', undefined, 'entertainment-play', 'logo play4'),
  play5: createNewLogo('play5.svg', undefined, 'entertainment-play', 'logo play5'),
  play6: createNewLogo('play6.svg', undefined, 'entertainment-play', 'logo play6'),
  play7: createNewLogo('play7.svg', undefined, 'entertainment-play', 'logo play7'),
  'playmore-light': createNewLogo('playmore-light.svg', undefined, 'entertainment-play', 'logo playmore'),
  playmore: createNewLogo('playmore.svg', undefined, 'entertainment-play', 'logo playmore'),
  'playmore-telenet-light': createNewLogo('playmore-telenet-light.svg', undefined, 'entertainment-play', 'logo playmore + telenet'),
  'playmore-telenet': createNewLogo('playmore-telenet.svg', undefined, 'entertainment-play', 'logo playmore + telenet'),
  'playsports-light': createNewLogo('playsports-light.svg', undefined, 'entertainment-play', 'logo playsports + telenet'),
  playsports: createNewLogo('playsports.svg', undefined, 'entertainment-play', 'logo playsports + telenet'),
  'playsports-light-sm': createNewLogo('playsports-light-sm.svg', undefined, 'entertainment-play', 'logo playsports + telenet'),
  'playsports-sm': createNewLogo('playsports.svg', undefined, 'entertainment-play', 'logo playsports + telenet'),
  'playsports-telenet-light': createNewLogo('playsports-telenet-light.svg', undefined, 'entertainment-play', 'logo playsports + telenet'),
  'playsports-telenet': createNewLogo('playsports-telenet.svg', undefined, 'entertainment-play', 'logo playsports + telenet'),
  'playsports-telenet-light-sm': createNewLogo('playsports-telenet-light-sm.svg', undefined, 'entertainment-play', 'logo playsports + telenet'),
  'playsports-telenet-sm': createNewLogo('playsports-telenet-sm.svg', undefined, 'entertainment-play', 'logo playsports + telenet '),
  'playsportsopen-light': createNewLogo('playsportsopen-light.svg', undefined, 'entertainment-play', 'logo playsportsopen'),
  playsportsopen: createNewLogo('playsportsopen.svg', undefined, 'entertainment-play', 'logo playsportsopen'),
  'playsportsopen-light-sm': createNewLogo('playsportsopen-light-sm.svg', undefined, 'entertainment-play', 'logo playsportsopen'),
  'playsportsopen-sm': createNewLogo('playsportsopen-sm.svg', undefined, 'entertainment-play', 'logo playsportsopen- + telenet'),
  'playsportsopen-telenet-light': createNewLogo('playsportsopen-telenet-light.svg', undefined, 'entertainment-play', 'logo playsportsopen + telenet'),
  'playsportsopen-telenet': createNewLogo('playsportsopen-telenet.svg', undefined, 'entertainment-play', 'logo playsportsopen + telenet'),
  'playsportsopen-telenet-light-sm': createNewLogo('playsportsopen-telenet-light-sm.svg', undefined, 'entertainment-play', 'logo playsportsopen + telenet'),
  'playsportsopen-telenet-sm': createNewLogo('playsportsopen-telenet-sm.svg', undefined, 'entertainment-play', 'logo playsportsopen + telenet'),
  netflix: createNewLogo('netflix.svg', undefined, 'entertainment-streaming', 'logo netflix'),
  primevideo: createNewLogo('primevideo.svg', undefined, 'entertainment-streaming', 'logo primevideo'),
  'primevideo-white': createNewLogo('primevideo-white.svg', undefined, 'entertainment-streaming', 'logo primevideo'),
  'primevideo-black': createNewLogo('primevideo-black.svg', undefined, 'entertainment-streaming', 'logo primevideo'),
  streamz: createNewLogo('streamz.svg', undefined, 'entertainment-streaming', 'logo streamz'),
  'streamz-sm': createNewLogo('streamz-sm.svg', undefined, 'entertainment-streaming', 'logo streamz'),
  'streamz-white': createNewLogo('streamz-white.svg', undefined, 'entertainment-streaming', 'logo streamz'),
  'streamz-white-sm': createNewLogo('streamz-white-sm.svg', undefined, 'entertainment-streaming', 'logo streamz'),
  'streamz+': createNewLogo('streamz+.svg', undefined, 'entertainment-streaming', 'logo streamz plus'),
  'streamz+-sm': createNewLogo('streamz+-sm.svg', undefined, 'entertainment-streaming', 'logo streamz plus'),
  'streamz+-white': createNewLogo('streamz+-white.svg', undefined, 'entertainment-streaming', 'logo streamz plus'),
  'streamz+-white-sm': createNewLogo('streamz+-white-sm.svg', undefined, 'entertainment-streaming', 'logo streamz plus'),
  'streamz-basic': createNewLogo('streamz-basic.svg', undefined, 'entertainment-streaming', 'logo streamz basic'),
  'streamz-basic-vertical': createNewLogo('streamz-basic-vertical.svg', undefined, 'entertainment-streaming', 'logo streamz basic'),
  'streamz-basic-white': createNewLogo('streamz-basic-white.svg', undefined, 'entertainment-streaming', 'logo streamz basic '),
  'streamz-basic-vertical-white': createNewLogo('streamz-basic-vertical-white.svg', undefined, 'entertainment-streaming', 'logo streamz basic'),
  'streamz-premium': createNewLogo('streamz-premium.svg', undefined, 'entertainment-streaming', 'logo streamz premium'),
  'streamz-premium-vertical': createNewLogo('streamz-premium-vertical.svg', undefined, 'entertainment-streaming', 'logo streamz premium'),
  'streamz-premium-white': createNewLogo('streamz-premium-white.svg', undefined, 'entertainment-streaming', 'logo streamz premium'),
  'streamz-premium-vertical-white': createNewLogo('streamz-premium-vertical-white.svg', undefined, 'entertainment-streaming', 'logo streamz premium'),
  'streamz-premium-plus': createNewLogo('streamz-premium-plus.svg', undefined, 'entertainment-streaming', 'logo streamz premium-plus'),
  'streamz-premium-plus-vertical': createNewLogo('streamz-premium-plus-vertical.svg', undefined, 'entertainment-streaming', 'logo streamz premium-plus'),
  'streamz-premium-plus-white': createNewLogo('streamz-premium-plus-white.svg', undefined, 'entertainment-streaming', 'logo streamz premium-plus'),
  'streamz-premium-plus-vertical-white': createNewLogo('streamz-premium-plus-vertical-white.svg', undefined, 'entertainment-streaming', 'logo streamz premium-plus'),
  hbo: createNewLogo('hbo.svg', undefined, 'entertainment-streaming', 'logo hbo'),
  'hbo-white': createNewLogo('hbo-white.svg', undefined, 'entertainment-streaming', 'logo hbo'),
  'disney+': createNewLogo('disney+.svg', undefined, 'entertainment-streaming', 'logo disney+'),
  'disney+-white': createNewLogo('disney+-white.svg', undefined, 'entertainment-streaming', 'logo disney+'),
  'disney+-white-gradient': createNewLogo('disney+-white-gradient.svg', undefined, 'entertainment-streaming', 'logo disney+')
};
const logoBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block}:host .not-clickable{pointer-events:none}:host a{display:block}:host a:focus,:host a:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host picture img{display:block;max-width:8rem;width:var(--wink-logo-width, 100%);height:auto}";
const WinkLogoBaseStyle0 = logoBaseCss;
const logoTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block}:host .not-clickable{pointer-events:none}:host a{display:block}:host a:focus,:host a:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host picture img{display:block;max-width:8rem;width:var(--wink-logo-width, 100%);height:auto}";
const WinkLogoTelenetStyle0 = logoTelenetCss;
const Logo = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class Logo extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.alt = '';
    this.href = '';
    this.target = _targets_types_js__WEBPACK_IMPORTED_MODULE_1__.T.self;
    this.appearance = 'telenet-yellow';
  }
  getSrcDesktop() {
    return logos[this.appearance]['desktop'] && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.getAssetPath)(logos[this.appearance]['desktop']);
  }
  getSrcMobile() {
    return logos[this.appearance]['mobile'] && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.getAssetPath)(logos[this.appearance]['mobile']);
  }
  altText() {
    return this.alt !== 'Inspect element to check' && this.alt || logos[this.appearance]['alt'];
  }
  renderLogoImage = (srcDesktop, srcMobile, alt) => {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("picture", null, srcMobile && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("source", {
      srcSet: srcMobile,
      media: _breakpoints_types_js__WEBPACK_IMPORTED_MODULE_0__.B.mobile
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("img", {
      src: srcDesktop,
      alt: alt
    }));
  };
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, {
      key: 'af3037b2e099d2cae8367abf1e6f37fce1a3ee39'
    }, this.href.length > 0 ? (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("a", {
      href: this.href,
      target: this.target
    }, this.renderLogoImage(this.getSrcDesktop(), this.getSrcMobile(), this.altText())) : this.renderLogoImage(this.getSrcDesktop(), this.getSrcMobile(), this.altText()));
  }
  static get style() {
    return {
      base: WinkLogoBaseStyle0,
      telenet: WinkLogoTelenetStyle0
    };
  }
}, [33, "wink-logo", {
  "alt": [1],
  "href": [1],
  "target": [1],
  "appearance": [1]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-logo"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-logo":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Logo);
        }
        break;
    }
  });
}
const WinkLogo = Logo;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 8392:
/*!**********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-main-navigation.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkMainNavigation: () => (/* binding */ WinkMainNavigation),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _media_query_detector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./media-query-detector.js */ 20462);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);



const mainNavigationBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host nav{display:contents}:host ul{all:unset;display:flex;align-self:stretch;gap:calc(var(--semantic-spacing-lg) * 1rem)}@media only screen and (min-width: 64em){:host ul{margin-left:calc(var(--semantic-spacing-md) * 1rem);margin-right:auto}}@media only screen and (max-width: calc(64em - 1px)){:host ul{flex-direction:column;gap:calc(var(--semantic-spacing-xs) * 1rem)}}@media only screen and (min-width: 64em) and (max-width: calc(74.5em - 1px)){:host ul{gap:calc(var(--semantic-spacing-sm) * 1rem)}}:host ul li{all:unset;display:contents}:host ul li a{display:flex;justify-content:space-between;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem);position:relative;padding:calc(var(--semantic-spacing-vertical-default) * 1rem) 0;color:var(--semantic-color-text-default);text-decoration:none;font-size:1.8rem;cursor:pointer}@media only screen and (max-width: calc(64em - 1px)){:host ul li a{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}}@media only screen and (min-width: 64em){:host ul li a:after{content:\"\";position:absolute;height:0.3rem;width:100%;left:0;bottom:0;border-radius:0.3rem 0.3rem 0 0;background-color:var(--wink-main-nav-link-after-bgc, unset)}:host ul li a:focus-visible,:host ul li a:hover{--wink-main-nav-link-after-bgc:var(--semantic-color-border-hover)}:host ul li a.active{--wink-main-nav-link-after-bgc:var(--semantic-color-border-selected)}:host ul li a wink-icon{display:none}}@media only screen and (min-width: 64em) and (max-width: calc(74.5em - 1px)){:host ul li a{font-size:1.6rem}}:host ul li a:focus,:host ul li a:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}";
const WinkMainNavigationBaseStyle0 = mainNavigationBaseCss;
const mainNavigationTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host nav{display:contents}:host ul{all:unset;display:flex;align-self:stretch;gap:calc(var(--semantic-spacing-lg) * 1rem)}@media only screen and (min-width: 64em){:host ul{margin-left:calc(var(--semantic-spacing-md) * 1rem);margin-right:auto}}@media only screen and (max-width: calc(64em - 1px)){:host ul{flex-direction:column;gap:calc(var(--semantic-spacing-xs) * 1rem)}}@media only screen and (min-width: 64em) and (max-width: calc(74.5em - 1px)){:host ul{gap:calc(var(--semantic-spacing-sm) * 1rem)}}:host ul li{all:unset;display:contents}:host ul li a{display:flex;justify-content:space-between;align-items:center;gap:calc(var(--semantic-spacing-xs) * 1rem);position:relative;padding:calc(var(--semantic-spacing-vertical-default) * 1rem) 0;color:var(--semantic-color-text-default);text-decoration:none;font-size:1.8rem;cursor:pointer}@media only screen and (max-width: calc(64em - 1px)){:host ul li a{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}}@media only screen and (min-width: 64em){:host ul li a:after{content:\"\";position:absolute;height:0.3rem;width:100%;left:0;bottom:0;border-radius:0.3rem 0.3rem 0 0;background-color:var(--wink-main-nav-link-after-bgc, unset)}:host ul li a:focus-visible,:host ul li a:hover{--wink-main-nav-link-after-bgc:var(--semantic-color-border-hover)}:host ul li a.active{--wink-main-nav-link-after-bgc:var(--semantic-color-border-selected)}:host ul li a wink-icon{display:none}}@media only screen and (min-width: 64em) and (max-width: calc(74.5em - 1px)){:host ul li a{font-size:1.6rem}}:host ul li a:focus,:host ul li a:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}";
const WinkMainNavigationTelenetStyle0 = mainNavigationTelenetCss;
const MainNavigation = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class MainNavigation extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.mainNavigationItemClicked = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.createEvent)(this, "mainNavigationItemClicked", 7);
    this.menuItems = '';
    this._menuItems = [];
    this.isOpen = false;
    this.activeIndex = undefined;
    this.ActiveLinkRef = undefined;
  }
  mainNavigationItemClicked;
  handleFlyoutBackLinkClicked(e) {
    const {
      eventType
    } = e.detail;
    this.isOpen = false;
    if (eventType !== 'mouse') {
      this.ActiveLinkRef?.focus();
    }
  }
  componentWillLoad() {
    if (!this.menuItems) {
      return;
    }
    this._menuItems = JSON.parse(this.menuItems);
  }
  mainNavigationItemEmitter(item) {
    this.mainNavigationItemClicked?.emit(item);
  }
  handleFlyOutOpening(item) {
    this.isOpen = !!this._menuItems[item.index]?.hasSubNav;
    this.mainNavigationItemEmitter(item);
  }
  handleItemClick(item) {
    this.activeIndex = item.index;
    this.handleFlyOutOpening(item);
  }
  handleItemMouseOver(item) {
    if (item.eventType === 'mouse' && _media_query_detector_js__WEBPACK_IMPORTED_MODULE_0__.M.isUntilMdHeader) {
      return;
    }
    if (this._menuItems[item.index].hasSubNav) {
      this.handleFlyOutOpening(item);
      return;
    }
    this.isOpen = false;
    this.mainNavigationItemEmitter({
      index: NaN,
      name: ''
    });
  }
  handleKeyDownEvent(e, index, name) {
    if (e.code === 'Space') {
      e.preventDefault();
      this.handleItemClick({
        index,
        name
      });
    }
  }
  getATagCssClasses(index) {
    return {
      active: this.activeIndex === index
    };
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("nav", {
      key: '80a30a8089e3f84ab3d8bf4f149bfbf892770ec0',
      role: "navigation"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("ul", {
      key: 'b1620989d27c010d1facd44b227b10e64333d528',
      role: "menu",
      "aria-label": "Main navigation menu"
    }, this._menuItems.map((item, index) => (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("li", {
      role: "none"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("a", {
      role: "menuitem",
      "aria-haspopup": (!!item.hasSubNav).toString(),
      "aria-expanded": this.isOpen.toString(),
      "aria-controls": item.hasSubNav ? `flyout-${index}` : undefined,
      class: this.getATagCssClasses(index),
      href: item.url,
      onClick: () => this.handleItemClick({
        index,
        name: item.name
      }),
      onMouseOver: () => this.handleItemMouseOver({
        index,
        name: item.name,
        eventType: 'mouse'
      }),
      onKeyDown: e => this.handleKeyDownEvent(e, index, item.name),
      ref: el => this.activeIndex === index && (this.ActiveLinkRef = el)
    }, item.name, item.hasSubNav && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      appearance: "default",
      icon: "chevron-right",
      size: "sm"
    }))))));
  }
  static get style() {
    return {
      base: WinkMainNavigationBaseStyle0,
      telenet: WinkMainNavigationTelenetStyle0
    };
  }
}, [33, "wink-main-navigation", {
  "menuItems": [1, "menu-items"],
  "_menuItems": [32],
  "isOpen": [32],
  "activeIndex": [32],
  "ActiveLinkRef": [32]
}, [[4, "flyoutBackLinkClicked", "handleFlyoutBackLinkClicked"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-main-navigation", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-main-navigation":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, MainNavigation);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}
const WinkMainNavigation = MainNavigation;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 67853:
/*!***************************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-navigation-list-item.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkNavigationListItem: () => (/* binding */ WinkNavigationListItem),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _targets_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./targets.types.js */ 83638);


const navigationListItemBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host .navigation-list-item{color:var(--semantic-color-text-default);text-decoration:none}";
const WinkNavigationListItemBaseStyle0 = navigationListItemBaseCss;
const navigationListItemTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host .navigation-list-item{color:var(--semantic-color-text-default);text-decoration:none}";
const WinkNavigationListItemTelenetStyle0 = navigationListItemTelenetCss;
const NavigationListItem = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class NavigationListItem extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.href = '';
    this.target = _targets_types_js__WEBPACK_IMPORTED_MODULE_0__.T.self;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: '3f6fd805c8fe113c745e6577aee2cc0ff62ee7eb'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("a", {
      key: '6c2d7e4f21f8784f08bb6fdec6c15e6affde549d',
      class: "navigation-list-item",
      href: this.href,
      target: this.target
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      key: '01dbf9dfac8d7f7cfc99c1363db49eef86f1d7b9'
    })));
  }
  static get style() {
    return {
      base: WinkNavigationListItemBaseStyle0,
      telenet: WinkNavigationListItemTelenetStyle0
    };
  }
}, [33, "wink-navigation-list-item", {
  "href": [1],
  "target": [1]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-navigation-list-item"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-navigation-list-item":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, NavigationListItem);
        }
        break;
    }
  });
}
const WinkNavigationListItem = NavigationListItem;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 94253:
/*!**********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-navigation-list.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkNavigationList: () => (/* binding */ WinkNavigationList),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ 69900);
/* harmony import */ var _paragraph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./paragraph.js */ 16784);



const navigationListBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block;margin-bottom:calc(var(--semantic-spacing-lg) * 1rem)}:host .navigation-list--title{color:var(--semantic-color-text-subtlest);font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif;padding-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}:host ul{list-style-type:none;padding:0;margin:0;display:flex;flex-direction:column;gap:calc(var(--semantic-spacing-3xs) * 1rem)}:host ul wink-navigation-list-item{font-size:1.8rem;line-height:2.8rem;text-decoration:none}@media only screen and (max-width: calc(48.0625em - 1px)){:host ul wink-navigation-list-item{display:block;padding:calc(var(--semantic-spacing-vertical-default) * 1rem) 0}}:host([has-bold-links]) wink-navigation-list-item,:host([has-bold-links=true]) wink-navigation-list-item{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:700}";
const WinkNavigationListBaseStyle0 = navigationListBaseCss;
const navigationListTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block;margin-bottom:calc(var(--semantic-spacing-lg) * 1rem)}:host .navigation-list--title{color:var(--semantic-color-text-subtlest);font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif;padding-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}:host ul{list-style-type:none;padding:0;margin:0;display:flex;flex-direction:column;gap:calc(var(--semantic-spacing-3xs) * 1rem)}:host ul wink-navigation-list-item{font-size:1.8rem;line-height:2.8rem;text-decoration:none}@media only screen and (max-width: calc(48.0625em - 1px)){:host ul wink-navigation-list-item{display:block;padding:calc(var(--semantic-spacing-vertical-default) * 1rem) 0}}:host([has-bold-links]) wink-navigation-list-item,:host([has-bold-links=true]) wink-navigation-list-item{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:700}";
const WinkNavigationListTelenetStyle0 = navigationListTelenetCss;
const NavigationList = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class NavigationList extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.listTitle = '';
    this.hasBoldLinks = false;
  }
  get host() {
    return this;
  }
  render() {
    const allLinkChilds = Array.from(this.host.children).filter(node => {
      return node.nodeName.toLocaleLowerCase() === 'wink-navigation-list-item';
    });
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, null, this.listTitle && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-paragraph", {
      appearance: "caption",
      size: "bold",
      class: "navigation-list--title"
    }, this.listTitle), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("ul", {
      class: "navigation-list--list"
    }, allLinkChilds.map(child => (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("li", {
      key: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.U)(),
      innerHTML: child.outerHTML
    }))));
  }
  static get style() {
    return {
      base: WinkNavigationListBaseStyle0,
      telenet: WinkNavigationListTelenetStyle0
    };
  }
}, [33, "wink-navigation-list", {
  "listTitle": [1, "list-title"],
  "hasBoldLinks": [4, "has-bold-links"]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-navigation-list", "wink-paragraph"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-navigation-list":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, NavigationList);
        }
        break;
      case "wink-paragraph":
        if (!customElements.get(tagName)) {
          (0,_paragraph_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}
const WinkNavigationList = NavigationList;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 41240:
/*!*******************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-notification.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkNotification: () => (/* binding */ WinkNotification),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _statuses_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./statuses.types.js */ 94001);
/* harmony import */ var _icon_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.types.js */ 98681);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon.js */ 45477);




const NOTIFICATION_TYPES = {
  information: _statuses_types_js__WEBPACK_IMPORTED_MODULE_0__.S.information,
  success: _statuses_types_js__WEBPACK_IMPORTED_MODULE_0__.S.success,
  error: _statuses_types_js__WEBPACK_IMPORTED_MODULE_0__.S.error,
  warning: _statuses_types_js__WEBPACK_IMPORTED_MODULE_0__.S.warning
};
const notificationBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host *{font-size:1.6rem;box-sizing:border-box;margin:0}:host .notification{display:flex;justify-content:space-between;align-items:flex-start;gap:1.6rem;padding:1.6rem;width:100%;flex-wrap:nowrap}@media only screen and (max-width: calc(36em - 1px)){:host .notification.has-close-icon{flex-wrap:wrap}}@media only screen and (max-width: calc(36em - 1px)){:host .notification{gap:2.4rem;padding:2.4rem}}:host .notification .close-icon{cursor:pointer}@media only screen and (min-width: 36em){:host .notification .close-icon{order:1}}:host .notification-text{display:flex;flex-direction:column;width:100%;gap:1.6rem}:host .notification.information{background-color:rgba(35, 115, 230, 0.1607843137)}:host .notification.information :not(.close-icon){--wink-icon-color:inherit}:host .notification.success{background-color:rgba(0, 135, 90, 0.1607843137)}:host .notification.success :not(.close-icon){--wink-icon-color:inherit}:host .notification.error{background-color:rgba(222, 53, 11, 0.1607843137)}:host .notification.error :not(.close-icon){--wink-icon-color:inherit}:host .notification.warning{background-color:rgba(255, 149, 0, 0.1607843137)}:host .notification.warning :not(.close-icon){--wink-icon-color:inherit}";
const WinkNotificationBaseStyle0 = notificationBaseCss;
const notificationTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host *{font-size:1.6rem;box-sizing:border-box;margin:0}:host .notification{display:flex;justify-content:space-between;align-items:flex-start;gap:1.6rem;padding:1.6rem;width:100%;flex-wrap:nowrap}@media only screen and (max-width: calc(36em - 1px)){:host .notification.has-close-icon{flex-wrap:wrap}}@media only screen and (max-width: calc(36em - 1px)){:host .notification{gap:2.4rem;padding:2.4rem}}:host .notification .close-icon{cursor:pointer}@media only screen and (min-width: 36em){:host .notification .close-icon{order:1}}:host .notification-text{display:flex;flex-direction:column;width:100%;gap:1.6rem}:host .notification.information{background-color:rgba(35, 115, 230, 0.1607843137)}:host .notification.information :not(.close-icon){--wink-icon-color:#2373e6}:host .notification.success{background-color:rgba(0, 135, 90, 0.1607843137)}:host .notification.success :not(.close-icon){--wink-icon-color:#00875a}:host .notification.error{background-color:rgba(222, 53, 11, 0.1607843137)}:host .notification.error :not(.close-icon){--wink-icon-color:#de350b}:host .notification.warning{background-color:rgba(255, 149, 0, 0.1607843137)}:host .notification.warning :not(.close-icon){--wink-icon-color:#ff9500}";
const WinkNotificationTelenetStyle0 = notificationTelenetCss;
const Notification = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.proxyCustomElement)(class Notification extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.appearance = NOTIFICATION_TYPES.information;
    this.hasCloseIcon = false;
    this.isNotificationVisible = true;
  }
  iconsNamesMap = new Map([['information', 'information-shape'], ['success', 'check-shape'], ['error', 'error-shape'], ['warning', 'alert-shape']]);
  closeNotification = () => {
    this.isNotificationVisible = false;
  };
  render() {
    return this.isNotificationVisible && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.Host, {
      key: 'f440c5eaf0642729ff78e250908e5c0492e253df',
      exportparts: `icon, icon-cross-small, icon-${this.iconsNamesMap.get(this.appearance)}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      key: '68c6b2c237e7918b26ed0c7a8464119fa5b1083a',
      class: `notification ${this.appearance} ${this.hasCloseIcon ? 'has-close-icon' : ''}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-icon", {
      key: '9647c838b41ac5ac6b469b7139cd5f540fb85e92',
      size: _icon_types_js__WEBPACK_IMPORTED_MODULE_1__.I.md,
      icon: this.iconsNamesMap.get(this.appearance)
    }), this.hasCloseIcon && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-icon", {
      class: "close-icon",
      appearance: "default",
      icon: "cross-small",
      size: _icon_types_js__WEBPACK_IMPORTED_MODULE_1__.I.md,
      onClick: this.closeNotification
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      key: '5da60762854c2bf8575e91eace9591b1fb6b7378',
      class: "notification-text"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      key: '315745107efac4e38114bab292cfb68f993ec7cf',
      name: "heading"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      key: '5f1850a6ec9cdbd8b471c815c3bc3cd447f3d94a',
      name: "content"
    }))));
  }
  static get style() {
    return {
      base: WinkNotificationBaseStyle0,
      telenet: WinkNotificationTelenetStyle0
    };
  }
}, [33, "wink-notification", {
  "appearance": [1],
  "hasCloseIcon": [4, "has-close-icon"],
  "isNotificationVisible": [32]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-notification", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-notification":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Notification);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
    }
  });
}
const WinkNotification = Notification;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 49688:
/*!****************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-paragraph.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkParagraph: () => (/* binding */ WinkParagraph),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _paragraph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./paragraph.js */ 16784);

const WinkParagraph = _paragraph_js__WEBPACK_IMPORTED_MODULE_0__.P;
const defineCustomElement = _paragraph_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 12705:
/*!**************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-pricing.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkPricing: () => (/* binding */ WinkPricing),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _positions_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./positions.types.js */ 46757);


const PRICING_TYPES = {
  text: 'text',
  patch: 'patch',
  subtle: 'subtle text'
};
const LANGUAGES = {
  nl: 'NL',
  fr: 'FR',
  en: 'EN'
};
const PRICING_ALIGN = {
  left: _positions_types_js__WEBPACK_IMPORTED_MODULE_0__.P.left,
  center: _positions_types_js__WEBPACK_IMPORTED_MODULE_0__.P.center,
  right: _positions_types_js__WEBPACK_IMPORTED_MODULE_0__.P.right
};
const pricingBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block}:host .price__price-currency{font-style:normal}:host .pricing__header{font-size:var(--pricing--mobile--desktop--fs, 1.2rem);line-height:var(--pricing--mobile--desktop--lh, 1.6rem);margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem);display:inline-flex;width:100%}@media only screen and (min-width: 48.0625em){:host .pricing__header{font-size:var(--pricing--header--desktop--fs, 1.4rem);line-height:var(--pricing--header--desktop--lh, 2rem)}}:host .pricing__header.price-align__center{justify-content:center}:host .pricing__header.price-align__right{justify-content:flex-end}:host .pricing__header .pricing__starting-from{color:var(--pricing--starting-from, var(--semantic-color-text-subtle));margin-right:calc(var(--semantic-spacing-3xs) * 1rem);display:inline-block}:host .pricing__header .pricing__promo-price{color:var(--pricing--promo-price, var(--semantic-color-text-subtle));display:inline-flex;text-decoration:line-through}:host .pricing__current-price-wrapper{display:flex;align-items:flex-end}:host .pricing__current-price-wrapper.price-align__right,:host .pricing__current-price-wrapper.price-align__center{flex-direction:column}:host .pricing__current-price-wrapper.price-align__right .pricing__price-frequency,:host .pricing__current-price-wrapper.price-align__center .pricing__price-frequency{margin-right:0}:host .pricing__current-price-wrapper.price-align__center{align-items:center}:host .pricing__current-price-wrapper.price-align__right{align-items:flex-end}:host .pricing__current-price-wrapper .pricing__price-value-wrapper{color:var(--price-price-value-color, var(--semantic-color-text-default));font-family:var(--pricing--price-value-wrapper--ff, AkagiProFat);display:inline-flex;align-items:flex-start}:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-currency{font-size:var(--price--price-currency--mobile--fs, 1.6rem);line-height:var(--price--price-currency--mobile--lh, 1.5rem);font-style:normal}@media only screen and (min-width: 48.0625em){:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-currency{font-size:var(--price--price-currency--desktop--fs, 1.8rem);line-height:var(--price--price-currency--desktop--lh, 1.9rem)}}:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-decimal{font-size:var(--price--price-decimal--mobile--fs, 1.6rem);line-height:var(--price--price-decimal--mobile--lh, 1.5rem);font-style:normal}@media only screen and (min-width: 48.0625em){:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-decimal{font-size:var(--price--price-decimal--desktop--fs, 1.8rem);line-height:var(--price--price-decimal--desktop--lh, 1.9rem)}}:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-value{font-size:var(--price--price-value--mobile--fs, 2.8rem);line-height:var(--price--price-value--mobile--lh, 2.8rem);display:inline-flex;align-items:flex-start}@media only screen and (min-width: 48.0625em){:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-value{font-size:var(--price--price-value--desktop--fs, 3.2rem);line-height:var(--price--price-value--desktop--lh, 3.1rem)}}:host .pricing__price-frequency{font-size:var(--pricing--price-frequency--mobile--fs, 1.2rem);line-height:var(--pricing--price-frequency--mobile--lh, 1.6rem)}@media only screen and (min-width: 48.0625em){:host .pricing__price-frequency{font-size:var(--pricing--price-frequency--desktop--fs, 1.4rem);line-height:var(--pricing--price-frequency--desktop--lh, 2rem)}}:host .pricing__price-promo-duration{font-size:var(--pricing--price-promo-duration--mobile--fs, 1.2rem);line-height:var(--pricing--price-promo-duration--mobile--lh, 1.6rem)}@media only screen and (min-width: 48.0625em){:host .pricing__price-promo-duration{font-size:var(--pricing--price-promo-duration--desktop--fs, 1.4rem);line-height:var(--pricing--price-promo-duration--desktop--lh, 2rem)}}:host .pricing__price-frequency{color:var(--price-frequency-color, var(--semantic-color-text-default));margin-left:calc(var(--semantic-spacing-3xs) * 1rem)}:host .pricing__price-promo-duration{color:var(--price-end-color, var(--semantic-color-text-subtle))}:host .currency-after{justify-content:start;flex-direction:row-reverse;gap:calc(var(--semantic-spacing-3xs) * 1rem)}:host .pricing__footer.price-align__center,:host .pricing__footer.price-align__right{display:flex}:host .pricing__footer.price-align__center{justify-content:center}:host .pricing__footer.price-align__right{justify-content:flex-end}:host([appearance=patch]){--pricing--starting-from:#ffffff;--pricing--promo-price:#ffffff;--price-frequency-color:#ffffff;--price-price-value-color:#ffffff;--price-end-color:#ffffff;--pricing--price-promo-price--desktop--fs:1.2rem;--pricing--price-promo-price--desktop--lh:1.6rem;--pricing--price-promo-duration--desktop--fs:1rem;--pricing--price-promo-duration--desktop--lh:1.2rem;display:inline-flex;flex-direction:column;justify-content:center;background-repeat:no-repeat;background-size:cover;background-color:var(--pricing-host-background, #004a47);padding:calc(var(--semantic-spacing-s) * 1rem);aspect-ratio:1/1;min-height:12.8rem;min-width:12.8rem}:host([appearance=patch]) .pricing__header.price-align__center{align-items:center;flex-direction:column}:host([appearance=patch]) .pricing__starting-from{font-family:AkagiProFat}:host([appearance=patch]) .pricing__price-frequency{font-family:AkagiProFat}:host([appearance=\"subtle text\"]){--price--price-value--desktop--fs:1.8rem;--price--price-value--desktop--lh:1.8rem}:host([brand=base]){font-family:AkagiProBook}:host([brand=base][theme=telenet-dark]),:host([brand=base][theme=base-dark]){--pricing--starting-from:#a9a9a9;--pricing--promo-price:#a9a9a9;--price-frequency-color:#ffffff;--price-price-value-color:#ffffff;--price-end-color:#a9a9a9}:host([brand=base][theme=telenet-dark][appearance=patch]),:host([brand=base][theme=base-dark][appearance=patch]){--pricing-host-background:#ffffff;--pricing--starting-from:#111111;--pricing--promo-price:#111111;--price-frequency-color:#111111;--price-price-value-color:#111111;--price-end-color:#111111}:host([brand=base][theme=telenet-light][appearance=\"subtle text\"]),:host([brand=base][theme=base-light][appearance=\"subtle text\"]),:host([brand=base][theme=telenet-dark][appearance=\"subtle text\"]),:host([brand=base][theme=base-dark][appearance=\"subtle text\"]){--price--price-value--desktop--fs:1.8rem;--price--price-value--desktop--lh:1.8rem;--pricing--price-value-wrapper--ff:AkagiProBold}";
const WinkPricingBaseStyle0 = pricingBaseCss;
const pricingTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:inline-block}:host .price__price-currency{font-style:normal}:host .pricing__header{font-size:var(--pricing--mobile--desktop--fs, 1.2rem);line-height:var(--pricing--mobile--desktop--lh, 1.6rem);margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem);display:inline-flex;width:100%}@media only screen and (min-width: 48.0625em){:host .pricing__header{font-size:var(--pricing--header--desktop--fs, 1.4rem);line-height:var(--pricing--header--desktop--lh, 2rem)}}:host .pricing__header.price-align__center{justify-content:center}:host .pricing__header.price-align__right{justify-content:flex-end}:host .pricing__header .pricing__starting-from{color:var(--pricing--starting-from, var(--semantic-color-text-subtle));margin-right:calc(var(--semantic-spacing-3xs) * 1rem);display:inline-block}:host .pricing__header .pricing__promo-price{color:var(--pricing--promo-price, var(--semantic-color-text-subtle));display:inline-flex;text-decoration:line-through}:host .pricing__current-price-wrapper{display:flex;align-items:flex-end}:host .pricing__current-price-wrapper.price-align__right,:host .pricing__current-price-wrapper.price-align__center{flex-direction:column}:host .pricing__current-price-wrapper.price-align__right .pricing__price-frequency,:host .pricing__current-price-wrapper.price-align__center .pricing__price-frequency{margin-right:0}:host .pricing__current-price-wrapper.price-align__center{align-items:center}:host .pricing__current-price-wrapper.price-align__right{align-items:flex-end}:host .pricing__current-price-wrapper .pricing__price-value-wrapper{color:var(--price-price-value-color, var(--semantic-color-text-default));font-family:var(--pricing--price-value-wrapper--ff, TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif);display:inline-flex;align-items:flex-start}:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-currency{font-size:var(--price--price-currency--mobile--fs, 1.6rem);line-height:var(--price--price-currency--mobile--lh, 1.5rem);font-style:normal}@media only screen and (min-width: 48.0625em){:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-currency{font-size:var(--price--price-currency--desktop--fs, 1.8rem);line-height:var(--price--price-currency--desktop--lh, 1.9rem)}}:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-decimal{font-size:var(--price--price-decimal--mobile--fs, 1.6rem);line-height:var(--price--price-decimal--mobile--lh, 1.5rem);font-style:normal}@media only screen and (min-width: 48.0625em){:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-decimal{font-size:var(--price--price-decimal--desktop--fs, 1.8rem);line-height:var(--price--price-decimal--desktop--lh, 1.9rem)}}:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-value{font-size:var(--price--price-value--mobile--fs, 2.8rem);line-height:var(--price--price-value--mobile--lh, 2.8rem);display:inline-flex;align-items:flex-start}@media only screen and (min-width: 48.0625em){:host .pricing__current-price-wrapper .pricing__price-value-wrapper .price__price-value{font-size:var(--price--price-value--desktop--fs, 3.2rem);line-height:var(--price--price-value--desktop--lh, 3.1rem)}}:host .pricing__price-frequency{font-size:var(--pricing--price-frequency--mobile--fs, 1.2rem);line-height:var(--pricing--price-frequency--mobile--lh, 1.6rem)}@media only screen and (min-width: 48.0625em){:host .pricing__price-frequency{font-size:var(--pricing--price-frequency--desktop--fs, 1.4rem);line-height:var(--pricing--price-frequency--desktop--lh, 2rem)}}:host .pricing__price-promo-duration{font-size:var(--pricing--price-promo-duration--mobile--fs, 1.2rem);line-height:var(--pricing--price-promo-duration--mobile--lh, 1.6rem)}@media only screen and (min-width: 48.0625em){:host .pricing__price-promo-duration{font-size:var(--pricing--price-promo-duration--desktop--fs, 1.4rem);line-height:var(--pricing--price-promo-duration--desktop--lh, 2rem)}}:host .pricing__price-frequency{color:var(--price-frequency-color, var(--semantic-color-text-default));margin-left:calc(var(--semantic-spacing-3xs) * 1rem)}:host .pricing__price-promo-duration{color:var(--price-end-color, var(--semantic-color-text-subtle))}:host .currency-after{justify-content:start;flex-direction:row-reverse;gap:calc(var(--semantic-spacing-3xs) * 1rem)}:host .pricing__footer.price-align__center,:host .pricing__footer.price-align__right{display:flex}:host .pricing__footer.price-align__center{justify-content:center}:host .pricing__footer.price-align__right{justify-content:flex-end}:host([appearance=patch]){--pricing--starting-from:var(--semantic-color-text-on-brand);--pricing--promo-price:var(--semantic-color-text-on-brand);--price-frequency-color:var(--semantic-color-text-on-brand);--price-price-value-color:var(--semantic-color-text-on-brand);--price-end-color:var(--semantic-color-text-on-brand);--pricing--price-promo-price--desktop--fs:1.2rem;--pricing--price-promo-price--desktop--lh:1.6rem;--pricing--price-promo-duration--desktop--fs:1rem;--pricing--price-promo-duration--desktop--lh:1.2rem;display:inline-flex;flex-direction:column;justify-content:center;background-repeat:no-repeat;background-size:cover;background-color:var(--pricing-host-background, var(--semantic-color-background-canvas-brand));padding:calc(var(--semantic-spacing-s) * 1rem);aspect-ratio:1/1;min-height:12.8rem;min-width:12.8rem}:host([appearance=patch]) .pricing__header.price-align__center{align-items:center;flex-direction:column}:host([appearance=patch]) .pricing__starting-from{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host([appearance=patch]) .pricing__price-frequency{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif}:host([appearance=\"subtle text\"]){--price--price-value--desktop--fs:1.8rem;--price--price-value--desktop--lh:1.8rem}:host([brand=telenet][appearance=patch]){mask:url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='109' height='109' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='%23fff' d='M105.9 20C104.8 11.2 98 4.2 89.2 3.2c0 0-14-2.2-34.7-2.2-20.6 0-34.7 2.2-34.7 2.2-8.8 1-15.6 8-16.7 16.8C3.1 20 1 35.8 1 54.5S3.1 89 3.1 89c1.1 8.8 7.9 15.8 16.7 16.8 0 0 14 2.2 34.7 2.2 20.6 0 34.7-2.2 34.7-2.2 8.8-1.1 15.6-8 16.7-16.8 0 0 2.1-15.8 2.1-34.5S105.9 20 105.9 20' fill-rule='evenodd'/%3E%3C/svg%3E\");mask-size:contain;mask-repeat:no-repeat}";
const WinkPricingTelenetStyle0 = pricingTelenetCss;
const Pricing = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class Pricing extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.price = '';
    this.priceStrikethrough = '';
    this.startingFrom = '';
    this.frequency = '';
    this.duration = '';
    this.appearance = PRICING_TYPES.text;
    this.annotation = LANGUAGES.nl;
    this.alignment = PRICING_ALIGN.left;
  }
  normalText = '_normal';
  strikeThroughText = '_strikethrough';
  screenReaderAnnotations = new Map([[LANGUAGES.nl + this.strikeThroughText, 'Normale prijs'], [LANGUAGES.fr + this.strikeThroughText, 'Prix normal'], [LANGUAGES.en + this.strikeThroughText, 'Normal price'], [LANGUAGES.nl + this.normalText, 'Huidige prijs'], [LANGUAGES.fr + this.normalText, 'Prix Maintenant'], [LANGUAGES.en + this.normalText, 'Current price']]);
  pricingChild = (price, lang, wrapperClassName) => {
    const currencyAfter = lang === LANGUAGES.fr ? 'currency-after' : '';
    const langDecimalPoint = lang !== LANGUAGES.en ? ',' : '.';
    const inputPrice = price ? price.replace(',', '.') : '';
    const integerPart = inputPrice.split('.')[0];
    const fractionalPart = inputPrice.split('.')[1] !== '00' ? inputPrice.split('.')[1] : '';
    const screenReaderText = wrapperClassName === 'pricing__promo-price' ? this.screenReaderAnnotations.get(lang + this.strikeThroughText) : this.screenReaderAnnotations.get(lang + this.normalText);
    let formatPriceHtml = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: `${wrapperClassName} ${currencyAfter}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
      class: "sr-only"
    }, screenReaderText), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("i", {
      class: "price__price-currency"
    }, "\u20AC"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
      class: "price__price-value"
    }, price));
    if (inputPrice.includes('.')) {
      formatPriceHtml = (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
        class: `${wrapperClassName} ${currencyAfter}`
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
        class: "sr-only"
      }, screenReaderText), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("i", {
        class: "price__price-currency"
      }, "\u20AC"), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
        class: "price__price-value"
      }, integerPart, fractionalPart && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("span", {
        class: "price__price-decimal"
      }, langDecimalPoint + fractionalPart)));
    }
    return formatPriceHtml;
  };
  alignmentClass = alignment => {
    return this.alignment !== PRICING_ALIGN.left ? `price-align__${alignment}` : '';
  };
  componentWillRender() {
    if (this.appearance === PRICING_TYPES.patch) {
      this.alignment = PRICING_ALIGN.center;
    }
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: 'a1d45a16934f2c4c72c1275b011a4f054a688395',
      type: "product price"
    }, (this.startingFrom || this.priceStrikethrough) && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: `pricing__header ${this.alignmentClass(this.alignment)}`
    }, this.startingFrom && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "pricing__starting-from"
    }, this.startingFrom, " "), this.priceStrikethrough && this.pricingChild(this.priceStrikethrough, this.annotation, 'pricing__promo-price')), (this.price || this.frequency) && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: `pricing__current-price-wrapper ${this.alignmentClass(this.alignment)}`
    }, this.price && this.pricingChild(this.price, this.annotation, 'pricing__price-value-wrapper'), this.frequency && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "pricing__price-frequency"
    }, this.frequency)), this.duration && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: `pricing__footer ${this.alignmentClass(this.alignment)}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      class: "pricing__price-promo-duration"
    }, this.duration)));
  }
  static get style() {
    return {
      base: WinkPricingBaseStyle0,
      telenet: WinkPricingTelenetStyle0
    };
  }
}, [33, "wink-pricing", {
  "price": [1],
  "priceStrikethrough": [1, "price-strikethrough"],
  "startingFrom": [1, "starting-from"],
  "frequency": [1],
  "duration": [1],
  "appearance": [1],
  "annotation": [1],
  "alignment": [1025]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-pricing"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-pricing":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Pricing);
        }
        break;
    }
  });
}
const WinkPricing = Pricing;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 87417:
/*!*******************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-radio-button.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkRadioButton: () => (/* binding */ WinkRadioButton),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./form-label.js */ 78529);


const radioButtonBaseCss = ".sr-only.sc-wink-radio-button-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-radio-button-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-radio-button-base-h{display:inline-block}.sc-wink-radio-button-base-h label.sc-wink-radio-button-base{display:flex;align-items:center;justify-content:flex-start;cursor:pointer;width:100%}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base{border-radius:50%;flex-shrink:0;align-self:flex-start;background-color:var(--semantic-color-background-surface-neutral-default);cursor:pointer;width:2rem;height:2rem;border:0.2rem solid var(--semantic-color-border-button-default);padding:0;margin:0.2rem calc(var(--semantic-spacing-xs) * 1rem) 0 0;appearance:none}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:before{content:\"\";position:absolute;margin-top:0.4rem;margin-left:0.4rem;width:0.8rem;height:0.8rem;border-radius:50%;background-color:var(--semantic-color-background-surface-highlight-7);transform:scale(0);transition:transform 0.12s ease-in-out}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:checked{background:var(--semantic-color-background-surface-action-default);border-color:var(--semantic-color-background-surface-action-selected)}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:checked:hover{background:var(--semantic-color-background-surface-action-hover);border-color:var(--semantic-color-background-surface-action-selected)}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:checked:before{transform:scale(1)}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:disabled,.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:disabled~*.sc-wink-radio-button-base{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:disabled:hover{border-color:var(--semantic-color-border-button-default)}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:invalid,.sc-wink-radio-button-base-h input[type=radio][aria-invalid].sc-wink-radio-button-base,.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:invalid:hover,.sc-wink-radio-button-base-h input[type=radio][aria-invalid].sc-wink-radio-button-base:hover,.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:invalid:focus,.sc-wink-radio-button-base-h input[type=radio][aria-invalid].sc-wink-radio-button-base:focus{border:2px solid var(--semantic-color-border-error);background-color:transparent}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:invalid:before,.sc-wink-radio-button-base-h input[type=radio][aria-invalid].sc-wink-radio-button-base:before,.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:invalid:hover:before,.sc-wink-radio-button-base-h input[type=radio][aria-invalid].sc-wink-radio-button-base:hover:before,.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:invalid:focus:before,.sc-wink-radio-button-base-h input[type=radio][aria-invalid].sc-wink-radio-button-base:focus:before{background-color:var(--semantic-color-icon-error)}.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:checked:invalid:before,.sc-wink-radio-button-base-h input[type=radio][aria-invalid].sc-wink-radio-button-base:checked:before{background-color:var(--semantic-color-icon-error)}.sc-wink-radio-button-base-h:hover,.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:hover{border-color:var(--semantic-color-border-highlight)}.sc-wink-radio-button-base-h:focus,.sc-wink-radio-button-base-h input[type=radio].sc-wink-radio-button-base:focus{border-color:var(--semantic-color-border-highlight);outline:0.2rem solid var(--semantic-color-border-focus);outline-offset:0.2rem}";
const WinkRadioButtonBaseStyle0 = radioButtonBaseCss;
const radioButtonTelenetCss = ".sr-only.sc-wink-radio-button-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-radio-button-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-radio-button-telenet-h{display:inline-block}.sc-wink-radio-button-telenet-h label.sc-wink-radio-button-telenet{display:flex;align-items:center;justify-content:flex-start;cursor:pointer;width:100%}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet{border-radius:50%;flex-shrink:0;align-self:flex-start;background-color:var(--semantic-color-background-surface-neutral-default);cursor:pointer;width:2rem;height:2rem;border:0.2rem solid var(--semantic-color-border-button-default);padding:0;margin:0.2rem calc(var(--semantic-spacing-xs) * 1rem) 0 0;appearance:none}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:before{content:\"\";position:absolute;margin-top:0.4rem;margin-left:0.4rem;width:0.8rem;height:0.8rem;border-radius:50%;background-color:var(--semantic-color-background-surface-highlight-7);transform:scale(0);transition:transform 0.12s ease-in-out}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:checked{background:var(--semantic-color-background-surface-action-default);border-color:var(--semantic-color-background-surface-action-selected)}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:checked:hover{background:var(--semantic-color-background-surface-action-hover);border-color:var(--semantic-color-background-surface-action-selected)}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:checked:before{transform:scale(1)}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:disabled,.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:disabled~*.sc-wink-radio-button-telenet{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:disabled:hover{border-color:var(--semantic-color-border-button-default)}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:invalid,.sc-wink-radio-button-telenet-h input[type=radio][aria-invalid].sc-wink-radio-button-telenet,.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:invalid:hover,.sc-wink-radio-button-telenet-h input[type=radio][aria-invalid].sc-wink-radio-button-telenet:hover,.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:invalid:focus,.sc-wink-radio-button-telenet-h input[type=radio][aria-invalid].sc-wink-radio-button-telenet:focus{border:2px solid var(--semantic-color-border-error);background-color:transparent}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:invalid:before,.sc-wink-radio-button-telenet-h input[type=radio][aria-invalid].sc-wink-radio-button-telenet:before,.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:invalid:hover:before,.sc-wink-radio-button-telenet-h input[type=radio][aria-invalid].sc-wink-radio-button-telenet:hover:before,.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:invalid:focus:before,.sc-wink-radio-button-telenet-h input[type=radio][aria-invalid].sc-wink-radio-button-telenet:focus:before{background-color:var(--semantic-color-icon-error)}.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:checked:invalid:before,.sc-wink-radio-button-telenet-h input[type=radio][aria-invalid].sc-wink-radio-button-telenet:checked:before{background-color:var(--semantic-color-icon-error)}.sc-wink-radio-button-telenet-h:hover,.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:hover{border-color:var(--semantic-color-border-highlight)}.sc-wink-radio-button-telenet-h:focus,.sc-wink-radio-button-telenet-h input[type=radio].sc-wink-radio-button-telenet:focus{border-color:var(--semantic-color-border-highlight);outline:0.2rem solid var(--semantic-color-border-focus);outline-offset:0.2rem}";
const WinkRadioButtonTelenetStyle0 = radioButtonTelenetCss;
const RadioButton = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class RadioButton extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.label = '';
    this.helper = '';
    this.radioButtonId = '';
    this.name = '';
    this.checked = false;
    this.disabled = false;
    this.error = false;
  }
  internals;
  get host() {
    return this;
  }
  handleKeyDown = e => {
    if (e.key === 'Enter') {
      this.host?.querySelector('input')?.click();
    }
  };
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("label", {
      key: '5336dc95e8f71b7e53c78561ea6c3fa7178c1c6a'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("input", {
      key: '0d8b31f04b76faf13499f095727fc0b8461b42a6',
      type: "radio",
      id: this.radioButtonId,
      name: this.name,
      value: this.label,
      checked: this.checked,
      disabled: this.disabled,
      "aria-invalid": this.error,
      onKeyDown: this.handleKeyDown
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("wink-form-label", {
      key: '45c16075ae892458d29ed10d4ded14932269dc21',
      label: this.label,
      helper: this.helper,
      rendition: _form_label_js__WEBPACK_IMPORTED_MODULE_0__.F.subComponent
    }));
  }
  static get style() {
    return {
      base: WinkRadioButtonBaseStyle0,
      telenet: WinkRadioButtonTelenetStyle0
    };
  }
}, [34, "wink-radio-button", {
  "label": [1],
  "helper": [1],
  "radioButtonId": [1, "radio-button-id"],
  "name": [1],
  "checked": [516],
  "disabled": [4],
  "error": [4]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-radio-button", "wink-form-label"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-radio-button":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RadioButton);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_0__.d)();
        }
        break;
    }
  });
}
const WinkRadioButton = RadioButton;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 81725:
/*!******************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-radio-group.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkRadioGroup: () => (/* binding */ WinkRadioGroup),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _positions_types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./positions.types.js */ 46757);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./form-label.js */ 78529);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _validation_message_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validation-message.js */ 46024);






const radioGroupBaseCss = ".sr-only.sc-wink-radio-group-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-radio-group-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-radio-group-base-h{display:block}.sc-wink-radio-group-base-h fieldset.sc-wink-radio-group-base{margin:0;padding:0;border:0}.sc-wink-radio-group-base-h legend.sc-wink-radio-group-base{margin-bottom:calc(var(--semantic-spacing-xs) * 1rem);display:flex;width:100%}.sc-wink-radio-group-base-h .radio-group--horizontal.sc-wink-radio-group-base,.sc-wink-radio-group-base-h .radio-group--vertical.sc-wink-radio-group-base{display:inline-flex;flex-wrap:wrap}.sc-wink-radio-group-base-h .radio-group--vertical.sc-wink-radio-group-base{flex-direction:column;gap:calc(var(--semantic-spacing-md) * 1rem)}.sc-wink-radio-group-base-h .radio-group--horizontal.sc-wink-radio-group-base{flex-direction:row;gap:calc(var(--semantic-spacing-xl) * 1rem)}";
const WinkRadioGroupBaseStyle0 = radioGroupBaseCss;
const radioGroupTelenetCss = ".sr-only.sc-wink-radio-group-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-radio-group-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-radio-group-telenet-h{display:block}.sc-wink-radio-group-telenet-h fieldset.sc-wink-radio-group-telenet{margin:0;padding:0;border:0}.sc-wink-radio-group-telenet-h legend.sc-wink-radio-group-telenet{margin-bottom:calc(var(--semantic-spacing-xs) * 1rem);display:flex;width:100%}.sc-wink-radio-group-telenet-h .radio-group--horizontal.sc-wink-radio-group-telenet,.sc-wink-radio-group-telenet-h .radio-group--vertical.sc-wink-radio-group-telenet{display:inline-flex;flex-wrap:wrap}.sc-wink-radio-group-telenet-h .radio-group--vertical.sc-wink-radio-group-telenet{flex-direction:column;gap:calc(var(--semantic-spacing-md) * 1rem)}.sc-wink-radio-group-telenet-h .radio-group--horizontal.sc-wink-radio-group-telenet{flex-direction:row;gap:calc(var(--semantic-spacing-xl) * 1rem)}";
const WinkRadioGroupTelenetStyle0 = radioGroupTelenetCss;
const RadioGroup = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.proxyCustomElement)(class RadioGroup extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.label = '';
    this.helper = '';
    this.direction = _positions_types_js__WEBPACK_IMPORTED_MODULE_1__.D.vertical;
    this.isRequired = false;
    this.optionalText = 'Optioneel';
    this.error = undefined;
  }
  internals;
  setValidation(errorMsg) {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      if (errorMsg) {
        _this.error = errorMsg;
      } else {
        _this.error = '';
      }
    })();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("fieldset", {
      key: 'e490b8f9e96079460ac2ac7eda69f90ba4d7a916'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("legend", {
      key: 'd96aa8fcf6a9b20767991732665367e36687a55b',
      class: "radio-group__wrapper"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-form-label", {
      key: '2d131f7ae1fdc24cf2eb8fe4ba19b1c153d5df1c',
      label: this.label,
      helper: this.helper,
      "show-optional": !this.isRequired,
      "optional-text": this.optionalText
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      key: '0ca6931cde693164749a85f789c0ff7e453e5e61',
      class: `radio-group--${this.direction}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("slot", {
      key: '134ae95d33ea8e0f7806a79f3260f47f523021da'
    })), this.error && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-validation-message", {
      message: this.error,
      type: "error"
    }));
  }
  static get style() {
    return {
      base: WinkRadioGroupBaseStyle0,
      telenet: WinkRadioGroupTelenetStyle0
    };
  }
}, [38, "wink-radio-group", {
  "label": [1],
  "helper": [1],
  "direction": [1],
  "isRequired": [4, "is-required"],
  "optionalText": [1, "optional-text"],
  "error": [1537],
  "setValidation": [64]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-radio-group", "wink-form-label", "wink-icon", "wink-validation-message"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-radio-group":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RadioGroup);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-validation-message":
        if (!customElements.get(tagName)) {
          (0,_validation_message_js__WEBPACK_IMPORTED_MODULE_4__.d)();
        }
        break;
    }
  });
}
const WinkRadioGroup = RadioGroup;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 64089:
/*!*******************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-range-slider.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkRangeSlider: () => (/* binding */ WinkRangeSlider),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./form-label.js */ 78529);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _input_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./input.js */ 75098);
/* harmony import */ var _validation_message_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validation-message.js */ 46024);






const SLIDER_TYPES = {
  single: 'single',
  range: 'range'
};
const SLIDER_DIRECTIONS = {
  from: 'from',
  to: 'to'
};
const rangeSliderBaseCss = ".sr-only.sc-wink-range-slider-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-range-slider-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.slider-container.sc-wink-range-slider-base{display:flex}.slider-container-range.sc-wink-range-slider-base{flex-direction:column;gap:calc(var(--semantic-spacing-xl) * 1rem)}.slider-container-range.sc-wink-range-slider-base .slider-specific.sc-wink-range-slider-base{width:100%}.slider-container-single.sc-wink-range-slider-base{flex-wrap:wrap}.slider-container-single.sc-wink-range-slider-base wink-form-label.sc-wink-range-slider-base{width:100%;margin-bottom:calc(var(--semantic-spacing-xl) * 1rem)}.slider-container-single.sc-wink-range-slider-base .slider-specific.sc-wink-range-slider-base{margin-left:calc(var(--semantic-spacing-md) * 1rem)}.slider-container-single.sc-wink-range-slider-base .slider.sc-wink-range-slider-base{cursor:pointer;pointer-events:all}.slider-wrapper.sc-wink-range-slider-base{font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:calc(var(--semantic-typography-font-size-desktop-sm) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-sm) * 1rem);color:var(--semantic-color-text-default);width:100%;padding-top:calc(var(--semantic-spacing-xs) * 1rem);display:flex;align-items:center;gap:calc(var(--semantic-spacing-sm) * 1rem)}.slider-controls.sc-wink-range-slider-base{position:relative;width:100%;height:calc(var(--semantic-spacing-xl) * 1rem);display:flex;align-items:center;justify-content:space-between}.slider-controls.sc-wink-range-slider-base:has(.slider:focus) .slider-tooltip.sc-wink-range-slider-base,.slider-controls.sc-wink-range-slider-base:has(.slider:hover) .slider-tooltip.sc-wink-range-slider-base{opacity:1}.slider-tooltip.sc-wink-range-slider-base{position:absolute;top:calc(var(--semantic-icon-xl) * 1rem * -1);font-size:calc(var(--semantic-typography-font-size-desktop-xs) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-xs) * 1rem);text-align:center;background-color:var(--semantic-color-background-input-outlined);color:var(--semantic-color-text-default);padding:calc(var(--semantic-spacing-2xs) * 1rem);border-radius:calc(var(--semantic-border-lg) * 1rem);box-shadow:0 calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-xs) * 1rem) 0 var(--semantic-color-background-input-filled);transform:translateX(-50%);min-width:calc(var(--semantic-icon-md) * 1rem);opacity:0;transition:opacity 300ms ease-in-out}.slider-tooltip-shown.sc-wink-range-slider-base .slider-tooltip.sc-wink-range-slider-base{opacity:1}.slider.sc-wink-range-slider-base{--size:calc(var(--semantic-icon-md) + (var(--semantic-spacing-3xs) * 2));appearance:none;position:absolute;left:0;width:100%;height:4.4rem;background-color:transparent;pointer-events:none}.slider.sc-wink-range-slider-base::-webkit-slider-runnable-track{width:100%;height:calc(var(--semantic-spacing-3xs) * 1rem);background-color:transparent;box-shadow:none;border:0;animation:0.2s}.slider.sc-wink-range-slider-base::-webkit-slider-thumb{appearance:none;height:calc(var(--size) * 1rem);width:calc(var(--size) * 1rem);background-clip:padding-box;background-color:var(--semantic-color-background-surface-action-default);border-radius:50%;margin-top:calc(var(--size) * 1rem * -0.5 + var(--semantic-spacing-3xs) * 1rem / 2);margin-left:calc(var(--semantic-spacing-3xs) * 1rem * -0.5);pointer-events:all;cursor:pointer;-webkit-transition:all 300ms ease-in-out;transition:all 300ms ease-in-out;border:calc(var(--semantic-spacing-3xs) * 1rem) solid transparent}.slider.sc-wink-range-slider-base::-webkit-slider-thumb:hover{--size:calc(var(--semantic-icon-md) + var(--semantic-spacing-3xs) + (var(--semantic-spacing-3xs) * 2));border:calc(var(--semantic-spacing-3xs) * 1rem) solid var(--semantic-color-background-surface-bold-hovered)}.slider.sc-wink-range-slider-base::-moz-range-track{width:100%;height:calc(var(--semantic-spacing-3xs) * 1rem);background-color:transparent;box-shadow:none;border:0;animation:0.2s}.slider.sc-wink-range-slider-base::-moz-range-track:hover{--size:calc(var(--semantic-icon-md) + var(--semantic-spacing-3xs) + (var(--semantic-spacing-3xs) * 2));border:calc(var(--semantic-spacing-3xs) * 1rem) solid var(--semantic-color-background-surface-bold-hovered)}.slider.sc-wink-range-slider-base::-moz-range-thumb{appearance:none;height:calc(var(--size) * 1rem);width:calc(var(--size) * 1rem);background-clip:padding-box;background-color:var(--semantic-color-background-surface-action-default);border-radius:50%;margin-top:calc(var(--size) * 1rem * -0.5 + var(--semantic-spacing-3xs) * 1rem / 2);margin-left:calc(var(--semantic-spacing-3xs) * 1rem * -0.5);pointer-events:all;cursor:pointer;-moz-transition:all 300ms ease-in-out;transition:all 300ms ease-in-out;border:calc(var(--semantic-spacing-3xs) * 1rem) solid var(--semantic-color-background-input-outlined)}.slider-track.sc-wink-range-slider-base{position:absolute;left:0;width:calc(100% - var(--semantic-border-lg) * 1rem * 2);height:calc(var(--semantic-spacing-3xs) * 1rem);margin:0 calc(var(--semantic-border-lg) * 1rem);border-radius:calc(var(--semantic-spacing-3xs) * 1rem)}.slider-tooltip-wrapper.sc-wink-range-slider-base{position:relative;width:calc(100% - var(--semantic-border-lg) * 1rem * 2);height:100%;margin:0 calc(var(--semantic-spacing-xs) * 1rem)}.slider-specific.sc-wink-range-slider-base{flex-shrink:0;display:flex;align-items:flex-start;gap:calc(var(--semantic-spacing-sm) * 1rem)}";
const WinkRangeSliderBaseStyle0 = rangeSliderBaseCss;
const rangeSliderTelenetCss = ".sr-only.sc-wink-range-slider-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-range-slider-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.slider-container.sc-wink-range-slider-telenet{display:flex}.slider-container-range.sc-wink-range-slider-telenet{flex-direction:column;gap:calc(var(--semantic-spacing-xl) * 1rem)}.slider-container-range.sc-wink-range-slider-telenet .slider-specific.sc-wink-range-slider-telenet{width:100%}.slider-container-single.sc-wink-range-slider-telenet{flex-wrap:wrap}.slider-container-single.sc-wink-range-slider-telenet wink-form-label.sc-wink-range-slider-telenet{width:100%;margin-bottom:calc(var(--semantic-spacing-xl) * 1rem)}.slider-container-single.sc-wink-range-slider-telenet .slider-specific.sc-wink-range-slider-telenet{margin-left:calc(var(--semantic-spacing-md) * 1rem)}.slider-container-single.sc-wink-range-slider-telenet .slider.sc-wink-range-slider-telenet{cursor:pointer;pointer-events:all}.slider-wrapper.sc-wink-range-slider-telenet{font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:calc(var(--semantic-typography-font-size-desktop-sm) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-sm) * 1rem);color:var(--semantic-color-text-default);width:100%;padding-top:calc(var(--semantic-spacing-xs) * 1rem);display:flex;align-items:center;gap:calc(var(--semantic-spacing-sm) * 1rem)}.slider-controls.sc-wink-range-slider-telenet{position:relative;width:100%;height:calc(var(--semantic-spacing-xl) * 1rem);display:flex;align-items:center;justify-content:space-between}.slider-controls.sc-wink-range-slider-telenet:has(.slider:focus) .slider-tooltip.sc-wink-range-slider-telenet,.slider-controls.sc-wink-range-slider-telenet:has(.slider:hover) .slider-tooltip.sc-wink-range-slider-telenet{opacity:1}.slider-tooltip.sc-wink-range-slider-telenet{position:absolute;top:calc(var(--semantic-icon-xl) * 1rem * -1);font-size:calc(var(--semantic-typography-font-size-desktop-xs) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-xs) * 1rem);text-align:center;background-color:var(--semantic-color-background-input-outlined);color:var(--semantic-color-text-default);padding:calc(var(--semantic-spacing-2xs) * 1rem);border-radius:calc(var(--semantic-border-lg) * 1rem);box-shadow:0 calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-xs) * 1rem) 0 var(--semantic-color-background-input-filled);transform:translateX(-50%);min-width:calc(var(--semantic-icon-md) * 1rem);opacity:0;transition:opacity 300ms ease-in-out}.slider-tooltip-shown.sc-wink-range-slider-telenet .slider-tooltip.sc-wink-range-slider-telenet{opacity:1}.slider.sc-wink-range-slider-telenet{--size:calc(var(--semantic-icon-md) + (var(--semantic-spacing-3xs) * 2));appearance:none;position:absolute;left:0;width:100%;height:4.4rem;background-color:transparent;pointer-events:none}.slider.sc-wink-range-slider-telenet::-webkit-slider-runnable-track{width:100%;height:calc(var(--semantic-spacing-3xs) * 1rem);background-color:transparent;box-shadow:none;border:0;animation:0.2s}.slider.sc-wink-range-slider-telenet::-webkit-slider-thumb{appearance:none;height:calc(var(--size) * 1rem);width:calc(var(--size) * 1rem);background-clip:padding-box;background-color:var(--semantic-color-background-surface-action-default);border-radius:50%;margin-top:calc(var(--size) * 1rem * -0.5 + var(--semantic-spacing-3xs) * 1rem / 2);margin-left:calc(var(--semantic-spacing-3xs) * 1rem * -0.5);pointer-events:all;cursor:pointer;-webkit-transition:all 300ms ease-in-out;transition:all 300ms ease-in-out;border:calc(var(--semantic-spacing-3xs) * 1rem) solid transparent}.slider.sc-wink-range-slider-telenet::-webkit-slider-thumb:hover{--size:calc(var(--semantic-icon-md) + var(--semantic-spacing-3xs) + (var(--semantic-spacing-3xs) * 2));border:calc(var(--semantic-spacing-3xs) * 1rem) solid var(--semantic-color-background-surface-bold-hovered)}.slider.sc-wink-range-slider-telenet::-moz-range-track{width:100%;height:calc(var(--semantic-spacing-3xs) * 1rem);background-color:transparent;box-shadow:none;border:0;animation:0.2s}.slider.sc-wink-range-slider-telenet::-moz-range-track:hover{--size:calc(var(--semantic-icon-md) + var(--semantic-spacing-3xs) + (var(--semantic-spacing-3xs) * 2));border:calc(var(--semantic-spacing-3xs) * 1rem) solid var(--semantic-color-background-surface-bold-hovered)}.slider.sc-wink-range-slider-telenet::-moz-range-thumb{appearance:none;height:calc(var(--size) * 1rem);width:calc(var(--size) * 1rem);background-clip:padding-box;background-color:var(--semantic-color-background-surface-action-default);border-radius:50%;margin-top:calc(var(--size) * 1rem * -0.5 + var(--semantic-spacing-3xs) * 1rem / 2);margin-left:calc(var(--semantic-spacing-3xs) * 1rem * -0.5);pointer-events:all;cursor:pointer;-moz-transition:all 300ms ease-in-out;transition:all 300ms ease-in-out;border:calc(var(--semantic-spacing-3xs) * 1rem) solid var(--semantic-color-background-input-outlined)}.slider-track.sc-wink-range-slider-telenet{position:absolute;left:0;width:calc(100% - var(--semantic-border-lg) * 1rem * 2);height:calc(var(--semantic-spacing-3xs) * 1rem);margin:0 calc(var(--semantic-border-lg) * 1rem);border-radius:calc(var(--semantic-spacing-3xs) * 1rem)}.slider-tooltip-wrapper.sc-wink-range-slider-telenet{position:relative;width:calc(100% - var(--semantic-border-lg) * 1rem * 2);height:100%;margin:0 calc(var(--semantic-spacing-xs) * 1rem)}.slider-specific.sc-wink-range-slider-telenet{flex-shrink:0;display:flex;align-items:flex-start;gap:calc(var(--semantic-spacing-sm) * 1rem)}";
const WinkRangeSliderTelenetStyle0 = rangeSliderTelenetCss;
const RangeSlider = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.proxyCustomElement)(class RangeSlider extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.sliderId = '';
    this.label = '';
    this.helper = '';
    this.minValue = 0;
    this.maxValue = 100;
    this.step = 1;
    this.showValues = false;
    this.showInput = false;
    this.errorMessage = '';
    this.sliderType = SLIDER_TYPES.range;
    this.bottomValue = 0;
    this.value = 100;
    this.topValueError = undefined;
    this.bottomValueError = undefined;
  }
  internals;
  showFromValue() {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this.bottomValue;
    })();
  }
  showToValue() {
    var _this2 = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this2.value;
    })();
  }
  getDragValue() {
    var _this3 = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      return _this3.value;
    })();
  }
  componentWillRender() {
    this.checkForErrors();
  }
  handleValueChanged(event, slider) {
    const value = parseFloat(event.detail);
    this.updateValue(value, slider);
  }
  handleValueSlider(event, slider) {
    const inputElement = event.target;
    if (inputElement) {
      const value = parseFloat(inputElement.value);
      this.updateValue(value, slider);
    }
  }
  updateValue(value, slider) {
    if (slider === SLIDER_DIRECTIONS.from) {
      this.bottomValue = value;
    }
    if (slider === SLIDER_DIRECTIONS.to) {
      this.value = value;
    }
    if (value < this.minValue) {
      slider === SLIDER_DIRECTIONS.from ? this.bottomValue = this.minValue : this.value = this.minValue;
    }
    if (value > this.maxValue) {
      this.value = this.maxValue;
    }
    if (this.bottomValue > this.value) {
      this.invertValues();
    }
  }
  invertValues() {
    const tempValue = this.bottomValue;
    this.bottomValue = this.value;
    this.value = tempValue;
  }
  calculateTooltipPosition(value) {
    const newValue = Number((value - this.minValue) * 100 / (this.maxValue - this.minValue));
    const newPosition = 10 - newValue * 0.2;
    if (newValue < 0) {
      return '3%';
    }
    if (newValue > 100) {
      return '97%';
    }
    return `calc(${newValue}% + (${newPosition}px))`;
  }
  calculateBackground() {
    const lowTopValue = this.minValue || 0;
    const highTopValue = this.maxValue || 100;
    const lowValue = this.bottomValue || lowTopValue;
    const highValue = this.value || highTopValue;
    const sliderLength = highTopValue - lowTopValue;
    const toPercentage = Math.round((highValue - lowTopValue) / sliderLength * 100 / this.step) * this.step;
    if (this.sliderType === SLIDER_TYPES.single) {
      return `linear-gradient(to right, var(--semantic-color-background-surface-action-default) ${toPercentage}%, var(--semantic-color-background-surface-bold-hovered) ${toPercentage}%)`;
    }
    const fromPercentage = Math.round((lowValue - lowTopValue) / sliderLength * 100 / this.step) * this.step;
    return `linear-gradient(to right, var(--semantic-color-background-surface-bold-hovered) ${fromPercentage}% , var(--semantic-color-background-surface-action-default) ${fromPercentage}% , var(--semantic-color-background-surface-action-default) ${toPercentage}%, var(--semantic-color-background-surface-bold-hovered) ${toPercentage}%)`;
  }
  renderSpecific() {
    const fromValueProps = this.bottomValueError ? {
      error: this.bottomValueError
    } : {};
    const toValueProps = this.topValueError && this.sliderType === SLIDER_TYPES.range ? {
      error: this.topValueError
    } : {};
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      class: "slider-specific"
    }, this.sliderType === SLIDER_TYPES.range && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-input", {
      class: "slider-specific-from",
      type: "number",
      inputId: this.sliderId + 'from-value',
      name: "fromValue",
      label: "From",
      value: this.bottomValue.toString(),
      "min-value": this.minValue,
      "max-value": this.maxValue,
      step: this.step,
      isRequired: true,
      ...fromValueProps,
      onValueChanged: event => this.handleValueChanged(event, SLIDER_DIRECTIONS.from)
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-input", {
      class: "slider-specific-to",
      type: "number",
      inputId: this.sliderId + 'to-value',
      name: "toValue",
      label: this.sliderType === SLIDER_TYPES.range ? 'To' : '',
      value: this.value.toString(),
      "min-value": this.minValue,
      "max-value": this.maxValue,
      step: this.step,
      isRequired: true,
      ...toValueProps,
      onValueChanged: event => this.handleValueChanged(event, SLIDER_DIRECTIONS.to)
    }));
  }
  checkForErrors() {
    if (!this.bottomValue && this.bottomValue !== 0 || this.bottomValue % this.step !== 0) {
      this.bottomValueError = this.errorMessage;
    } else {
      this.bottomValueError = undefined;
    }
    if (!this.value && this.value !== 0 || this.value % this.step !== 0) {
      this.topValueError = this.errorMessage;
    } else {
      this.topValueError = undefined;
    }
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("label", {
      key: 'a9f898767e2d6e1e94cac11d09c9c78b24f010da',
      class: `slider-container slider-container-${this.sliderType}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-form-label", {
      key: '5652e8d44e355e459d5e1cd5646e72d1eb5e7322',
      label: this.label,
      helper: this.helper
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      key: '5c9b646830bb0774de70cf4a7e32f511731f71a0',
      class: "slider-wrapper"
    }, this.showValues && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("span", null, this.minValue), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      key: 'e7ee2f3cd7896e4d3d0461e3806e7aea9c6a66e3',
      class: "slider-controls"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      key: '388b3f0a1530ce5731556f136da3607828d126e4',
      class: `slider-tooltip-wrapper ${!this.showInput ? 'slider-tooltip-shown' : ''}`
    }, this.sliderType === SLIDER_TYPES.range && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      style: {
        left: this.calculateTooltipPosition(this.bottomValue)
      },
      class: "slider-tooltip"
    }, this.bottomValue), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      key: '06a0ad3ccee21c8be0504fdd1688906764347de9',
      style: {
        left: this.calculateTooltipPosition(this.value)
      },
      class: "slider-tooltip"
    }, this.value)), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("div", {
      key: 'b2acd782cecc66fb30a0278c5df7cf7b1fbb786e',
      style: {
        background: this.calculateBackground()
      },
      class: "slider-track"
    }), this.sliderType === SLIDER_TYPES.range && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("input", {
      class: "slider slider-from",
      type: "range",
      value: this.bottomValue,
      min: this.minValue,
      max: this.maxValue,
      step: this.step,
      onInput: event => this.handleValueSlider(event, SLIDER_DIRECTIONS.from)
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("input", {
      key: 'bbc14c32e53527848d3ccaeebc97666976668853',
      class: "slider slider-to",
      type: "range",
      value: this.value,
      min: this.minValue,
      max: this.maxValue,
      step: this.step,
      onInput: event => this.handleValueSlider(event, SLIDER_DIRECTIONS.to)
    })), this.showValues && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("span", null, this.maxValue), this.sliderType === SLIDER_TYPES.single && this.showInput && this.renderSpecific()), this.sliderType === SLIDER_TYPES.range && this.showInput && this.renderSpecific(), this.topValueError && this.sliderType === SLIDER_TYPES.single && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-validation-message", {
      message: this.topValueError,
      type: "error"
    }));
  }
  static get style() {
    return {
      base: WinkRangeSliderBaseStyle0,
      telenet: WinkRangeSliderTelenetStyle0
    };
  }
}, [34, "wink-range-slider", {
  "sliderId": [1, "slider-id"],
  "label": [1],
  "helper": [1],
  "minValue": [2, "min-value"],
  "maxValue": [2, "max-value"],
  "step": [2],
  "showValues": [4, "show-values"],
  "showInput": [4, "show-input"],
  "errorMessage": [1, "error-message"],
  "sliderType": [1, "slider-type"],
  "bottomValue": [1538, "bottom-value"],
  "value": [1538],
  "topValueError": [32],
  "bottomValueError": [32],
  "showFromValue": [64],
  "showToValue": [64],
  "getDragValue": [64]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-range-slider", "wink-form-label", "wink-icon", "wink-input", "wink-validation-message"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-range-slider":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, RangeSlider);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
      case "wink-input":
        if (!customElements.get(tagName)) {
          (0,_input_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-validation-message":
        if (!customElements.get(tagName)) {
          (0,_validation_message_js__WEBPACK_IMPORTED_MODULE_4__.d)();
        }
        break;
    }
  });
}
const WinkRangeSlider = RangeSlider;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 1149:
/*!*************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-select.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkSelect: () => (/* binding */ WinkSelect),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./form-label.js */ 78529);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 69900);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _validation_message_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./validation-message.js */ 46024);





const selectBaseCss = ".sr-only.sc-wink-select-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-select-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-select-base-h{display:block}.sc-wink-select-base-h wink-form-label.sc-wink-select-base{margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}.sc-wink-select-base-h .select-wrapper.sc-wink-select-base{--wink-icon-bg-color:transparent;--wink-icon-color:var(--semantic-color-icon-default);position:relative;width:100%}.sc-wink-select-base-h .select-wrapper.sc-wink-select-base wink-icon.sc-wink-select-base{position:absolute;top:calc(var(--semantic-spacing-2xs) * 1rem);right:calc(var(--semantic-spacing-2xs) * 1rem);cursor:pointer;pointer-events:none}.sc-wink-select-base-h select.sc-wink-select-base{background-color:transparent;appearance:none;display:block;margin:0;box-sizing:border-box;width:100%;padding:calc(var(--semantic-spacing-sm) * 1rem) calc(var(--semantic-spacing-sm) * 1rem);border-radius:0;border-width:calc(var(--semantic-border-md) * 1rem);border-style:solid;border-color:var(--semantic-color-border-bold);font-size:18px;line-height:28px;color:var(--semantic-color-text-default)}.sc-wink-select-base-h select.placeholder.sc-wink-select-base{color:var(--semantic-color-text-subtle)}.sc-wink-select-base-h select.sc-wink-select-base:hover{border-color:var(--semantic-color-border-highlight);cursor:pointer}.sc-wink-select-base-h select.sc-wink-select-base:focus{outline-offset:0.2rem;outline:calc(var(--semantic-border-md) * 1rem) solid var(--semantic-color-border-focus);border-color:var(--semantic-color-border-highlight)}.sc-wink-select-base-h select.invalid.sc-wink-select-base{border-color:var(--semantic-color-border-error)}.sc-wink-select-base-h .label-disabled.sc-wink-select-base,.sc-wink-select-base-h select.sc-wink-select-base:disabled,.sc-wink-select-base-h select.sc-wink-select-base:disabled+wink-icon.sc-wink-select-base{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-select-base-h select.sc-wink-select-base:disabled{border-color:var(--semantic-color-border-bold);background-color:var(--semantic-color-background-surface-bold-default)}";
const WinkSelectBaseStyle0 = selectBaseCss;
const selectTelenetCss = ".sr-only.sc-wink-select-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-select-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-select-telenet-h{display:block}.sc-wink-select-telenet-h wink-form-label.sc-wink-select-telenet{margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}.sc-wink-select-telenet-h .select-wrapper.sc-wink-select-telenet{--wink-icon-bg-color:transparent;--wink-icon-color:var(--semantic-color-icon-default);position:relative;width:100%}.sc-wink-select-telenet-h .select-wrapper.sc-wink-select-telenet wink-icon.sc-wink-select-telenet{position:absolute;top:calc(var(--semantic-spacing-2xs) * 1rem);right:calc(var(--semantic-spacing-2xs) * 1rem);cursor:pointer;pointer-events:none}.sc-wink-select-telenet-h select.sc-wink-select-telenet{background-color:transparent;appearance:none;display:block;margin:0;box-sizing:border-box;width:100%;padding:calc(var(--semantic-spacing-sm) * 1rem) calc(var(--semantic-spacing-sm) * 1rem);border-radius:0;border-width:calc(var(--semantic-border-md) * 1rem);border-style:solid;border-color:var(--semantic-color-border-bold);font-size:18px;line-height:28px;color:var(--semantic-color-text-default)}.sc-wink-select-telenet-h select.placeholder.sc-wink-select-telenet{color:var(--semantic-color-text-subtle)}.sc-wink-select-telenet-h select.sc-wink-select-telenet:hover{border-color:var(--semantic-color-border-highlight);cursor:pointer}.sc-wink-select-telenet-h select.sc-wink-select-telenet:focus{outline-offset:0.2rem;outline:calc(var(--semantic-border-md) * 1rem) solid var(--semantic-color-border-focus);border-color:var(--semantic-color-border-highlight)}.sc-wink-select-telenet-h select.invalid.sc-wink-select-telenet{border-color:var(--semantic-color-border-error)}.sc-wink-select-telenet-h .label-disabled.sc-wink-select-telenet,.sc-wink-select-telenet-h select.sc-wink-select-telenet:disabled,.sc-wink-select-telenet-h select.sc-wink-select-telenet:disabled+wink-icon.sc-wink-select-telenet{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-select-telenet-h select.sc-wink-select-telenet:disabled{border-color:var(--semantic-color-border-bold);background-color:var(--semantic-color-background-surface-bold-default)}";
const WinkSelectTelenetStyle0 = selectTelenetCss;
const Select = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.proxyCustomElement)(class Select extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.label = undefined;
    this.helper = undefined;
    this.isRequired = false;
    this.selectId = '';
    this.selectName = undefined;
    this.error = undefined;
    this.isDisabled = false;
    this.value = undefined;
    this.placeholder = undefined;
  }
  internals;
  get host() {
    return this;
  }
  componentDidRender() {
    const selectEl = this.host.querySelector('select');
    if (selectEl?.value === '') {
      selectEl.classList.add('placeholder');
    }
    this.selectId = this.selectId.length > 0 ? this.selectId : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.U)();
  }
  handleChange(e) {
    this.value = e.target.value;
    if (this.value === '') {
      e.target.classList.add('placeholder');
    } else {
      e.target.classList.remove('placeholder');
    }
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.Host, {
      key: '1813c868d5c6d5afafba0a266225d0e202f27a29'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("label", {
      key: '53affcdc0add022abc8cfb91035e34a0ad93041f',
      class: {
        'label-disabled': this.isDisabled
      },
      htmlFor: this.selectId
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-form-label", {
      key: 'e5fb998d5c5286ccae9de63348c1d1f85934231a',
      label: this.label,
      helper: this.helper,
      rendition: _form_label_js__WEBPACK_IMPORTED_MODULE_0__.F.default,
      "show-optional": this.isRequired
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
      key: 'c8a423819070a049c140f4e2081eafda63afe6c9',
      class: "select-wrapper"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("select", {
      key: 'adf6fda40188d6cd15d3ccf864e80cd74835ee45',
      id: this.selectId,
      name: this.selectName,
      "aria-invalid": !!this.error,
      onChange: e => this.handleChange(e),
      disabled: !!this.isDisabled,
      class: {
        invalid: !!this.error
      }
    }, this.placeholder && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("option", {
      value: "",
      selected: true,
      disabled: true
    }, this.placeholder), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("slot", {
      key: '2490da6cbc2e15be733cac6f560a147935bc80da'
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-icon", {
      key: '7a306fb86ee49e44904abe9cdd23423e0bbecc83',
      icon: "chevron-down",
      appearance: "transparent"
    })), this.error && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-validation-message", {
      message: this.error
    }));
  }
  static get style() {
    return {
      base: WinkSelectBaseStyle0,
      telenet: WinkSelectTelenetStyle0
    };
  }
}, [38, "wink-select", {
  "label": [1],
  "helper": [1],
  "isRequired": [4, "is-required"],
  "selectId": [1, "select-id"],
  "selectName": [1, "select-name"],
  "error": [1],
  "isDisabled": [4, "is-disabled"],
  "value": [1],
  "placeholder": [1]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-select", "wink-form-label", "wink-icon", "wink-validation-message"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-select":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Select);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_0__.d)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
      case "wink-validation-message":
        if (!customElements.get(tagName)) {
          (0,_validation_message_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
    }
  });
}
const WinkSelect = Select;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 22180:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-sheet.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkSheet: () => (/* binding */ WinkSheet),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./animation.js */ 8071);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon.js */ 45477);




const sheetBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block;--semantic-duration-medium:300ms;--semantic-duration-very-slow:500ms;--semantic-easing-productive-ease-in:cubic-bezier(0.11, 0, 0.5, 0);--semantic-easing-productive-ease-out:cubic-bezier(0.5, 1, 0.89, 1)}:host .sheet{--sticky-footer-height:10;background-color:var(--semantic-color-background-surface-neutral-overlapping-default);color:var(--semantic-color-text-default);border:unset;position:fixed;inset:auto auto 0 0;padding:0;margin:unset;width:100vw;height:-moz-fit-content;height:fit-content;max-width:100%;max-height:85vh;overflow:hidden;transition:display var(--semantic-duration-medium) allow-discrete, overlay var(--semantic-duration-medium) allow-discrete;animation-name:sheetMobileFadeOut;animation-duration:var(--semantic-duration-very-slow);animation-timing-function:var(--semantic-easing-productive-ease-out);animation-fill-mode:forwards;box-sizing:border-box;display:flex;flex-direction:column}@media only screen and (min-width: 48.0625em){:host .sheet{animation-name:sheetDesktopFadeOut;inset:0 0 0 auto;left:unset;right:0;top:0;bottom:0;width:-moz-fit-content;width:fit-content;height:100vh;max-width:50%;max-height:100%}}@media only screen and (min-width: 74.5em){:host .sheet{max-width:55.6rem}}:host .sheet::backdrop{pointer-events:none;background-color:var(--semantic-color-background-surface-overlay);transition:opacity var(--semantic-duration-very-slow) display var(--semantic-duration-very-slow) allow-discrete, overlay var(--semantic-duration-very-slow) allow-discrete;opacity:0}:host .sheet[open]{animation-name:sheetMobileFadeIn;animation-timing-function:var(--semantic-easing-productive-ease-in)}@media only screen and (min-width: 48.0625em){:host .sheet[open]{animation-name:sheetDesktopFadeIn}}:host .sheet[open]::backdrop{opacity:1}:host .sheet:not([open]){pointer-events:none;opacity:0}:host .sheet-darker,:host .sheet-darker .sheet-footer{background-color:var(--semantic-color-background-surface-neutral-overlapping-default)}:host .sheet-content{display:flex;flex:1;flex-direction:column;max-height:85vh;overflow:hidden;font-size:1.8rem;padding-top:calc(var(--semantic-icon-md) * 1rem + 2 * var(--semantic-spacing-md) * 1rem)}@media only screen and (min-width: 48.0625em){:host .sheet-content{padding-top:calc(var(--semantic-icon-md) * 1rem + 2 * var(--semantic-spacing-lg) * 1rem)}}:host .sheet-content-scroll{padding:0 calc(var(--semantic-spacing-lg) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);overflow-y:auto}@media only screen and (min-width: 48.0625em){:host .sheet-content-scroll{padding-bottom:calc(var(--sticky-footer-height) * 1rem + var(--semantic-spacing-lg) * 1rem)}}:host .sheet-content-page{display:none}:host .sheet-content-page-visible{display:block}:host .sheet-icon{--icon-position:var(--semantic-spacing-3xs);cursor:pointer;position:absolute;top:calc(var(--icon-position) * 1rem)}@media only screen and (min-width: 48.0625em){:host .sheet-icon{--icon-position:var(--semantic-spacing-sm)}}:host .sheet-icon-close{right:calc(var(--icon-position) * 1rem)}:host .sheet-icon-back{left:calc(var(--icon-position) * 1rem)}:host .sheet-footer{background-color:var(--semantic-color-background-surface-neutral-overlapping-default);padding:calc(var(--semantic-spacing-md) * 1rem);border-top:calc(var(--semantic-border-sm) * 1rem) solid var(--semantic-color-border-default);width:100%;max-height:calc(var(--sticky-footer-height) * 1rem);box-sizing:border-box;flex-shrink:0}@media only screen and (min-width: 48.0625em){:host .sheet-footer{position:absolute;bottom:0;left:0;padding:calc(var(--semantic-spacing-lg) * 1rem)}}:host .sheet-footer-sub{display:none}:host .sheet-footer-sub.sheet-footer-visible{display:flex;gap:calc(var(--semantic-spacing-md) * 1rem)}@keyframes sheetDesktopFadeIn{from{opacity:0;transform:translateX(100%)}to{opacity:1;transform:translateX(0)}}@keyframes sheetDesktopFadeOut{from{opacity:1;transform:translateX(0)}to{opacity:0;transform:translateX(100%)}}@keyframes sheetMobileFadeIn{from{opacity:0;transform:translateY(100%)}to{opacity:1;transform:translateY(0)}}@keyframes sheetMobileFadeOut{from{opacity:1;transform:translateY(0)}to{opacity:0;transform:translateY(100%)}}@media (prefers-reduced-motion){:host{animation-duration:0}}";
const WinkSheetBaseStyle0 = sheetBaseCss;
const sheetTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:block;--semantic-duration-medium:300ms;--semantic-duration-very-slow:500ms;--semantic-easing-productive-ease-in:cubic-bezier(0.11, 0, 0.5, 0);--semantic-easing-productive-ease-out:cubic-bezier(0.5, 1, 0.89, 1)}:host .sheet{--sticky-footer-height:10;background-color:var(--semantic-color-background-surface-neutral-overlapping-default);color:var(--semantic-color-text-default);border:unset;position:fixed;inset:auto auto 0 0;padding:0;margin:unset;width:100vw;height:-moz-fit-content;height:fit-content;max-width:100%;max-height:85vh;overflow:hidden;transition:display var(--semantic-duration-medium) allow-discrete, overlay var(--semantic-duration-medium) allow-discrete;animation-name:sheetMobileFadeOut;animation-duration:var(--semantic-duration-very-slow);animation-timing-function:var(--semantic-easing-productive-ease-out);animation-fill-mode:forwards;box-sizing:border-box;display:flex;flex-direction:column}@media only screen and (min-width: 48.0625em){:host .sheet{animation-name:sheetDesktopFadeOut;inset:0 0 0 auto;left:unset;right:0;top:0;bottom:0;width:-moz-fit-content;width:fit-content;height:100vh;max-width:50%;max-height:100%}}@media only screen and (min-width: 74.5em){:host .sheet{max-width:55.6rem}}:host .sheet::backdrop{pointer-events:none;background-color:var(--semantic-color-background-surface-overlay);transition:opacity var(--semantic-duration-very-slow) display var(--semantic-duration-very-slow) allow-discrete, overlay var(--semantic-duration-very-slow) allow-discrete;opacity:0}:host .sheet[open]{animation-name:sheetMobileFadeIn;animation-timing-function:var(--semantic-easing-productive-ease-in)}@media only screen and (min-width: 48.0625em){:host .sheet[open]{animation-name:sheetDesktopFadeIn}}:host .sheet[open]::backdrop{opacity:1}:host .sheet:not([open]){pointer-events:none;opacity:0}:host .sheet-darker,:host .sheet-darker .sheet-footer{background-color:var(--semantic-color-background-surface-neutral-overlapping-default)}:host .sheet-content{display:flex;flex:1;flex-direction:column;max-height:85vh;overflow:hidden;font-size:1.8rem;padding-top:calc(var(--semantic-icon-md) * 1rem + 2 * var(--semantic-spacing-md) * 1rem)}@media only screen and (min-width: 48.0625em){:host .sheet-content{padding-top:calc(var(--semantic-icon-md) * 1rem + 2 * var(--semantic-spacing-lg) * 1rem)}}:host .sheet-content-scroll{padding:0 calc(var(--semantic-spacing-lg) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);overflow-y:auto}@media only screen and (min-width: 48.0625em){:host .sheet-content-scroll{padding-bottom:calc(var(--sticky-footer-height) * 1rem + var(--semantic-spacing-lg) * 1rem)}}:host .sheet-content-page{display:none}:host .sheet-content-page-visible{display:block}:host .sheet-icon{--icon-position:var(--semantic-spacing-3xs);cursor:pointer;position:absolute;top:calc(var(--icon-position) * 1rem)}@media only screen and (min-width: 48.0625em){:host .sheet-icon{--icon-position:var(--semantic-spacing-sm)}}:host .sheet-icon-close{right:calc(var(--icon-position) * 1rem)}:host .sheet-icon-back{left:calc(var(--icon-position) * 1rem)}:host .sheet-footer{background-color:var(--semantic-color-background-surface-neutral-overlapping-default);padding:calc(var(--semantic-spacing-md) * 1rem);border-top:calc(var(--semantic-border-sm) * 1rem) solid var(--semantic-color-border-default);width:100%;max-height:calc(var(--sticky-footer-height) * 1rem);box-sizing:border-box;flex-shrink:0}@media only screen and (min-width: 48.0625em){:host .sheet-footer{position:absolute;bottom:0;left:0;padding:calc(var(--semantic-spacing-lg) * 1rem)}}:host .sheet-footer-sub{display:none}:host .sheet-footer-sub.sheet-footer-visible{display:flex;gap:calc(var(--semantic-spacing-md) * 1rem)}@keyframes sheetDesktopFadeIn{from{opacity:0;transform:translateX(100%)}to{opacity:1;transform:translateX(0)}}@keyframes sheetDesktopFadeOut{from{opacity:1;transform:translateX(0)}to{opacity:0;transform:translateX(100%)}}@keyframes sheetMobileFadeIn{from{opacity:0;transform:translateY(100%)}to{opacity:1;transform:translateY(0)}}@keyframes sheetMobileFadeOut{from{opacity:1;transform:translateY(0)}to{opacity:0;transform:translateY(100%)}}@media (prefers-reduced-motion){:host{animation-duration:0}}";
const WinkSheetTelenetStyle0 = sheetTelenetCss;
const Sheet = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.proxyCustomElement)(class Sheet extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.dashboard = false;
    this.multipage = false;
    this.isVisible = false;
    this.isOpen = false;
    this.hasStickyFooter = false;
    this.firstPage = true;
  }
  get host() {
    return this;
  }
  onIsVisibleChange() {
    if (this.isVisible && !this.isOpen) {
      this.openModal();
    }
    if (!this.isVisible && this.isOpen) {
      this.closeModal();
    }
  }
  open() {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this.openModal();
    })();
  }
  close() {
    var _this2 = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this2.closeModal();
    })();
  }
  nextPage() {
    var _this3 = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this3.goForward();
    })();
  }
  componentWillLoad() {
    if (this.isVisible && !this.isOpen) {
      this.openModal();
    }
    const stickyElements = this.host?.querySelectorAll('[slot*="footer"]');
    if (stickyElements.length > 0) {
      this.hasStickyFooter = true;
    }
  }
  componentDidLoad() {
    document.addEventListener('click', this.handleOutsideClick, true);
  }
  disconnectedCallback() {
    document.removeEventListener('click', this.handleOutsideClick, true);
  }
  handleOutsideClick = event => {
    if (this.isOpen && !this.host.contains(event.target)) {
      this.closeModal();
    }
  };
  handleButtonClick = event => {
    const target = event.target;
    if (target.tagName.toLowerCase() === 'wink-button') {
      if (target.classList.contains('wink-button-forward')) {
        this.goForward();
      }
      if (target.classList.contains('wink-button-back')) {
        this.goBack();
      }
      if (target.classList.contains('wink-button-close')) {
        this.close();
      }
    }
  };
  openModal() {
    if (this.isOpen) return;
    this.isVisible = true;
    this.isOpen = true;
    setTimeout(() => {
      const dialog = this.host.shadowRoot?.querySelector('dialog');
      if (dialog) {
        dialog.showModal();
      }
    }, 0);
  }
  closeModal() {
    if (!this.isOpen) return;
    this.isVisible = false;
    this.isOpen = false;
    const dialog = this.host.shadowRoot?.querySelector('dialog');
    if (dialog) {
      dialog.close();
    }
  }
  goBack() {
    this.firstPage = true;
  }
  goForward() {
    this.firstPage = false;
  }
  renderFooter() {
    if (!this.hasStickyFooter) return;
    if (this.multipage) {
      return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
        class: "sheet-footer"
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
        class: `sheet-footer-sub ${this.firstPage ? 'sheet-footer-visible' : ''}`
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
        name: "footer"
      })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
        class: `sheet-footer-sub ${!this.firstPage ? 'sheet-footer-visible' : ''}`
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
        name: "footer-second"
      })));
    }
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      class: "sheet-footer"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      name: "footer"
    }));
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("dialog", {
      key: '6c391240655b93400dd6736dc93cd169a12338b8',
      onClick: this.handleButtonClick,
      class: `sheet  ${this.hasStickyFooter ? 'sheet-margin-bottom' : ''} ${this.dashboard ? 'sheet-darker' : ''}`,
      "aria-live": "assertive"
    }, !this.firstPage && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-button", {
      appearance: "tertiary",
      size: "md",
      icon: "chevron-left",
      "icon-position": "center",
      class: "sheet-icon sheet-icon-back",
      "icon-button-aria-label": "Terug",
      onClick: this.goBack.bind(this)
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("wink-button", {
      key: '93349cd37b62fd955255b5a758ba796182d851ce',
      appearance: "tertiary",
      size: "md",
      icon: "cross",
      "icon-position": "center",
      class: "sheet-icon sheet-icon-close",
      "icon-button-aria-label": "Sluiten",
      onClick: this.closeModal.bind(this)
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      key: 'a99178e56a7a76ee6371955b59481db8c5a1654d',
      class: "sheet-content"
    }, this.multipage ? (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      class: "sheet-content-scroll"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      class: `sheet-content-page sheet-content-page-first ${this.firstPage ? 'sheet-content-page-visible' : ''}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      name: "page-first"
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      class: `sheet-content-page sheet-content-page-second ${!this.firstPage ? 'sheet-content-page-visible' : ''} `
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", {
      name: "page-second"
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", null)) : (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("div", {
      class: "sheet-content-scroll"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_3__.h)("slot", null)), this.renderFooter()));
  }
  static get watchers() {
    return {
      "isVisible": ["onIsVisibleChange"]
    };
  }
  static get style() {
    return {
      base: WinkSheetBaseStyle0,
      telenet: WinkSheetTelenetStyle0
    };
  }
}, [33, "wink-sheet", {
  "dashboard": [4],
  "multipage": [4],
  "isVisible": [1540, "is-visible"],
  "isOpen": [32],
  "hasStickyFooter": [32],
  "firstPage": [32],
  "open": [64],
  "close": [64],
  "nextPage": [64]
}, undefined, {
  "isVisible": ["onIsVisibleChange"]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-sheet", "wink-animation", "wink-button", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-sheet":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Sheet);
        }
        break;
      case "wink-animation":
        if (!customElements.get(tagName)) {
          (0,_animation_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
      case "wink-button":
        if (!customElements.get(tagName)) {
          (0,_animation_js__WEBPACK_IMPORTED_MODULE_1__.a)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
    }
  });
}
const WinkSheet = Sheet;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 42557:
/*!*************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-spacer.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkSpacer: () => (/* binding */ WinkSpacer),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.types.js */ 7988);


const spacerBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host .height-3xs{height:calc(var(--semantic-spacing-3xs) * 1rem)}:host .height-2xs{height:calc(var(--semantic-spacing-2xs) * 1rem)}:host .height-xs{height:calc(var(--semantic-spacing-xs) * 1rem)}:host .height-sm{height:calc(var(--semantic-spacing-sm) * 1rem)}:host .height-md{height:calc(var(--semantic-spacing-md) * 1rem)}:host .height-lg{height:calc(var(--semantic-spacing-lg) * 1rem)}:host .height-xl{height:calc(var(--semantic-spacing-xl) * 1rem)}:host .height-none{height:calc(var(--semantic-spacing-none) * 1rem)}";
const WinkSpacerBaseStyle0 = spacerBaseCss;
const spacerTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host .height-3xs{height:calc(var(--semantic-spacing-3xs) * 1rem)}:host .height-2xs{height:calc(var(--semantic-spacing-2xs) * 1rem)}:host .height-xs{height:calc(var(--semantic-spacing-xs) * 1rem)}:host .height-sm{height:calc(var(--semantic-spacing-sm) * 1rem)}:host .height-md{height:calc(var(--semantic-spacing-md) * 1rem)}:host .height-lg{height:calc(var(--semantic-spacing-lg) * 1rem)}:host .height-xl{height:calc(var(--semantic-spacing-xl) * 1rem)}:host .height-none{height:calc(var(--semantic-spacing-none) * 1rem)}";
const WinkSpacerTelenetStyle0 = spacerTelenetCss;
const Spacer = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class Spacer extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.size = _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.md;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: '0b4aedd2307b6ff895b6d090bbc6e75e8508c40f'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("div", {
      key: '912beed0ede283947b2305990f2eed3768e1333b',
      class: `height-${this.size}`
    }));
  }
  static get style() {
    return {
      base: WinkSpacerBaseStyle0,
      telenet: WinkSpacerTelenetStyle0
    };
  }
}, [33, "wink-spacer", {
  "size": [1]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-spacer"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-spacer":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Spacer);
        }
        break;
    }
  });
}
const WinkSpacer = Spacer;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 4140:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-stack.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkStack: () => (/* binding */ WinkStack),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sizes.types.js */ 7988);


const STACK_SIZES = {
  '3xs': _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S['3xs'],
  '2xs': _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S['2xs'],
  xs: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.xs,
  sm: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.sm,
  md: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.md,
  lg: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.lg,
  none: _sizes_types_js__WEBPACK_IMPORTED_MODULE_0__.S.none
};
const stackBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;box-sizing:border-box}:host(.justify-content-flex-start){justify-content:flex-start}:host(.justify-content-center){justify-content:center}:host(.justify-content-flex-end){justify-content:flex-end}:host(.justify-content-unset){justify-content:unset}:host(.justify-content-space-around){justify-content:space-around}:host(.justify-content-space-between){justify-content:space-between}:host(.justify-content-space-evenly){justify-content:space-evenly}:host(.justify-content-stretch){justify-content:stretch}:host(.justify-content-left){justify-content:left}:host(.justify-content-inherit){justify-content:inherit}:host(.justify-content-normal){justify-content:normal}:host(.align-items-flex-start){align-items:flex-start}:host(.align-items-center){align-items:center}:host(.align-items-flex-end){align-items:flex-end}:host(.align-items-baseline){align-items:baseline}:host(.align-items-stretch){align-items:stretch}:host(.align-items-inherit){align-items:inherit}:host(.flex-direction-row){flex-direction:row}:host(.flex-direction-row-reverse){flex-direction:row-reverse}:host(.flex-direction-column){flex-direction:column}:host(.flex-direction-column-reverse){flex-direction:column-reverse}:host(.flex-wrap-wrap){flex-wrap:wrap}:host(.flex-wrap-nowrap){flex-wrap:nowrap}:host(.flex-wrap-wrap-reverse){flex-wrap:wrap-reverse}:host(.flex-wrap-initial){flex-wrap:initial}:host(.col-1){flex-basis:8.3333333333%;max-width:8.3333333333%}:host(.col-2){flex-basis:16.6666666667%;max-width:16.6666666667%}:host(.col-3){flex-basis:25%;max-width:25%}:host(.col-4){flex-basis:33.3333333333%;max-width:33.3333333333%}:host(.col-5){flex-basis:41.6666666667%;max-width:41.6666666667%}:host(.col-6){flex-basis:50%;max-width:50%}:host(.col-7){flex-basis:58.3333333333%;max-width:58.3333333333%}:host(.col-8){flex-basis:66.6666666667%;max-width:66.6666666667%}:host(.col-9){flex-basis:75%;max-width:75%}:host(.col-10){flex-basis:83.3333333333%;max-width:83.3333333333%}:host(.col-11){flex-basis:91.6666666667%;max-width:91.6666666667%}:host(.col-12){flex-basis:100%;max-width:100%}:host(.gap-3xs){gap:calc(var(--semantic-spacing-3xs) * 1rem)}:host(.gap-2xs){gap:calc(var(--semantic-spacing-2xs) * 1rem)}:host(.gap-xs){gap:calc(var(--semantic-spacing-xs) * 1rem)}:host(.gap-sm){gap:calc(var(--semantic-spacing-sm) * 1rem)}:host(.gap-md){gap:calc(var(--semantic-spacing-md) * 1rem)}:host(.gap-lg){gap:calc(var(--semantic-spacing-lg) * 1rem)}:host(.gap-xl){gap:calc(var(--semantic-spacing-xl) * 1rem)}:host(.gap-none){gap:calc(var(--semantic-spacing-none) * 1rem)}";
const WinkStackBaseStyle0 = stackBaseCss;
const stackTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:flex;box-sizing:border-box}:host(.justify-content-flex-start){justify-content:flex-start}:host(.justify-content-center){justify-content:center}:host(.justify-content-flex-end){justify-content:flex-end}:host(.justify-content-unset){justify-content:unset}:host(.justify-content-space-around){justify-content:space-around}:host(.justify-content-space-between){justify-content:space-between}:host(.justify-content-space-evenly){justify-content:space-evenly}:host(.justify-content-stretch){justify-content:stretch}:host(.justify-content-left){justify-content:left}:host(.justify-content-inherit){justify-content:inherit}:host(.justify-content-normal){justify-content:normal}:host(.align-items-flex-start){align-items:flex-start}:host(.align-items-center){align-items:center}:host(.align-items-flex-end){align-items:flex-end}:host(.align-items-baseline){align-items:baseline}:host(.align-items-stretch){align-items:stretch}:host(.align-items-inherit){align-items:inherit}:host(.flex-direction-row){flex-direction:row}:host(.flex-direction-row-reverse){flex-direction:row-reverse}:host(.flex-direction-column){flex-direction:column}:host(.flex-direction-column-reverse){flex-direction:column-reverse}:host(.flex-wrap-wrap){flex-wrap:wrap}:host(.flex-wrap-nowrap){flex-wrap:nowrap}:host(.flex-wrap-wrap-reverse){flex-wrap:wrap-reverse}:host(.flex-wrap-initial){flex-wrap:initial}:host(.col-1){flex-basis:8.3333333333%;max-width:8.3333333333%}:host(.col-2){flex-basis:16.6666666667%;max-width:16.6666666667%}:host(.col-3){flex-basis:25%;max-width:25%}:host(.col-4){flex-basis:33.3333333333%;max-width:33.3333333333%}:host(.col-5){flex-basis:41.6666666667%;max-width:41.6666666667%}:host(.col-6){flex-basis:50%;max-width:50%}:host(.col-7){flex-basis:58.3333333333%;max-width:58.3333333333%}:host(.col-8){flex-basis:66.6666666667%;max-width:66.6666666667%}:host(.col-9){flex-basis:75%;max-width:75%}:host(.col-10){flex-basis:83.3333333333%;max-width:83.3333333333%}:host(.col-11){flex-basis:91.6666666667%;max-width:91.6666666667%}:host(.col-12){flex-basis:100%;max-width:100%}:host(.gap-3xs){gap:calc(var(--semantic-spacing-3xs) * 1rem)}:host(.gap-2xs){gap:calc(var(--semantic-spacing-2xs) * 1rem)}:host(.gap-xs){gap:calc(var(--semantic-spacing-xs) * 1rem)}:host(.gap-sm){gap:calc(var(--semantic-spacing-sm) * 1rem)}:host(.gap-md){gap:calc(var(--semantic-spacing-md) * 1rem)}:host(.gap-lg){gap:calc(var(--semantic-spacing-lg) * 1rem)}:host(.gap-xl){gap:calc(var(--semantic-spacing-xl) * 1rem)}:host(.gap-none){gap:calc(var(--semantic-spacing-none) * 1rem)}";
const WinkStackTelenetStyle0 = stackTelenetCss;
const Stack = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.proxyCustomElement)(class Stack extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.col = {
      default: 12
    };
    this.gap = {
      default: STACK_SIZES.xs
    };
    this.direction = undefined;
    this.justifyContent = undefined;
    this.alignItems = undefined;
    this.wrap = undefined;
  }
  getStackClasses = () => {
    return {
      ...this.getClassesByPostfix('col', 'col'),
      ...this.getClassesByPostfix('gap', 'gap'),
      ...this.getClassesByPostfix('flex-direction', 'direction'),
      ...this.getClassesByPostfix('justify-content', 'justifyContent'),
      ...this.getClassesByPostfix('align-items', 'alignItems'),
      ...this.getClassesByPostfix('flex-wrap', 'wrap')
    };
  };
  getClassesByPostfix(postFix, prop) {
    if (!this[prop]) {
      return {};
    }
    return {
      ...(this[prop].default && {
        [`${postFix}-${this[prop].default}`]: true
      }),
      ...(this[prop].sm && {
        [`${postFix}-${this[prop].sm}-sm`]: true
      }),
      ...(this[prop].md && {
        [`${postFix}-${this[prop].md}-md`]: true
      })
    };
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.Host, {
      key: '3af6d8c575758d252dd72454dfd40d02e2ccffe3',
      class: this.getStackClasses()
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_1__.h)("slot", {
      key: 'f614e77cf433a44ea8f4580d85f0ec853b804ad0'
    }));
  }
  static get style() {
    return {
      base: WinkStackBaseStyle0,
      telenet: WinkStackTelenetStyle0
    };
  }
}, [33, "wink-stack", {
  "col": [16],
  "gap": [16],
  "direction": [16],
  "justifyContent": [16],
  "alignItems": [16],
  "wrap": [16]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-stack"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-stack":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Stack);
        }
        break;
    }
  });
}
const WinkStack = Stack;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 78175:
/*!***********************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-tabs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkTabs: () => (/* binding */ WinkTabs),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 69900);
/* harmony import */ var _indicator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./indicator.js */ 19766);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon.js */ 45477);





const TAB_TYPES = {
  container: 'container',
  inline: 'inline'
};
const tabsBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host .tabs{color:var(--semantic-color-text-default)}:host .tabs *{box-sizing:border-box}:host .tabs .tab-header{position:relative;display:flex;width:100%}:host .tabs .tab-header .tab-list{min-width:100%;display:inline-flex}:host .tabs .tab-header .tab-list .tab,:host .tabs .tab-header .tab-list .tab:focus,:host .tabs .tab-header .tab-list .tab:hover{all:unset;cursor:pointer;flex-grow:1;text-transform:capitalize;padding:calc(var(--semantic-spacing-xs) * 1rem) calc(var(--semantic-spacing-3xs) * 1rem);outline-offset:-0.3rem;white-space:nowrap}:host .tabs .tab-header .tab-list .tab:first-of-type,:host .tabs .tab-header .tab-list .tab:focus:first-of-type,:host .tabs .tab-header .tab-list .tab:hover:first-of-type{padding-left:0}:host .tabs .tab-header .tab-list .tab:last-of-type,:host .tabs .tab-header .tab-list .tab:focus:last-of-type,:host .tabs .tab-header .tab-list .tab:hover:last-of-type{padding-right:0}:host .tabs .tab-header .tab-list .tab .tab-content,:host .tabs .tab-header .tab-list .tab:focus .tab-content,:host .tabs .tab-header .tab-list .tab:hover .tab-content{height:100%;background-color:var(--semantic-color-background-surface-bold-default);padding:calc(var(--semantic-spacing-md) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);font-size:1.4rem}:host .tabs .tab-header .tab-list .tab .tab-content p,:host .tabs .tab-header .tab-list .tab:focus .tab-content p,:host .tabs .tab-header .tab-list .tab:hover .tab-content p{margin:0}:host .tabs .tab-header .tab-list .tab .tab-content .tab-title,:host .tabs .tab-header .tab-list .tab:focus .tab-content .tab-title,:host .tabs .tab-header .tab-list .tab:hover .tab-content .tab-title{font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:1.8rem;line-height:2.8rem}:host .tabs .tab-header .tab-list .tab:has(+.is-active-tab),:host .tabs .tab-header .tab-list .tab:focus:has(+.is-active-tab),:host .tabs .tab-header .tab-list .tab:hover:has(+.is-active-tab){padding-right:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs .tab-header .tab-list .tab.is-active-tab,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab{background-color:var(--semantic-color-background-tab-default);position:relative;border-top:calc(var(--semantic-border-lg) * 1rem) solid var(--semantic-color-border-selected);padding:calc(var(--semantic-spacing-lg) * 1rem + var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-lg) * 1rem) calc(var(--semantic-spacing-lg) * 1rem)}@media only screen and (min-width: 36em){:host .tabs .tab-header .tab-list .tab.is-active-tab,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab{padding:calc(var(--semantic-spacing-lg) * 1rem - var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-lg) * 1rem) calc(var(--semantic-spacing-lg) * 1rem)}}:host .tabs .tab-header .tab-list .tab.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab .tab-content{background-color:unset;padding:unset}:host .tabs .tab-header .tab-list .tab.is-active-tab+.tab,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab+.tab,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab+.tab{padding-left:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs .tab-header .tab-list .tab:focus-visible,:host .tabs .tab-header .tab-list .tab:focus:focus-visible,:host .tabs .tab-header .tab-list .tab:hover:focus-visible{isolation:isolate}:host .tabs .tab-header .tab-list .tab:focus-visible:not(.is-active-tab) .tab-content,:host .tabs .tab-header .tab-list .tab:focus:focus-visible:not(.is-active-tab) .tab-content,:host .tabs .tab-header .tab-list .tab:hover:focus-visible:not(.is-active-tab) .tab-content{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .tabs .tab-header .tab-list .tab:focus-visible.is-active-tab,:host .tabs .tab-header .tab-list .tab:focus:focus-visible.is-active-tab,:host .tabs .tab-header .tab-list .tab:hover:focus-visible.is-active-tab{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .tabs .tab-header .tab-list .tab:focus-visible.is-active-tab:first-of-type,:host .tabs .tab-header .tab-list .tab:focus:focus-visible.is-active-tab:first-of-type,:host .tabs .tab-header .tab-list .tab:hover:focus-visible.is-active-tab:first-of-type{margin-left:calc(var(--semantic-spacing-3xs) * 1rem)}:host .tabs .tab-header .tab-list .tab:focus-visible.is-active-tab:last-of-type,:host .tabs .tab-header .tab-list .tab:focus:focus-visible.is-active-tab:last-of-type,:host .tabs .tab-header .tab-list .tab:hover:focus-visible.is-active-tab:last-of-type{margin-right:calc(var(--semantic-spacing-3xs) * 1rem)}:host .tabs .tab-header .tab-list .tab:hover .tab-content,:host .tabs .tab-header .tab-list .tab:focus:hover .tab-content,:host .tabs .tab-header .tab-list .tab:hover:hover .tab-content{background-color:var(--semantic-color-background-surface-bold-hovered)}:host .tabs .tab-header .tab-list .tab:hover.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:focus:hover.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:hover:hover.is-active-tab .tab-content{background-color:unset}:host .tabs .tab-header .tab-list .tab:disabled,:host .tabs .tab-header .tab-list .tab:focus:disabled,:host .tabs .tab-header .tab-list .tab:hover:disabled{cursor:not-allowed}:host .tabs .tab-header .tab-list .tab:disabled .tab-content,:host .tabs .tab-header .tab-list .tab:focus:disabled .tab-content,:host .tabs .tab-header .tab-list .tab:hover:disabled .tab-content{opacity:calc(var(--semantic-opacity-disabled) * 0.1)}:host .tabs .tab-header.is-scrollable{position:relative;z-index:1}:host .tabs .tab-header.is-scrollable .tab-list{overflow-x:auto;overflow-y:visible;padding:0.6rem 0;margin-bottom:-0.6rem;-ms-overflow-style:none;scrollbar-width:none}:host .tabs .tab-header.is-scrollable .tab-list::-webkit-scrollbar{display:none}:host .tabs .tab-header.is-scrollable .tab-list .tab{min-width:-moz-fit-content;min-width:fit-content}:host .tabs .tab-header .scroll-button{position:absolute;top:0;bottom:0;height:-moz-fit-content;height:fit-content;margin:auto 0}:host .tabs .tab-header .scroll-button-left{left:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs .tab-header .scroll-button-right{right:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs [role=tabpanel]{background-color:var(--semantic-color-background-tab-default);padding:calc(var(--semantic-spacing-lg) * 1rem);width:100%;overflow:auto}:host .tabs [role=tabpanel] *{font-size:1rem}:host .tabs [role=tabpanel].is-hidden{display:none}:host .tabs [role=tabpanel]:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem;outline-offset:-0.2rem}:host .tabs-inline .tab-header .tab-list .tab,:host .tabs-inline .tab-header .tab-list .tab:focus,:host .tabs-inline .tab-header .tab-list .tab:hover{border-bottom:0.1rem solid var(--semantic-color-border-default)}:host .tabs-inline .tab-header .tab-list .tab.is-active-tab,:host .tabs-inline .tab-header .tab-list .tab:focus.is-active-tab,:host .tabs-inline .tab-header .tab-list .tab:hover.is-active-tab{border:0.1rem solid var(--semantic-color-border-default);border-top:0.3rem solid var(--semantic-color-border-selected);border-bottom:0.1rem solid var(--semantic-color-background-tab-default)}";
const WinkTabsBaseStyle0 = tabsBaseCss;
const tabsTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{display:contents}:host .tabs{color:var(--semantic-color-text-default)}:host .tabs *{box-sizing:border-box}:host .tabs .tab-header{position:relative;display:flex;width:100%}:host .tabs .tab-header .tab-list{min-width:100%;display:inline-flex}:host .tabs .tab-header .tab-list .tab,:host .tabs .tab-header .tab-list .tab:focus,:host .tabs .tab-header .tab-list .tab:hover{all:unset;cursor:pointer;flex-grow:1;text-transform:capitalize;padding:calc(var(--semantic-spacing-xs) * 1rem) calc(var(--semantic-spacing-3xs) * 1rem);outline-offset:-0.3rem;white-space:nowrap}:host .tabs .tab-header .tab-list .tab:first-of-type,:host .tabs .tab-header .tab-list .tab:focus:first-of-type,:host .tabs .tab-header .tab-list .tab:hover:first-of-type{padding-left:0}:host .tabs .tab-header .tab-list .tab:last-of-type,:host .tabs .tab-header .tab-list .tab:focus:last-of-type,:host .tabs .tab-header .tab-list .tab:hover:last-of-type{padding-right:0}:host .tabs .tab-header .tab-list .tab .tab-content,:host .tabs .tab-header .tab-list .tab:focus .tab-content,:host .tabs .tab-header .tab-list .tab:hover .tab-content{height:100%;background-color:var(--semantic-color-background-surface-bold-default);padding:calc(var(--semantic-spacing-md) * 1rem) calc(var(--semantic-spacing-lg) * 1rem);font-size:1.4rem}:host .tabs .tab-header .tab-list .tab .tab-content p,:host .tabs .tab-header .tab-list .tab:focus .tab-content p,:host .tabs .tab-header .tab-list .tab:hover .tab-content p{margin:0}:host .tabs .tab-header .tab-list .tab .tab-content .tab-title,:host .tabs .tab-header .tab-list .tab:focus .tab-content .tab-title,:host .tabs .tab-header .tab-list .tab:hover .tab-content .tab-title{font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:1.8rem;line-height:2.8rem}:host .tabs .tab-header .tab-list .tab:has(+.is-active-tab),:host .tabs .tab-header .tab-list .tab:focus:has(+.is-active-tab),:host .tabs .tab-header .tab-list .tab:hover:has(+.is-active-tab){padding-right:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs .tab-header .tab-list .tab.is-active-tab,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab{background-color:var(--semantic-color-background-tab-default);position:relative;border-top:calc(var(--semantic-border-lg) * 1rem) solid var(--semantic-color-border-selected);padding:calc(var(--semantic-spacing-lg) * 1rem + var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-lg) * 1rem) calc(var(--semantic-spacing-lg) * 1rem)}@media only screen and (min-width: 36em){:host .tabs .tab-header .tab-list .tab.is-active-tab,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab{padding:calc(var(--semantic-spacing-lg) * 1rem - var(--semantic-spacing-3xs) * 1rem) calc(var(--semantic-spacing-lg) * 1rem) calc(var(--semantic-spacing-lg) * 1rem)}}:host .tabs .tab-header .tab-list .tab.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab .tab-content{background-color:unset;padding:unset}:host .tabs .tab-header .tab-list .tab.is-active-tab+.tab,:host .tabs .tab-header .tab-list .tab:focus.is-active-tab+.tab,:host .tabs .tab-header .tab-list .tab:hover.is-active-tab+.tab{padding-left:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs .tab-header .tab-list .tab:focus-visible,:host .tabs .tab-header .tab-list .tab:focus:focus-visible,:host .tabs .tab-header .tab-list .tab:hover:focus-visible{isolation:isolate}:host .tabs .tab-header .tab-list .tab:focus-visible:not(.is-active-tab) .tab-content,:host .tabs .tab-header .tab-list .tab:focus:focus-visible:not(.is-active-tab) .tab-content,:host .tabs .tab-header .tab-list .tab:hover:focus-visible:not(.is-active-tab) .tab-content{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .tabs .tab-header .tab-list .tab:focus-visible.is-active-tab,:host .tabs .tab-header .tab-list .tab:focus:focus-visible.is-active-tab,:host .tabs .tab-header .tab-list .tab:hover:focus-visible.is-active-tab{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}:host .tabs .tab-header .tab-list .tab:focus-visible.is-active-tab:first-of-type,:host .tabs .tab-header .tab-list .tab:focus:focus-visible.is-active-tab:first-of-type,:host .tabs .tab-header .tab-list .tab:hover:focus-visible.is-active-tab:first-of-type{margin-left:calc(var(--semantic-spacing-3xs) * 1rem)}:host .tabs .tab-header .tab-list .tab:focus-visible.is-active-tab:last-of-type,:host .tabs .tab-header .tab-list .tab:focus:focus-visible.is-active-tab:last-of-type,:host .tabs .tab-header .tab-list .tab:hover:focus-visible.is-active-tab:last-of-type{margin-right:calc(var(--semantic-spacing-3xs) * 1rem)}:host .tabs .tab-header .tab-list .tab:hover .tab-content,:host .tabs .tab-header .tab-list .tab:focus:hover .tab-content,:host .tabs .tab-header .tab-list .tab:hover:hover .tab-content{background-color:var(--semantic-color-background-surface-bold-hovered)}:host .tabs .tab-header .tab-list .tab:hover.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:focus:hover.is-active-tab .tab-content,:host .tabs .tab-header .tab-list .tab:hover:hover.is-active-tab .tab-content{background-color:unset}:host .tabs .tab-header .tab-list .tab:disabled,:host .tabs .tab-header .tab-list .tab:focus:disabled,:host .tabs .tab-header .tab-list .tab:hover:disabled{cursor:not-allowed}:host .tabs .tab-header .tab-list .tab:disabled .tab-content,:host .tabs .tab-header .tab-list .tab:focus:disabled .tab-content,:host .tabs .tab-header .tab-list .tab:hover:disabled .tab-content{opacity:calc(var(--semantic-opacity-disabled) * 0.1)}:host .tabs .tab-header.is-scrollable{position:relative;z-index:1}:host .tabs .tab-header.is-scrollable .tab-list{overflow-x:auto;overflow-y:visible;padding:0.6rem 0;margin-bottom:-0.6rem;-ms-overflow-style:none;scrollbar-width:none}:host .tabs .tab-header.is-scrollable .tab-list::-webkit-scrollbar{display:none}:host .tabs .tab-header.is-scrollable .tab-list .tab{min-width:-moz-fit-content;min-width:fit-content}:host .tabs .tab-header .scroll-button{position:absolute;top:0;bottom:0;height:-moz-fit-content;height:fit-content;margin:auto 0}:host .tabs .tab-header .scroll-button-left{left:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs .tab-header .scroll-button-right{right:calc(var(--semantic-spacing-xs) * 1rem)}:host .tabs [role=tabpanel]{background-color:var(--semantic-color-background-tab-default);padding:calc(var(--semantic-spacing-lg) * 1rem);width:100%;overflow:auto}:host .tabs [role=tabpanel] *{font-size:1.6rem}:host .tabs [role=tabpanel].is-hidden{display:none}:host .tabs [role=tabpanel]:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem;outline-offset:-0.2rem}:host .tabs-inline .tab-header .tab-list .tab,:host .tabs-inline .tab-header .tab-list .tab:focus,:host .tabs-inline .tab-header .tab-list .tab:hover{border-bottom:0.1rem solid var(--semantic-color-border-default)}:host .tabs-inline .tab-header .tab-list .tab.is-active-tab,:host .tabs-inline .tab-header .tab-list .tab:focus.is-active-tab,:host .tabs-inline .tab-header .tab-list .tab:hover.is-active-tab{border:0.1rem solid var(--semantic-color-border-default);border-top:0.3rem solid var(--semantic-color-border-selected);border-bottom:0.1rem solid var(--semantic-color-background-tab-default)}";
const WinkTabsTelenetStyle0 = tabsTelenetCss;
const Tabs = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.proxyCustomElement)(class Tabs extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.appearance = TAB_TYPES.container;
    this.activeTabIndex = 1;
    this.isScrollable = false;
    this.tabElements = [];
    this.uuidMap = new Map();
  }
  get host() {
    return this;
  }
  tabList;
  tabItems;
  handleClickOnButton = index => {
    this.activeTabIndex = index;
    this.handleScroll();
    this.tabItems[this.activeTabIndex - 1].focus();
  };
  handleKeyDown = e => {
    this.assignTheRightActiveTabIndex(e.key);
  };
  handleKeyDownIndicator = (e, direction) => {
    if (e.key === 'Enter') {
      direction === _indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.left ? this.handleScroll(_indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.left) : this.handleScroll(_indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.right);
    }
  };
  assignTheRightActiveTabIndex(key) {
    const supportedKeysMap = new Map([['ArrowRight', () => {
      this.handleScroll(_indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.right);
    }], ['ArrowLeft', () => {
      this.handleScroll(_indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.left);
    }], ['Home', () => {
      if (this.activeTabIndex !== 1) {
        this.activeTabIndex = 1;
      }
    }], ['End', () => {
      if (this.activeTabIndex !== this.tabElements.length) {
        this.activeTabIndex = this.tabElements.length;
      }
    }]]);
    const handler = supportedKeysMap.get(key);
    if (handler) {
      handler();
    }
  }
  findNextTabItemId(direction) {
    if (direction === _indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.left) {
      for (let i = this.activeTabIndex - 1; i > 0; i--) {
        const nextItem = this.tabList.querySelector('#tab-' + i);
        if (nextItem && !nextItem.hasAttribute('disabled')) {
          return i;
        }
      }
    } else {
      for (let i = this.activeTabIndex + 1; i < this.tabElements.length + 1; i++) {
        const nextItem = this.tabList.querySelector('#tab-' + i);
        if (nextItem && !nextItem.hasAttribute('disabled')) {
          return i;
        }
      }
    }
    return undefined;
  }
  handleScroll(direction) {
    if (direction) {
      this.activeTabIndex = this.findNextTabItemId(direction) || this.activeTabIndex;
    }
    const containerRect = this.tabList.getBoundingClientRect();
    const containerCenter = containerRect.width / 2;
    const activeTab = this.tabList.querySelector('#tab-' + this.activeTabIndex);
    if (activeTab) {
      const activeRect = activeTab.getBoundingClientRect();
      const activeCenter = activeRect.left + activeRect.width / 2;
      const scrollOffset = activeCenter - containerCenter;
      let scrollLeft = this.tabList.scrollLeft + scrollOffset - 8;
      if (this.activeTabIndex === 1) {
        scrollLeft = 0;
      }
      if (this.activeTabIndex === this.tabElements.length) {
        scrollLeft = this.tabList.scrollWidth;
      }
      this.tabList.scrollTo({
        left: scrollLeft,
        behavior: 'smooth'
      });
    }
  }
  checkIfScrollable() {
    this.tabList = this.host?.shadowRoot?.querySelector('.tab-list');
    this.tabItems = this.host?.shadowRoot?.querySelectorAll('.tab');
    let tabitemWidth = 0;
    this.tabItems.forEach(item => {
      tabitemWidth = tabitemWidth + item.offsetWidth;
    });
    if (tabitemWidth >= this.tabList.offsetWidth + 4) {
      this.isScrollable = true;
    } else {
      this.isScrollable = false;
    }
  }
  renderSlots(type) {
    return this.tabElements.map((item, index) => {
      const slotname = item.slot && item.slot.replace('tab-', '') || `${index + 1}`;
      const computedSlotName = type === 'tabpanel' ? `tabpanel-${slotname}` : `tab-${slotname}`;
      let uuid = this.uuidMap.get(computedSlotName);
      if (uuid === undefined) {
        uuid = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.U)();
        this.uuidMap.set(computedSlotName, uuid);
      }
      return type === 'tabpanel' ? (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
        key: uuid,
        id: `tabpanel-${index + 1}`,
        role: "tabpanel",
        "aria-labelledby": `tab-${index + 1}`,
        tabIndex: this.activeTabIndex === index + 1 ? 0 : -1,
        class: {
          'is-hidden': this.activeTabIndex !== index + 1
        }
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("slot", {
        name: `tab-${slotname}`
      })) : (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("button", {
        key: uuid,
        id: `tab-${index + 1}`,
        type: "button",
        role: "tab",
        disabled: item.hasAttribute('disabled'),
        class: `tab ${this.activeTabIndex === index + 1 ? 'is-active-tab' : ''}`,
        "aria-selected": `${this.activeTabIndex === index + 1}`,
        "aria-controls": `tabpanel-${index + 1}`,
        "aria-describedby": `tabpanel-${index + 1}`,
        onClick: () => this.handleClickOnButton(index + 1),
        onKeyDown: this.handleKeyDown
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
        class: "tab-content"
      }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("p", {
        class: "tab-title"
      }, " ", item.getAttribute('data-title')), item.getAttribute('data-subtitle')));
    });
  }
  componentWillLoad() {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      const tabDivs = _this.host?.querySelectorAll('div[slot*="tab-"]');
      _this.tabElements = Array.from(tabDivs);
    })();
  }
  componentDidLoad() {
    this.checkIfScrollable();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.Host, {
      key: '037d9e35e1e160cdf67e79565edffe9ef6097ea7'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
      key: '3d9c826186d92b384cefb90a933f435fc991a1e3',
      class: `tabs tabs-${this.appearance}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
      key: '91b6c377f1cc6b1040285e461c1aac15602c5a95',
      class: `tab-header ${this.isScrollable ? 'is-scrollable' : ''}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("div", {
      key: 'b699dcdec27e1c7177272613505d5e5623a82c5a',
      class: "tab-list",
      role: "tablist",
      "aria-labelledby": "tablist-1",
      ref: el => this.tabList = el
    }, this.renderSlots('tab')), this.isScrollable && this.activeTabIndex > 1 && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-indicator", {
      class: "scroll-button scroll-button-left",
      direction: "left",
      tabIndex: 1,
      onKeyDown: event => this.handleKeyDownIndicator(event, _indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.left),
      onClick: () => this.handleScroll(_indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.left)
    }), this.isScrollable && this.activeTabIndex !== this.tabElements.length && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_4__.h)("wink-indicator", {
      class: "scroll-button scroll-button-right",
      direction: "right",
      tabIndex: 1,
      onKeyDown: event => this.handleKeyDownIndicator(event, _indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.right),
      onClick: () => this.handleScroll(_indicator_js__WEBPACK_IMPORTED_MODULE_2__.a.right)
    })), this.renderSlots('tabpanel')));
  }
  static get style() {
    return {
      base: WinkTabsBaseStyle0,
      telenet: WinkTabsTelenetStyle0
    };
  }
}, [33, "wink-tabs", {
  "appearance": [1],
  "activeTabIndex": [32],
  "isScrollable": [32],
  "tabElements": [32],
  "uuidMap": [32]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-tabs", "wink-icon", "wink-indicator"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-tabs":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Tabs);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-indicator":
        if (!customElements.get(tagName)) {
          (0,_indicator_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
    }
  });
}
const WinkTabs = Tabs;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 62535:
/*!***************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-textarea.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkTextarea: () => (/* binding */ WinkTextarea),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _input_types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input.types.js */ 17663);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ 69900);
/* harmony import */ var _form_label_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./form-label.js */ 78529);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _validation_message_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./validation-message.js */ 46024);






const AUTOCOMPLETE_OPTIONS = {
  on: 'on',
  off: 'off'
};
const textareaBaseCss = ".sr-only.sc-wink-textarea-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-textarea-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-textarea-base-h{display:block}.sc-wink-textarea-base-h wink-form-label.sc-wink-textarea-base{margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}.sc-wink-textarea-base-h textarea.sc-wink-textarea-base{width:100%;font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:calc(var(--semantic-typography-font-size-desktop-sm) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-sm) * 1rem);color:var(--semantic-color-text-default);background:var(--color-background-input-outlined);border:calc(var(--semantic-border-md) * 1rem) solid var(--semantic-color-border-bold);padding:calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem)}.sc-wink-textarea-base-h textarea.sc-wink-textarea-base::placeholder{color:var(--semantic-color-text-subtle)}.sc-wink-textarea-base-h textarea[aria-invalid].sc-wink-textarea-base{border-color:var(--semantic-color-border-error)}.sc-wink-textarea-base-h textarea.sc-wink-textarea-base:hover{border-color:var(--semantic-color-border-highlight)}.sc-wink-textarea-base-h textarea.sc-wink-textarea-base:disabled,.sc-wink-textarea-base-h textarea.sc-wink-textarea-base:disabled~*.sc-wink-textarea-base{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-textarea-base-h textarea.sc-wink-textarea-base:disabled:hover{border-color:var(--semantic-color-border-button-default)}.sc-wink-textarea-base-h textarea.sc-wink-textarea-base:focus,.sc-wink-textarea-base-h textarea.sc-wink-textarea-base:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}";
const WinkTextareaBaseStyle0 = textareaBaseCss;
const textareaTelenetCss = ".sr-only.sc-wink-textarea-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-textarea-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-textarea-telenet-h{display:block}.sc-wink-textarea-telenet-h wink-form-label.sc-wink-textarea-telenet{margin-bottom:calc(var(--semantic-spacing-3xs) * 1rem)}.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet{width:100%;font-family:TelenetAlbra, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:400;font-size:calc(var(--semantic-typography-font-size-desktop-sm) * 1rem);line-height:calc(var(--semantic-typography-line-height-desktop-sm) * 1rem);color:var(--semantic-color-text-default);background:var(--color-background-input-outlined);border:calc(var(--semantic-border-md) * 1rem) solid var(--semantic-color-border-bold);padding:calc(var(--semantic-spacing-2xs) * 1rem) calc(var(--semantic-spacing-sm) * 1rem)}.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet::placeholder{color:var(--semantic-color-text-subtle)}.sc-wink-textarea-telenet-h textarea[aria-invalid].sc-wink-textarea-telenet{border-color:var(--semantic-color-border-error)}.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet:hover{border-color:var(--semantic-color-border-highlight)}.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet:disabled,.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet:disabled~*.sc-wink-textarea-telenet{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet:disabled:hover{border-color:var(--semantic-color-border-button-default)}.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet:focus,.sc-wink-textarea-telenet-h textarea.sc-wink-textarea-telenet:focus-visible{outline-offset:0.1rem;outline:0.2rem solid var(--semantic-color-border-focus);border-radius:0.1rem}";
const WinkTextareaTelenetStyle0 = textareaTelenetCss;
const TextArea = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.proxyCustomElement)(class TextArea extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.isDisabled = false;
    this.isRequired = false;
    this.autocomplete = AUTOCOMPLETE_OPTIONS.off;
    this.enterkeyhintOption = _input_types_js__WEBPACK_IMPORTED_MODULE_0__.I.none;
    this.textareaId = undefined;
    this.label = undefined;
    this.helper = undefined;
    this.name = undefined;
    this.placeholder = undefined;
    this.error = undefined;
    this.minlength = undefined;
    this.maxlength = undefined;
    this.rows = undefined;
  }
  getAttributes() {
    return {
      ...(this.textareaId && {
        id: this.textareaId
      }),
      ...(this.name && {
        name: this.name
      }),
      ...(this.autocomplete && {
        autocomplete: this.autocomplete
      }),
      ...(this.minlength && {
        minlength: this.minlength
      }),
      ...(this.maxlength && {
        maxlength: this.maxlength
      }),
      ...(this.placeholder && {
        placeholder: this.placeholder
      }),
      ...(this.rows && {
        rows: this.rows
      }),
      ...(this.enterkeyhintOption && {
        enterkeyhint: this.enterkeyhintOption
      }),
      'aria-invalid': !!this.error,
      required: this.isRequired,
      disabled: this.isDisabled
    };
  }
  componentDidRender() {
    this.textareaId = this.textareaId?.length > 0 ? this.textareaId : (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.U)();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("label", {
      key: '23f2d6dadeaef36871f554132e6c3c69028ecb37'
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-form-label", {
      key: 'abb4ad4159726d60e3d2f6fd9ab151b5299f7288',
      label: this.label,
      helper: this.helper,
      showOptional: !this.isRequired,
      "is-disabled": this.isDisabled
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("textarea", {
      key: '39d04d8ca8244e0c4c6c204222262632f41c6ba5',
      ...this.getAttributes()
    }), !!this.error && (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-validation-message", {
      message: this.error,
      type: "error"
    }));
  }
  static get style() {
    return {
      base: WinkTextareaBaseStyle0,
      telenet: WinkTextareaTelenetStyle0
    };
  }
}, [34, "wink-textarea", {
  "isDisabled": [4, "is-disabled"],
  "isRequired": [4, "is-required"],
  "autocomplete": [1],
  "enterkeyhintOption": [1, "enterkeyhint-option"],
  "textareaId": [1, "textarea-id"],
  "label": [1],
  "helper": [1],
  "name": [1],
  "placeholder": [1],
  "error": [1],
  "minlength": [2],
  "maxlength": [2],
  "rows": [2]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-textarea", "wink-form-label", "wink-icon", "wink-validation-message"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-textarea":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, TextArea);
        }
        break;
      case "wink-form-label":
        if (!customElements.get(tagName)) {
          (0,_form_label_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-validation-message":
        if (!customElements.get(tagName)) {
          (0,_validation_message_js__WEBPACK_IMPORTED_MODULE_4__.d)();
        }
        break;
    }
  });
}
const WinkTextarea = TextArea;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 53312:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-title.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkTitle: () => (/* binding */ WinkTitle),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);

const TITLE_SIZES = {
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6'
};
const TITLE_SPACINGS_Y = {
  default: 'default',
  top: 'top',
  bottom: 'bottom',
  none: 'none'
};
const titleBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:700}:host h1,:host .h1{font-size:56px;line-height:60px;margin-top:4.8rem;margin-bottom:2.4rem}:host h2,:host .h2{font-size:40px;line-height:48px;margin-top:2.4rem;margin-bottom:0.4rem}:host h3,:host .h3{font-size:32px;line-height:40px;margin-top:2.4rem;margin-bottom:0.4rem}:host h4,:host .h4{font-size:24px;line-height:32px;margin-top:2.4rem;margin-bottom:0.4rem}:host h5,:host .h5{font-size:20px;line-height:28px;margin-top:0.4rem;margin-bottom:2.4rem}:host h6,:host .h6{font-size:18px;line-height:28px;margin-top:1.6rem;margin-bottom:0}:host(.spacing-top) *{margin-bottom:0}:host(.spacing-bottom) *{margin-top:0}:host(.spacing-none) *{margin-top:0;margin-bottom:0}";
const WinkTitleBaseStyle0 = titleBaseCss;
const titleTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}:host{font-family:TelenetAlbra-Bold, \"Helvetica Neue\", Helvetica, Arial, sans-serif;font-weight:700}:host h1,:host .h1{font-size:5.6rem;line-height:6rem;margin-top:4.8rem;margin-bottom:2.4rem}:host h2,:host .h2{font-size:4rem;line-height:4.8rem;margin-top:2.4rem;margin-bottom:0.4rem}:host h3,:host .h3{font-size:3.2rem;line-height:4rem;margin-top:2.4rem;margin-bottom:0.4rem}:host h4,:host .h4{font-size:2.4rem;line-height:3.2rem;margin-top:2.4rem;margin-bottom:0.4rem}:host h5,:host .h5{font-size:2rem;line-height:2.8rem;margin-top:2.4rem;margin-bottom:0.4rem}:host h6,:host .h6{font-size:1.8rem;line-height:2.8rem;margin-top:1.6rem;margin-bottom:0}:host(.spacing-top) *{margin-bottom:0}:host(.spacing-bottom) *{margin-top:0}:host(.spacing-none) *{margin-top:0;margin-bottom:0}";
const WinkTitleTelenetStyle0 = titleTelenetCss;
const Title = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.proxyCustomElement)(class Title extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.htmlTag = TITLE_SIZES.h2;
    this.noSeo = false;
    this.text = '';
    this.spacingY = TITLE_SPACINGS_Y.default;
    this._HtmlTag = this.htmlTag;
  }
  componentWillRender() {
    this._HtmlTag = this.noSeo ? 'div' : this.htmlTag;
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.Host, {
      key: 'ad89fd8cc705021f289f820bba893b5fba3b7e30',
      class: this.spacingY !== 'default' ? `spacing-${this.spacingY}` : ''
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_0__.h)(this._HtmlTag, {
      key: '9b43bafd3c9d4b96c56473032137277edf5ccee8',
      class: {
        [this.htmlTag]: this.noSeo
      }
    }, this.text));
  }
  static get style() {
    return {
      base: WinkTitleBaseStyle0,
      telenet: WinkTitleTelenetStyle0
    };
  }
}, [33, "wink-title", {
  "htmlTag": [1, "html-tag"],
  "noSeo": [4, "no-seo"],
  "text": [1],
  "spacingY": [1, "spacing-y"],
  "_HtmlTag": [32]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-title"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-title":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Title);
        }
        break;
    }
  });
}
const WinkTitle = Title;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 55675:
/*!************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-toast.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkToast: () => (/* binding */ WinkToast),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _toast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toast.js */ 82637);

const WinkToast = _toast_js__WEBPACK_IMPORTED_MODULE_0__.T;
const defineCustomElement = _toast_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 33252:
/*!**************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-toaster.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkToaster: () => (/* binding */ WinkToaster),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _toast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toast.js */ 82637);
/* harmony import */ var _animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animation.js */ 8071);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon.js */ 45477);
/* harmony import */ var _link_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./link.js */ 37232);






const toasterBaseCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}wink-toaster{position:fixed;z-index:99999;right:0;bottom:0;width:100%;height:auto;display:block;box-sizing:border-box;display:flex;justify-content:flex-end;flex-direction:column;pointer-events:none;transition:all 200ms ease-in-out;gap:calc(var(--semantic-spacing-3xs) * 1rem)}@media only screen and (min-width: 36em){wink-toaster{align-items:flex-end;gap:calc(var(--semantic-spacing-md) * 1rem);padding:calc(var(--semantic-spacing-md) * 1rem)}}";
const WinkToasterBaseStyle0 = toasterBaseCss;
const toasterTelenetCss = ".sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}wink-toaster{position:fixed;z-index:99999;right:0;bottom:0;width:100%;height:auto;display:block;box-sizing:border-box;display:flex;justify-content:flex-end;flex-direction:column;pointer-events:none;transition:all 200ms ease-in-out;gap:calc(var(--semantic-spacing-3xs) * 1rem)}@media only screen and (min-width: 36em){wink-toaster{align-items:flex-end;gap:calc(var(--semantic-spacing-md) * 1rem);padding:calc(var(--semantic-spacing-md) * 1rem)}}";
const WinkToasterTelenetStyle0 = toasterTelenetCss;
const Toaster = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.proxyCustomElement)(class Toaster extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.toasts = [];
  }
  winkCreateToast(toast) {
    var _this = this;
    return (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* () {
      _this.toasts = [..._this.toasts, toast];
    })();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.Host, {
      key: 'db735387e621d6a7343648cb3ec2fa235b993b87',
      "aria-live": "polite",
      "aria-atomic": "true"
    }, this.toasts.map(toast => (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("wink-toast", {
      appearance: toast.appearance || _toast_js__WEBPACK_IMPORTED_MODULE_1__.a.actionable,
      text: toast.text || '',
      duration: toast.duration || 6000,
      href: toast.href || '#',
      target: toast.target || '_self',
      linkText: toast.linkText || 'link',
      "is-open": true
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_5__.h)("slot", {
      key: '5d2596336bd40af5c4ab0b97b572c9162e034881'
    }));
  }
  static get style() {
    return {
      base: WinkToasterBaseStyle0,
      telenet: WinkToasterTelenetStyle0
    };
  }
}, [36, "wink-toaster", {
  "toasts": [32],
  "winkCreateToast": [64]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-toaster", "wink-animation", "wink-button", "wink-icon", "wink-link", "wink-toast"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-toaster":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, Toaster);
        }
        break;
      case "wink-animation":
        if (!customElements.get(tagName)) {
          (0,_animation_js__WEBPACK_IMPORTED_MODULE_2__.d)();
        }
        break;
      case "wink-button":
        if (!customElements.get(tagName)) {
          (0,_animation_js__WEBPACK_IMPORTED_MODULE_2__.a)();
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_3__.d)();
        }
        break;
      case "wink-link":
        if (!customElements.get(tagName)) {
          (0,_link_js__WEBPACK_IMPORTED_MODULE_4__.d)();
        }
        break;
      case "wink-toast":
        if (!customElements.get(tagName)) {
          (0,_toast_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}
const WinkToaster = Toaster;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 74097:
/*!********************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-toggle-switch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkToggleSwitch: () => (/* binding */ WinkToggleSwitch),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stencil/core/internal/client */ 58082);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ 69900);
/* harmony import */ var _icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icon.js */ 45477);



const TOGGLE_ALIGNMENT = {
  nextTo: 'nextToEachOther',
  spaceBetween: 'spaceBetween'
};
const toggleSwitchBaseCss = ".sr-only.sc-wink-toggle-switch-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-toggle-switch-base{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-toggle-switch-base-h{display:flex;align-items:center}.toggle-switch--spacebetween.sc-wink-toggle-switch-base-h{justify-content:space-between}.sc-wink-toggle-switch-base-h .toggle-switch--label.sc-wink-toggle-switch-base{display:inline-block;font-size:1.6rem;line-height:2.4rem;margin:0 calc(var(--semantic-spacing-xs) * 1rem) 0 0;cursor:pointer;padding:0;height:100%;color:var(--semantic-color-text-default)}.sc-wink-toggle-switch-base-h .toggle-switch--wrapper.sc-wink-toggle-switch-base{position:relative}.sc-wink-toggle-switch-base-h input[type=checkbox].sc-wink-toggle-switch-base{height:0;width:0}.sc-wink-toggle-switch-base-h label.sc-wink-toggle-switch-base{cursor:pointer;text-indent:-999.9rem;width:5.2rem;height:3.2rem;background:var(--semantic-color-background-form-default-default);display:block;border-radius:2rem;position:relative;margin-top:-1.4rem}.sc-wink-toggle-switch-base-h label.sc-wink-toggle-switch-base:before{content:\"\";position:absolute;top:-0.4rem;left:-0.4rem;width:6rem;height:4rem;cursor:pointer}.sc-wink-toggle-switch-base-h label.sc-wink-toggle-switch-base:after{content:\"\";position:absolute;top:0.4rem;left:0.4rem;width:2.4rem;height:2.4rem;background:var(--semantic-color-background-surface-highlight-8);border-radius:9rem;transition:0.3s}.sc-wink-toggle-switch-base-h .toggle-switch--icon.sc-wink-toggle-switch-base:hover~label.sc-wink-toggle-switch-base,.sc-wink-toggle-switch-base-h label.sc-wink-toggle-switch-base:hover{background:var(--semantic-color-background-form-default-hovered)}.sc-wink-toggle-switch-base-h .toggle-switch--icon.sc-wink-toggle-switch-base:hover{cursor:pointer}.sc-wink-toggle-switch-base-h .toggle-switch--icon.sc-wink-toggle-switch-base:hover~label.sc-wink-toggle-switch-base:after,.sc-wink-toggle-switch-base-h label.sc-wink-toggle-switch-base:hover:after{box-shadow:0 0 0 0.8rem var(--semantic-color-background-surface-subtle-hovered)}.sc-wink-toggle-switch-base-h input[type=checkbox].sc-wink-toggle-switch-base:focus~label.sc-wink-toggle-switch-base{outline:0.2rem solid var(--semantic-color-border-focus);outline-offset:0.2rem}.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~label.sc-wink-toggle-switch-base{background:var(--semantic-color-background-form-selected-selected)}.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~.toggle-switch--icon.sc-wink-toggle-switch-base:hover~label.sc-wink-toggle-switch-base,.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~label.sc-wink-toggle-switch-base:hover{background:var(--semantic-color-background-surface-action-hover)}.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~.toggle-switch--icon.sc-wink-toggle-switch-base:hover~label.sc-wink-toggle-switch-base:after,.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~label.sc-wink-toggle-switch-base:after{left:calc(100% - 0.5rem);transform:translateX(-100%)}.sc-wink-toggle-switch-base-h .toggle-switch--icon.sc-wink-toggle-switch-base:active~label.sc-wink-toggle-switch-base:after,.sc-wink-toggle-switch-base-h label.sc-wink-toggle-switch-base:active:after{width:2.6rem}.sc-wink-toggle-switch-base-h .toggle-switch--icon.sc-wink-toggle-switch-base wink-icon.sc-wink-toggle-switch-base{--wink-icon-color:var(--semantic-color-icon-on-action);position:absolute;border-radius:100%;z-index:3;top:0.75rem;transition:0.2s all}.sc-wink-toggle-switch-base-h .toggle-switch--icon.sc-wink-toggle-switch-base wink-icon.sc-wink-toggle-switch-base:nth-child(1){left:0.75rem;opacity:1}.sc-wink-toggle-switch-base-h .toggle-switch--icon.sc-wink-toggle-switch-base wink-icon.sc-wink-toggle-switch-base:nth-child(2){left:0.75rem;opacity:0}.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~.toggle-switch--icon.sc-wink-toggle-switch-base wink-icon.sc-wink-toggle-switch-base{z-index:3;transition:0.2s all}.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~.toggle-switch--icon.sc-wink-toggle-switch-base wink-icon.sc-wink-toggle-switch-base:nth-child(1){opacity:0;left:2.7rem}.sc-wink-toggle-switch-base-h input.sc-wink-toggle-switch-base:checked~.toggle-switch--icon.sc-wink-toggle-switch-base wink-icon.sc-wink-toggle-switch-base:nth-child(2){opacity:1;left:2.7rem}.sc-wink-toggle-switch-base-h input[type=checkbox].sc-wink-toggle-switch-base:disabled,.sc-wink-toggle-switch-base-h input[type=checkbox].sc-wink-toggle-switch-base:disabled~*.sc-wink-toggle-switch-base,.sc-wink-toggle-switch-base-h input[type=checkbox].sc-wink-toggle-switch-base:disabled~label.sc-wink-toggle-switch-base:before,.sc-wink-toggle-switch-base-h .toggle-switch--label--disabled.sc-wink-toggle-switch-base{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}";
const WinkToggleSwitchBaseStyle0 = toggleSwitchBaseCss;
const toggleSwitchTelenetCss = ".sr-only.sc-wink-toggle-switch-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sr-only.sc-wink-toggle-switch-telenet{position:absolute;width:0.1rem;height:0.1rem;padding:0;margin:-0.1rem;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0}.sc-wink-toggle-switch-telenet-h{display:flex;align-items:center}.toggle-switch--spacebetween.sc-wink-toggle-switch-telenet-h{justify-content:space-between}.sc-wink-toggle-switch-telenet-h .toggle-switch--label.sc-wink-toggle-switch-telenet{display:inline-block;font-size:1.6rem;line-height:2.4rem;margin:0 calc(var(--semantic-spacing-xs) * 1rem) 0 0;cursor:pointer;padding:0;height:100%;color:var(--semantic-color-text-default)}.sc-wink-toggle-switch-telenet-h .toggle-switch--wrapper.sc-wink-toggle-switch-telenet{position:relative}.sc-wink-toggle-switch-telenet-h input[type=checkbox].sc-wink-toggle-switch-telenet{height:0;width:0}.sc-wink-toggle-switch-telenet-h label.sc-wink-toggle-switch-telenet{cursor:pointer;text-indent:-999.9rem;width:5.2rem;height:3.2rem;background:var(--semantic-color-background-form-default-default);display:block;border-radius:2rem;position:relative;margin-top:-1.4rem}.sc-wink-toggle-switch-telenet-h label.sc-wink-toggle-switch-telenet:before{content:\"\";position:absolute;top:-0.4rem;left:-0.4rem;width:6rem;height:4rem;cursor:pointer}.sc-wink-toggle-switch-telenet-h label.sc-wink-toggle-switch-telenet:after{content:\"\";position:absolute;top:0.4rem;left:0.4rem;width:2.4rem;height:2.4rem;background:var(--semantic-color-background-surface-highlight-8);border-radius:9rem;transition:0.3s}.sc-wink-toggle-switch-telenet-h .toggle-switch--icon.sc-wink-toggle-switch-telenet:hover~label.sc-wink-toggle-switch-telenet,.sc-wink-toggle-switch-telenet-h label.sc-wink-toggle-switch-telenet:hover{background:var(--semantic-color-background-form-default-hovered)}.sc-wink-toggle-switch-telenet-h .toggle-switch--icon.sc-wink-toggle-switch-telenet:hover{cursor:pointer}.sc-wink-toggle-switch-telenet-h .toggle-switch--icon.sc-wink-toggle-switch-telenet:hover~label.sc-wink-toggle-switch-telenet:after,.sc-wink-toggle-switch-telenet-h label.sc-wink-toggle-switch-telenet:hover:after{box-shadow:0 0 0 0.8rem var(--semantic-color-background-surface-subtle-hovered)}.sc-wink-toggle-switch-telenet-h input[type=checkbox].sc-wink-toggle-switch-telenet:focus~label.sc-wink-toggle-switch-telenet{outline:0.2rem solid var(--semantic-color-border-focus);outline-offset:0.2rem}.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~label.sc-wink-toggle-switch-telenet{background:var(--semantic-color-background-form-selected-selected)}.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~.toggle-switch--icon.sc-wink-toggle-switch-telenet:hover~label.sc-wink-toggle-switch-telenet,.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~label.sc-wink-toggle-switch-telenet:hover{background:var(--semantic-color-background-surface-action-hover)}.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~.toggle-switch--icon.sc-wink-toggle-switch-telenet:hover~label.sc-wink-toggle-switch-telenet:after,.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~label.sc-wink-toggle-switch-telenet:after{left:calc(100% - 0.5rem);transform:translateX(-100%)}.sc-wink-toggle-switch-telenet-h .toggle-switch--icon.sc-wink-toggle-switch-telenet:active~label.sc-wink-toggle-switch-telenet:after,.sc-wink-toggle-switch-telenet-h label.sc-wink-toggle-switch-telenet:active:after{width:2.6rem}.sc-wink-toggle-switch-telenet-h .toggle-switch--icon.sc-wink-toggle-switch-telenet wink-icon.sc-wink-toggle-switch-telenet{--wink-icon-color:var(--semantic-color-icon-on-action);position:absolute;border-radius:100%;z-index:3;top:0.75rem;transition:0.2s all}.sc-wink-toggle-switch-telenet-h .toggle-switch--icon.sc-wink-toggle-switch-telenet wink-icon.sc-wink-toggle-switch-telenet:nth-child(1){left:0.75rem;opacity:1}.sc-wink-toggle-switch-telenet-h .toggle-switch--icon.sc-wink-toggle-switch-telenet wink-icon.sc-wink-toggle-switch-telenet:nth-child(2){left:0.75rem;opacity:0}.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~.toggle-switch--icon.sc-wink-toggle-switch-telenet wink-icon.sc-wink-toggle-switch-telenet{z-index:3;transition:0.2s all}.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~.toggle-switch--icon.sc-wink-toggle-switch-telenet wink-icon.sc-wink-toggle-switch-telenet:nth-child(1){opacity:0;left:2.7rem}.sc-wink-toggle-switch-telenet-h input.sc-wink-toggle-switch-telenet:checked~.toggle-switch--icon.sc-wink-toggle-switch-telenet wink-icon.sc-wink-toggle-switch-telenet:nth-child(2){opacity:1;left:2.7rem}.sc-wink-toggle-switch-telenet-h input[type=checkbox].sc-wink-toggle-switch-telenet:disabled,.sc-wink-toggle-switch-telenet-h input[type=checkbox].sc-wink-toggle-switch-telenet:disabled~*.sc-wink-toggle-switch-telenet,.sc-wink-toggle-switch-telenet-h input[type=checkbox].sc-wink-toggle-switch-telenet:disabled~label.sc-wink-toggle-switch-telenet:before,.sc-wink-toggle-switch-telenet-h .toggle-switch--label--disabled.sc-wink-toggle-switch-telenet{opacity:calc(var(--semantic-opacity-disabled) / 10);cursor:not-allowed}";
const WinkToggleSwitchTelenetStyle0 = toggleSwitchTelenetCss;
const ToggleSwitch = /*@__PURE__*/(0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.proxyCustomElement)(class ToggleSwitch extends _stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.label = '';
    this.toggleSwitchId = '';
    this.toggleSwitchName = '';
    this.alignment = TOGGLE_ALIGNMENT.nextTo;
    this.checked = false;
    this.disabled = false;
  }
  internals;
  get host() {
    return this;
  }
  labelOnClick = _e => {
    this.host?.querySelector('input')?.click();
  };
  handleKeyDown = e => {
    if (e.key === 'Enter') {
      this.host?.querySelector('input')?.click();
    }
  };
  componentDidRender() {
    this.toggleSwitchId = this.toggleSwitchId?.length > 0 ? this.toggleSwitchId : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.U)();
  }
  render() {
    return (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)(_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.Host, {
      key: '8eaea9a526d5fdf88d0092a41a0f2fc4b9eda781',
      class: `toggle-switch--${this.alignment.toLocaleLowerCase()}`
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("p", {
      key: '084c14e951c16357ebc1f0fcb2fecce3165d04f4',
      class: `toggle-switch--label ${this.disabled ? 'toggle-switch--label--disabled' : ''}`,
      onClick: this.labelOnClick
    }, this.label), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: 'd87e7f3b068bd4de018c6a3f0e1d71506b2e2ef1',
      class: "toggle-switch--wrapper"
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("input", {
      key: '1dd4399c93b27989bb9026ef77aafeec24c7ab4f',
      type: "checkbox",
      id: this.toggleSwitchId,
      name: this.toggleSwitchName,
      onKeyDown: this.handleKeyDown,
      checked: this.checked,
      disabled: this.disabled
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("div", {
      key: 'ff20ff19eadf7a72d54ed16e90134ac9a62b1470',
      class: "toggle-switch--icon",
      onClick: this.labelOnClick
    }, (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: '212f45f616c9ad346a34cedea77d5a5eaf231e03',
      icon: "cross-small",
      size: "sm"
    }), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("wink-icon", {
      key: '0d9658f2535b5a93fe3ddab1ec965a8e38be3247',
      icon: "tick-small",
      size: "sm"
    })), (0,_stencil_core_internal_client__WEBPACK_IMPORTED_MODULE_2__.h)("label", {
      key: '6ad1b044f672973f09102beba9055785490ee363',
      htmlFor: this.toggleSwitchId
    })));
  }
  static get style() {
    return {
      base: WinkToggleSwitchBaseStyle0,
      telenet: WinkToggleSwitchTelenetStyle0
    };
  }
}, [34, "wink-toggle-switch", {
  "label": [1],
  "toggleSwitchId": [1, "toggle-switch-id"],
  "toggleSwitchName": [1, "toggle-switch-name"],
  "alignment": [1],
  "checked": [516],
  "disabled": [4]
}]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["wink-toggle-switch", "wink-icon"];
  components.forEach(tagName => {
    switch (tagName) {
      case "wink-toggle-switch":
        if (!customElements.get(tagName)) {
          customElements.define(tagName, ToggleSwitch);
        }
        break;
      case "wink-icon":
        if (!customElements.get(tagName)) {
          (0,_icon_js__WEBPACK_IMPORTED_MODULE_1__.d)();
        }
        break;
    }
  });
}
const WinkToggleSwitch = ToggleSwitch;
const defineCustomElement = defineCustomElement$1;


/***/ }),

/***/ 96292:
/*!*************************************************************************!*\
  !*** ./libs/foundation/wink/dist/components/wink-validation-message.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WinkValidationMessage: () => (/* binding */ WinkValidationMessage),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement)
/* harmony export */ });
/* harmony import */ var _validation_message_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validation-message.js */ 46024);

const WinkValidationMessage = _validation_message_js__WEBPACK_IMPORTED_MODULE_0__.V;
const defineCustomElement = _validation_message_js__WEBPACK_IMPORTED_MODULE_0__.d;


/***/ }),

/***/ 58082:
/*!*************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BUILD: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD),
/* harmony export */   Build: () => (/* binding */ Build),
/* harmony export */   Env: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.Env),
/* harmony export */   Fragment: () => (/* binding */ Fragment),
/* harmony export */   H: () => (/* binding */ H),
/* harmony export */   HTMLElement: () => (/* binding */ H),
/* harmony export */   Host: () => (/* binding */ Host),
/* harmony export */   NAMESPACE: () => (/* reexport safe */ _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.NAMESPACE),
/* harmony export */   STENCIL_DEV_MODE: () => (/* binding */ STENCIL_DEV_MODE),
/* harmony export */   addHostEventListeners: () => (/* binding */ addHostEventListeners),
/* harmony export */   bootstrapLazy: () => (/* binding */ bootstrapLazy),
/* harmony export */   cmpModules: () => (/* binding */ cmpModules),
/* harmony export */   connectedCallback: () => (/* binding */ connectedCallback),
/* harmony export */   consoleDevError: () => (/* binding */ consoleDevError),
/* harmony export */   consoleDevInfo: () => (/* binding */ consoleDevInfo),
/* harmony export */   consoleDevWarn: () => (/* binding */ consoleDevWarn),
/* harmony export */   consoleError: () => (/* binding */ consoleError),
/* harmony export */   createEvent: () => (/* binding */ createEvent),
/* harmony export */   defineCustomElement: () => (/* binding */ defineCustomElement),
/* harmony export */   disconnectedCallback: () => (/* binding */ disconnectedCallback),
/* harmony export */   doc: () => (/* binding */ doc),
/* harmony export */   forceModeUpdate: () => (/* binding */ forceModeUpdate),
/* harmony export */   forceUpdate: () => (/* binding */ forceUpdate),
/* harmony export */   getAssetPath: () => (/* binding */ getAssetPath),
/* harmony export */   getElement: () => (/* binding */ getElement),
/* harmony export */   getHostRef: () => (/* binding */ getHostRef),
/* harmony export */   getMode: () => (/* binding */ getMode),
/* harmony export */   getRenderingRef: () => (/* binding */ getRenderingRef),
/* harmony export */   getValue: () => (/* binding */ getValue),
/* harmony export */   h: () => (/* binding */ h),
/* harmony export */   insertVdomAnnotations: () => (/* binding */ insertVdomAnnotations),
/* harmony export */   isMemberInElement: () => (/* binding */ isMemberInElement),
/* harmony export */   loadModule: () => (/* binding */ loadModule),
/* harmony export */   modeResolutionChain: () => (/* binding */ modeResolutionChain),
/* harmony export */   nextTick: () => (/* binding */ nextTick),
/* harmony export */   parsePropertyValue: () => (/* binding */ parsePropertyValue),
/* harmony export */   plt: () => (/* binding */ plt),
/* harmony export */   postUpdateComponent: () => (/* binding */ postUpdateComponent),
/* harmony export */   promiseResolve: () => (/* binding */ promiseResolve),
/* harmony export */   proxyComponent: () => (/* binding */ proxyComponent),
/* harmony export */   proxyCustomElement: () => (/* binding */ proxyCustomElement),
/* harmony export */   readTask: () => (/* binding */ readTask),
/* harmony export */   registerHost: () => (/* binding */ registerHost),
/* harmony export */   registerInstance: () => (/* binding */ registerInstance),
/* harmony export */   renderVdom: () => (/* binding */ renderVdom),
/* harmony export */   setAssetPath: () => (/* binding */ setAssetPath),
/* harmony export */   setErrorHandler: () => (/* binding */ setErrorHandler),
/* harmony export */   setMode: () => (/* binding */ setMode),
/* harmony export */   setNonce: () => (/* binding */ setNonce),
/* harmony export */   setPlatformHelpers: () => (/* binding */ setPlatformHelpers),
/* harmony export */   setPlatformOptions: () => (/* binding */ setPlatformOptions),
/* harmony export */   setValue: () => (/* binding */ setValue),
/* harmony export */   styles: () => (/* binding */ styles),
/* harmony export */   supportsConstructableStylesheets: () => (/* binding */ supportsConstructableStylesheets),
/* harmony export */   supportsListenerOptions: () => (/* binding */ supportsListenerOptions),
/* harmony export */   supportsShadow: () => (/* binding */ supportsShadow),
/* harmony export */   win: () => (/* binding */ win),
/* harmony export */   writeTask: () => (/* binding */ writeTask)
/* harmony export */ });
/* harmony import */ var _Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js */ 71670);
/* harmony import */ var _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stencil/core/internal/app-data */ 18769);

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
 *
 * Modified for Stencil's renderer and slot projection
 */
let scopeId;
let contentRef;
let hostTagName;
let customError;
let i = 0;
let useNativeShadowDom = false;
let checkSlotFallbackVisibility = false;
let checkSlotRelocate = false;
let isSvgMode = false;
let renderingRef = null;
let queueCongestion = 0;
let queuePending = false;
/*
 Stencil Client Platform v4.12.1 | MIT Licensed | https://stenciljs.com
 */

const Build = {
  isDev: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev ? true : false,
  isBrowser: true,
  isServer: false,
  isTesting: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isTesting ? true : false
};
const getAssetPath = path => {
  const assetUrl = new URL(path, plt.$resourcesUrl$);
  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
const setAssetPath = path => plt.$resourcesUrl$ = path;
const createTime = (fnName, tagName = '') => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.profile && performance.mark) {
    const key = `st:${fnName}:${tagName}:${i++}`;
    // Start
    performance.mark(key);
    // End
    return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);
  } else {
    return () => {
      return;
    };
  }
};
const uniqueTime = (key, measureText) => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.profile && performance.mark) {
    if (performance.getEntriesByName(key, 'mark').length === 0) {
      performance.mark(key);
    }
    return () => {
      if (performance.getEntriesByName(measureText, 'measure').length === 0) {
        performance.measure(measureText, key);
      }
    };
  } else {
    return () => {
      return;
    };
  }
};
const inspect = ref => {
  const hostRef = getHostRef(ref);
  if (!hostRef) {
    return undefined;
  }
  const flags = hostRef.$flags$;
  const hostElement = hostRef.$hostElement$;
  return {
    renderCount: hostRef.$renderCount$,
    flags: {
      hasRendered: !!(flags & 2 /* HOST_FLAGS.hasRendered */),
      hasConnected: !!(flags & 1 /* HOST_FLAGS.hasConnected */),
      isWaitingForChildren: !!(flags & 4 /* HOST_FLAGS.isWaitingForChildren */),
      isConstructingInstance: !!(flags & 8 /* HOST_FLAGS.isConstructingInstance */),
      isQueuedForUpdate: !!(flags & 16 /* HOST_FLAGS.isQueuedForUpdate */),
      hasInitializedComponent: !!(flags & 32 /* HOST_FLAGS.hasInitializedComponent */),
      hasLoadedComponent: !!(flags & 64 /* HOST_FLAGS.hasLoadedComponent */),
      isWatchReady: !!(flags & 128 /* HOST_FLAGS.isWatchReady */),
      isListenReady: !!(flags & 256 /* HOST_FLAGS.isListenReady */),
      needsRerender: !!(flags & 512 /* HOST_FLAGS.needsRerender */)
    },
    instanceValues: hostRef.$instanceValues$,
    ancestorComponent: hostRef.$ancestorComponent$,
    hostElement,
    lazyInstance: hostRef.$lazyInstance$,
    vnode: hostRef.$vnode$,
    modeName: hostRef.$modeName$,
    onReadyPromise: hostRef.$onReadyPromise$,
    onReadyResolve: hostRef.$onReadyResolve$,
    onInstancePromise: hostRef.$onInstancePromise$,
    onInstanceResolve: hostRef.$onInstanceResolve$,
    onRenderResolve: hostRef.$onRenderResolve$,
    queuedListeners: hostRef.$queuedListeners$,
    rmListeners: hostRef.$rmListeners$,
    ['s-id']: hostElement['s-id'],
    ['s-cr']: hostElement['s-cr'],
    ['s-lr']: hostElement['s-lr'],
    ['s-p']: hostElement['s-p'],
    ['s-rc']: hostElement['s-rc'],
    ['s-sc']: hostElement['s-sc']
  };
};
const installDevTools = () => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.devTools) {
    const stencil = win.stencil = win.stencil || {};
    const originalInspect = stencil.inspect;
    stencil.inspect = ref => {
      let result = inspect(ref);
      if (!result && typeof originalInspect === 'function') {
        result = originalInspect(ref);
      }
      return result;
    };
  }
};
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const HYDRATE_ID = 's-id';
const HYDRATED_STYLE_ID = 'sty-id';
const HYDRATE_CHILD_ID = 'c-id';
const HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';
/**
 * Constant for styles to be globally applied to `slot-fb` elements for pseudo-slot behavior.
 *
 * Two cascading rules must be used instead of a `:not()` selector due to Stencil browser
 * support as of Stencil v4.
 */
const SLOT_FB_CSS = 'slot-fb{display:contents}slot-fb[hidden]{display:none}';
const XLINK_NS = 'http://www.w3.org/1999/xlink';
const FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS = ['formAssociatedCallback', 'formResetCallback', 'formDisabledCallback', 'formStateRestoreCallback'];
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
/**
 * Namespaces
 */
const SVG_NS = 'http://www.w3.org/2000/svg';
const HTML_NS = 'http://www.w3.org/1999/xhtml';
const isDef = v => v != null;
/**
 * Check whether a value is a 'complex type', defined here as an object or a
 * function.
 *
 * @param o the value to check
 * @returns whether it's a complex type or not
 */
const isComplexType = o => {
  // https://jsperf.com/typeof-fn-object/5
  o = typeof o;
  return o === 'object' || o === 'function';
};
/**
 * Helper method for querying a `meta` tag that contains a nonce value
 * out of a DOM's head.
 *
 * @param doc The DOM containing the `head` to query against
 * @returns The content of the meta tag representing the nonce value, or `undefined` if no tag
 * exists or the tag has no content.
 */
function queryNonceMetaTagContent(doc) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('content')) !== null && _c !== void 0 ? _c : undefined;
}
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = c => {
    for (let i = 0; i < c.length; i++) {
      child = c[i];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== 'boolean') {
        if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {
          child = String(child);
        } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {
          consoleDevError(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`);
        }
        if (simple && lastSimple) {
          // If the previous child was simple (string), we merge both
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          // Append a new vNode, if it's text, we create a text vNode
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev && nodeName === 'input') {
      validateInputProperties(vnodeData);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomKey && vnodeData.key) {
      key = vnodeData.key;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && vnodeData.name) {
      slotName = vnodeData.name;
    }
    // normalize class / className attributes
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomClass) {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== 'object' ? classData : Object.keys(classData).filter(k => classData[k]).join(' ');
      }
    }
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev && vNodeChildren.some(isHost)) {
    consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomFunctional && typeof nodeName === 'function') {
    // nodeName is a functional component
    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomKey) {
    vnode.$key$ = key;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
    vnode.$name$ = slotName;
  }
  return vnode;
};
/**
 * A utility function for creating a virtual DOM node from a tag and some
 * possible text content.
 *
 * @param tag the tag for this element
 * @param text possible text content for the node
 * @returns a newly-minted virtual DOM node
 */
const newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomAttribute) {
    vnode.$attrs$ = null;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomKey) {
    vnode.$key$ = null;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
    vnode.$name$ = null;
  }
  return vnode;
};
const Host = {};
/**
 * Check whether a given node is a Host node or not
 *
 * @param node the virtual DOM node to check
 * @returns whether it's a Host node or not
 */
const isHost = node => node && node.$tag$ === Host;
/**
 * Implementation of {@link d.FunctionalUtilities} for Stencil's VDom.
 *
 * Note that these functions convert from {@link d.VNode} to
 * {@link d.ChildNode} to give functional component developers a friendly
 * interface.
 */
const vdomFnUtils = {
  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
};
/**
 * Convert a {@link d.VNode} to a {@link d.ChildNode} in order to present a
 * friendlier public interface (hence, 'convertToPublic').
 *
 * @param node the virtual DOM node to convert
 * @returns a converted child node
 */
const convertToPublic = node => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
/**
 * Convert a {@link d.ChildNode} back to an equivalent {@link d.VNode} in
 * order to use the resulting object in the virtual DOM. The initial object was
 * likely created as part of presenting a public API, so converting it back
 * involved making it 'private' again (hence, `convertToPrivate`).
 *
 * @param node the child node to convert
 * @returns a converted virtual DOM node
 */
const convertToPrivate = node => {
  if (typeof node.vtag === 'function') {
    const vnodeData = Object.assign({}, node.vattrs);
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h(node.vtag, vnodeData, ...(node.vchildren || []));
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
/**
 * Validates the ordering of attributes on an input element
 *
 * @param inputElm the element to validate
 */
const validateInputProperties = inputElm => {
  const props = Object.keys(inputElm);
  const value = props.indexOf('value');
  if (value === -1) {
    return;
  }
  const typeIndex = props.indexOf('type');
  const minIndex = props.indexOf('min');
  const maxIndex = props.indexOf('max');
  const stepIndex = props.indexOf('step');
  if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
    consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
  }
};
/**
 * Entrypoint of the client-side hydration process. Facilitates calls to hydrate the
 * document and all its nodes.
 *
 * This process will also reconstruct the shadow root and slot DOM nodes for components using shadow DOM.
 *
 * @param hostElm The element to hydrate.
 * @param tagName The element's tag name.
 * @param hostId The host ID assigned to the element by the server.
 * @param hostRef The host reference for the element.
 */
const initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
  const endHydrate = createTime('hydrateClient', tagName);
  const shadowRoot = hostElm.shadowRoot;
  const childRenderNodes = [];
  const slotNodes = [];
  const shadowRootNodes = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && shadowRoot ? [] : null;
  const vnode = hostRef.$vnode$ = newVNode(tagName, null);
  if (!plt.$orgLocNodes$) {
    initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = new Map());
  }
  hostElm[HYDRATE_ID] = hostId;
  hostElm.removeAttribute(HYDRATE_ID);
  clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
  childRenderNodes.map(c => {
    const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;
    const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
    const node = c.$elm$;
    // Put the node back in its original location since the native Shadow DOM
    // can handle rendering it its correct location now
    if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {
      orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
    }
    if (!shadowRoot) {
      node['s-hn'] = tagName;
      if (orgLocationNode) {
        node['s-ol'] = orgLocationNode;
        node['s-ol']['s-nr'] = node;
      }
    }
    plt.$orgLocNodes$.delete(orgLocationId);
  });
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && shadowRoot) {
    shadowRootNodes.map(shadowRootNode => {
      if (shadowRootNode) {
        shadowRoot.appendChild(shadowRootNode);
      }
    });
  }
  endHydrate();
};
/**
 * Recursively constructs the virtual node tree for a host element and its children.
 * The tree is constructed by parsing the annotations set on the nodes by the server.
 *
 * In addition to constructing the vNode tree, we also track information about the node's
 * descendants like which are slots, which should exist in the shadow root, and which
 * are nodes that should be rendered as children of the parent node.
 *
 * @param parentVNode The vNode representing the parent node.
 * @param childRenderNodes An array of all child nodes in the parent's node tree.
 * @param slotNodes An array of all slot nodes in the parent's node tree.
 * @param shadowRootNodes An array all nodes that should be rendered in the shadow root in the parent's node tree.
 * @param hostElm The parent element.
 * @param node The node to construct the vNode tree for.
 * @param hostId The host ID assigned to the element by the server.
 */
const clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {
  let childNodeType;
  let childIdSplt;
  let childVNode;
  let i;
  if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {
    childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
    if (childNodeType) {
      // got the node data from the element's attribute
      // `${hostId}.${nodeId}.${depth}.${index}`
      childIdSplt = childNodeType.split('.');
      if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {
        childVNode = {
          $flags$: 0,
          $hostId$: childIdSplt[0],
          $nodeId$: childIdSplt[1],
          $depth$: childIdSplt[2],
          $index$: childIdSplt[3],
          $tag$: node.tagName.toLowerCase(),
          $elm$: node,
          $attrs$: null,
          $children$: null,
          $key$: null,
          $name$: null,
          $text$: null
        };
        childRenderNodes.push(childVNode);
        node.removeAttribute(HYDRATE_CHILD_ID);
        // this is a new child vnode
        // so ensure its parent vnode has the vchildren array
        if (!parentVNode.$children$) {
          parentVNode.$children$ = [];
        }
        // add our child vnode to a specific index of the vnode's children
        parentVNode.$children$[childVNode.$index$] = childVNode;
        // this is now the new parent vnode for all the next child checks
        parentVNode = childVNode;
        if (shadowRootNodes && childVNode.$depth$ === '0') {
          shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
        }
      }
    }
    // recursively drill down, end to start so we can remove nodes
    for (i = node.childNodes.length - 1; i >= 0; i--) {
      clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);
    }
    if (node.shadowRoot) {
      // keep drilling down through the shadow root nodes
      for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {
        clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);
      }
    }
  } else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {
    // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`
    childIdSplt = node.nodeValue.split('.');
    if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {
      // comment node for either the host id or a 0 host id
      childNodeType = childIdSplt[0];
      childVNode = {
        $flags$: 0,
        $hostId$: childIdSplt[1],
        $nodeId$: childIdSplt[2],
        $depth$: childIdSplt[3],
        $index$: childIdSplt[4],
        $elm$: node,
        $attrs$: null,
        $children$: null,
        $key$: null,
        $name$: null,
        $tag$: null,
        $text$: null
      };
      if (childNodeType === TEXT_NODE_ID) {
        childVNode.$elm$ = node.nextSibling;
        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* NODE_TYPE.TextNode */) {
          childVNode.$text$ = childVNode.$elm$.textContent;
          childRenderNodes.push(childVNode);
          // remove the text comment since it's no longer needed
          node.remove();
          if (!parentVNode.$children$) {
            parentVNode.$children$ = [];
          }
          parentVNode.$children$[childVNode.$index$] = childVNode;
          if (shadowRootNodes && childVNode.$depth$ === '0') {
            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
          }
        }
      } else if (childVNode.$hostId$ === hostId) {
        // this comment node is specifically for this host id
        if (childNodeType === SLOT_NODE_ID) {
          // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;
          childVNode.$tag$ = 'slot';
          if (childIdSplt[5]) {
            node['s-sn'] = childVNode.$name$ = childIdSplt[5];
          } else {
            node['s-sn'] = '';
          }
          node['s-sr'] = true;
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && shadowRootNodes) {
            // browser support shadowRoot and this is a shadow dom component
            // create an actual slot element
            childVNode.$elm$ = doc.createElement(childVNode.$tag$);
            if (childVNode.$name$) {
              // add the slot name attribute
              childVNode.$elm$.setAttribute('name', childVNode.$name$);
            }
            // insert the new slot element before the slot comment
            node.parentNode.insertBefore(childVNode.$elm$, node);
            // remove the slot comment since it's not needed for shadow
            node.remove();
            if (childVNode.$depth$ === '0') {
              shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
            }
          }
          slotNodes.push(childVNode);
          if (!parentVNode.$children$) {
            parentVNode.$children$ = [];
          }
          parentVNode.$children$[childVNode.$index$] = childVNode;
        } else if (childNodeType === CONTENT_REF_ID) {
          // `${CONTENT_REF_ID}.${hostId}`;
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && shadowRootNodes) {
            // remove the content ref comment since it's not needed for shadow
            node.remove();
          } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
            hostElm['s-cr'] = node;
            node['s-cn'] = true;
          }
        }
      }
    }
  } else if (parentVNode && parentVNode.$tag$ === 'style') {
    const vnode = newVNode(null, node.textContent);
    vnode.$elm$ = node;
    vnode.$index$ = '0';
    parentVNode.$children$ = [vnode];
  }
};
/**
 * Recursively locate any comments representing an original location for a node in a node's
 * children or shadowRoot children.
 *
 * @param node The node to search.
 * @param orgLocNodes A map of the original location annotation and the current node being searched.
 */
const initializeDocumentHydrate = (node, orgLocNodes) => {
  if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {
    let i = 0;
    for (; i < node.childNodes.length; i++) {
      initializeDocumentHydrate(node.childNodes[i], orgLocNodes);
    }
    if (node.shadowRoot) {
      for (i = 0; i < node.shadowRoot.childNodes.length; i++) {
        initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);
      }
    }
  } else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {
    const childIdSplt = node.nodeValue.split('.');
    if (childIdSplt[0] === ORG_LOCATION_ID) {
      orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);
      node.nodeValue = '';
      // useful to know if the original location is
      // the root light-dom of a shadow dom component
      node['s-en'] = childIdSplt[3];
    }
  }
};
// Private
const computeMode = elm => modeResolutionChain.map(h => h(elm)).find(m => !!m);
// Public
const setMode = handler => modeResolutionChain.push(handler);
const getMode = ref => getHostRef(ref).$modeName$;
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */
const parsePropertyValue = (propValue, propType) => {
  // ensure this value is of the correct prop type
  if (propValue != null && !isComplexType(propValue)) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.propBoolean && propType & 4 /* MEMBER_FLAGS.Boolean */) {
      // per the HTML spec, any string value means it is a boolean true value
      // but we'll cheat here and say that the string "false" is the boolean false
      return propValue === 'false' ? false : propValue === '' || !!propValue;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.propNumber && propType & 2 /* MEMBER_FLAGS.Number */) {
      // force it to be a number
      return parseFloat(propValue);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.propString && propType & 1 /* MEMBER_FLAGS.String */) {
      // could have been passed as a number or boolean
      // but we still want it as a string
      return String(propValue);
    }
    // redundant return here for better minification
    return propValue;
  }
  // not sure exactly what type we want
  // so no need to change to a different type
  return propValue;
};
const getElement = ref => _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref;
const createEvent = (ref, name, flags) => {
  const elm = getElement(ref);
  return {
    emit: detail => {
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev && !elm.isConnected) {
        consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
      }
      return emitEvent(elm, name, {
        bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),
        composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),
        cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),
        detail
      });
    }
  };
};
/**
 * Helper function to create & dispatch a custom Event on a provided target
 * @param elm the target of the Event
 * @param name the name to give the custom Event
 * @param opts options for configuring a custom Event
 * @returns the custom Event
 */
const emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
const rootAppliedStyles = /*@__PURE__*/new WeakMap();
const registerStyle = (scopeId, cssText, allowCS) => {
  let style = styles.get(scopeId);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === 'string') {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId = getScopeId(cmpMeta, mode);
  const style = styles.get(scopeId);
  if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.attachStyles) {
    return scopeId;
  }
  // if an element is NOT connected then getRootNode() will return the wrong root node
  // so the fallback is to always use the document for the root node in those cases
  styleContainerNode = styleContainerNode.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? styleContainerNode : doc;
  if (style) {
    if (typeof style === 'string') {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());
      }
      if (!appliedStyles.has(scopeId)) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId}"]`))) {
          // This is only happening on native shadow-dom, do not needs CSS var shim
          styleElm.innerHTML = style;
        } else {
          styleElm = doc.createElement('style');
          styleElm.innerHTML = style;
          // Apply CSP nonce to the style tag if it exists
          const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
          if (nonce != null) {
            styleElm.setAttribute('nonce', nonce);
          }
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hotModuleReplacement) {
            styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
        }
        // Add styles for `slot-fb` elements if we're using slots outside the Shadow DOM
        if (cmpMeta.$flags$ & 4 /* CMP_FLAGS.hasSlotRelocation */) {
          styleElm.innerHTML += SLOT_FB_CSS;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId);
        }
      }
    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId;
};
const attachStyles = hostRef => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
  const scopeId = addStyle(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);
  if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scoped) && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cssAnnotations && flags & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {
    // only required when we're NOT using native shadow dom (slot)
    // or this browser doesn't support native shadow dom
    // and this host element was NOT created with SSR
    // let's pick out the inner content for slot projection
    // create a node to represent where the original
    // content was first placed, which is useful later on
    // DOM WRITE!!
    elm['s-sc'] = scopeId;
    elm.classList.add(scopeId + '-h');
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scoped && flags & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
      elm.classList.add(scopeId + '-s');
    }
  }
  endAttachStyles();
};
const getScopeId = (cmp, mode) => 'sc-' + (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.mode && mode && cmp.$flags$ & 32 /* CMP_FLAGS.hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);
const convertScopedToShadow = css => css.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, '$1{');
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
/**
 * When running a VDom render set properties present on a VDom node onto the
 * corresponding HTML element.
 *
 * Note that this function has special functionality for the `class`,
 * `style`, `key`, and `ref` attributes, as well as event handlers (like
 * `onClick`, etc). All others are just passed through as-is.
 *
 * @param elm the HTMLElement onto which attributes should be set
 * @param memberName the name of the attribute to set
 * @param oldValue the old value for the attribute
 * @param newValue the new value for the attribute
 * @param isSvg whether we're in an svg context or not
 * @param flags bitflags for Vdom variables
 */
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln = memberName.toLowerCase();
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomClass && memberName === 'class') {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter(c => c && !newClasses.includes(c)));
      classList.add(...newClasses.filter(c => c && !oldClasses.includes(c)));
    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomStyle && memberName === 'style') {
      // update style attribute, css properties and values
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable) {
        for (const prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide && prop.includes('-')) {
              elm.style.removeProperty(prop);
            } else {
              elm.style[prop] = '';
            }
          }
        }
      }
      for (const prop in newValue) {
        if (!oldValue || newValue[prop] !== oldValue[prop]) {
          if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide && prop.includes('-')) {
            elm.style.setProperty(prop, newValue[prop]);
          } else {
            elm.style[prop] = newValue[prop];
          }
        }
      }
    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomKey && memberName === 'key') ;else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomRef && memberName === 'ref') {
      // minifier will clean this up
      if (newValue) {
        newValue(elm);
      }
    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomListener && (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === 'o' && memberName[1] === 'n') {
      // Event Handlers
      // so if the member name starts with "on" and the 3rd characters is
      // a capital letter, and it's not already a member on the element,
      // then we're assuming it's an event listener
      if (memberName[2] === '-') {
        // on- prefixed events
        // allows to be explicit about the dom event to listen without any magic
        // under the hood:
        // <my-cmp on-click> // listens for "click"
        // <my-cmp on-Click> // listens for "Click"
        // <my-cmp on-ionChange> // listens for "ionChange"
        // <my-cmp on-EVENTS> // listens for "EVENTS"
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win, ln)) {
        // standard event
        // the JSX attribute could have been "onMouseOver" and the
        // member name "onmouseover" is on the window's prototype
        // so let's add the listener "mouseover", which is all lowercased
        memberName = ln.slice(2);
      } else {
        // custom event
        // the JSX attribute could have been "onMyCustomEvent"
        // so let's trim off the "on" prefix and lowercase the first character
        // and add the listener "myCustomEvent"
        // except for the first character, we keep the event name case
        memberName = ln[2] + memberName.slice(3);
      }
      if (oldValue || newValue) {
        // Need to account for "capture" events.
        // If the event name ends with "Capture", we'll update the name to remove
        // the "Capture" suffix and make sure the event listener is setup to handle the capture event.
        const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
        // Make sure we only replace the last instance of "Capture"
        memberName = memberName.replace(CAPTURE_EVENT_REGEX, '');
        if (oldValue) {
          plt.rel(elm, memberName, oldValue, capture);
        }
        if (newValue) {
          plt.ael(elm, memberName, newValue, capture);
        }
      }
    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomPropOrAttr) {
      // Set property if it exists and it's not a SVG
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes('-')) {
            const n = newValue == null ? '' : newValue;
            // Workaround for Safari, moving the <input> caret when re-assigning the same valued
            if (memberName === 'list') {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n) {
              elm[memberName] = n;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e) {
          /**
           * in case someone tries to set a read-only property, e.g. "namespaceURI", we just ignore it
           */
        }
      }
      /**
       * Need to manually update attribute if:
       * - memberName is not an attribute
       * - if we are rendering the host element in order to reflect attribute
       * - if it's a SVG, since properties might not work in <svg>
       * - if the newValue is null/undefined or 'false'.
       */
      let xlink = false;
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomXlink) {
        if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
          memberName = ln;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === '') {
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomXlink && xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {
        newValue = newValue === true ? '' : newValue;
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomXlink && xlink) {
          elm.setAttributeNS(XLINK_NS, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
const parseClassListRegex = /\s/;
/**
 * Parsed a string of classnames into an array
 * @param value className string, e.g. "foo bar baz"
 * @returns list of classes, e.g. ["foo", "bar", "baz"]
 */
const parseClassList = value => !value ? [] : value.split(parseClassListRegex);
const CAPTURE_EVENT_SUFFIX = 'Capture';
const CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + '$');
const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
  // if the element passed in is a shadow root, which is a document fragment
  // then we want to be adding attrs/props to the shadow root's "host" element
  // if it's not a shadow root, then we add attrs/props to the same element
  const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable) {
    // remove attributes no longer present on the vnode by setting them to undefined
    for (memberName in oldVnodeAttrs) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
      }
    }
  }
  // add new & update changed attributes
  for (memberName in newVnodeAttrs) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
  }
};
/**
 * Create a DOM Node corresponding to one of the children of a given VNode.
 *
 * @param oldParentVNode the parent VNode from the previous render
 * @param newParentVNode the parent VNode from the current render
 * @param childIndex the index of the VNode, in the _new_ parent node's
 * children, for which we will create a new DOM node
 * @param parentElm the parent DOM node which our new node will be a child of
 * @returns the newly created node
 */
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  // tslint:disable-next-line: prefer-const
  const newVNode = newParentVNode.$children$[childIndex];
  let i = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && !useNativeShadowDom) {
    // remember for later we need to check to relocate nodes
    checkSlotRelocate = true;
    if (newVNode.$tag$ === 'slot') {
      if (scopeId) {
        // scoped css needs to add its scoped id to the parent element
        parentElm.classList.add(scopeId + '-s');
      }
      newVNode.$flags$ |= newVNode.$children$ ?
      // slot element has fallback content
      2 /* VNODE_FLAGS.isSlotFallback */ :
      // slot element does not have fallback content
      1 /* VNODE_FLAGS.isSlotReference */;
    }
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev && newVNode.$elm$) {
    consoleDevError(`The JSX ${newVNode.$text$ !== null ? `"${newVNode.$text$}" text` : `"${newVNode.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomText && newVNode.$text$ !== null) {
    // create text node
    elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && newVNode.$flags$ & 1 /* VNODE_FLAGS.isSlotReference */) {
    // create a slot reference node
    elm = newVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');
  } else {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.svg && !isSvgMode) {
      isSvgMode = newVNode.$tag$ === 'svg';
    }
    // create element
    elm = newVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.svg ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */ ? 'slot-fb' : newVNode.$tag$) : doc.createElement(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */ ? 'slot-fb' : newVNode.$tag$);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {
      isSvgMode = false;
    }
    // add css classes, attrs, props, listeners, etc.
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomAttribute) {
      updateElement(null, newVNode, isSvgMode);
    }
    if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {
      // if there is a scopeId and this is the initial render
      // then let's add the scopeId as a css class
      elm.classList.add(elm['s-si'] = scopeId);
    }
    if (newVNode.$children$) {
      for (i = 0; i < newVNode.$children$.length; ++i) {
        // create the node
        childNode = createElm(oldParentVNode, newVNode, i, elm);
        // return node could have been null
        if (childNode) {
          // append our new node
          elm.appendChild(childNode);
        }
      }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.svg) {
      if (newVNode.$tag$ === 'svg') {
        // Only reset the SVG context when we're exiting <svg> element
        isSvgMode = false;
      } else if (elm.tagName === 'foreignObject') {
        // Reenter SVG context when we're exiting <foreignObject> element
        isSvgMode = true;
      }
    }
  }
  // This needs to always happen so we can hide nodes that are projected
  // to another component but don't end up in a slot
  elm['s-hn'] = hostTagName;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
    if (newVNode.$flags$ & (2 /* VNODE_FLAGS.isSlotFallback */ | 1 /* VNODE_FLAGS.isSlotReference */)) {
      // remember the content reference comment
      elm['s-sr'] = true;
      // remember the content reference comment
      elm['s-cr'] = contentRef;
      // remember the slot name, or empty string for default slot
      elm['s-sn'] = newVNode.$name$ || '';
      // check if we've got an old vnode for this slot
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalSlotFixes) {
          // we've got an old slot vnode and the wrapper is being replaced
          // so let's move the old slot content to the root of the element currently being rendered
          relocateToHostRoot(oldParentVNode.$elm$);
        } else {
          // we've got an old slot vnode and the wrapper is being replaced
          // so let's move the old slot content back to its original location
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
  }
  return elm;
};
/**
 * Relocates all child nodes of an element that were a part of a previous slot relocation
 * to the root of the Stencil component currently being rendered. This happens when a parent
 * element of a slot reference node dynamically changes and triggers a re-render. We cannot use
 * `putBackInOriginalLocation()` because that may relocate nodes to elements that will not be re-rendered
 * and so they will not be relocated again.
 *
 * @param parentElm The element potentially containing relocated nodes.
 */
const relocateToHostRoot = parentElm => {
  plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
  const host = parentElm.closest(hostTagName.toLowerCase());
  if (host != null) {
    const contentRefNode = Array.from(host.childNodes).find(ref => ref['s-cr']);
    const childNodeArray = Array.from(parentElm.childNodes);
    // If we have a content ref, we need to invert the order of the nodes we're relocating
    // to preserve the correct order of elements in the DOM on future relocations
    for (const childNode of contentRefNode ? childNodeArray.reverse() : childNodeArray) {
      // Only relocate nodes that were slotted in
      if (childNode['s-sh'] != null) {
        host.insertBefore(childNode, contentRefNode !== null && contentRefNode !== void 0 ? contentRefNode : null);
        // Reset so we can correctly move the node around again.
        childNode['s-sh'] = undefined;
        // Need to tell the render pipeline to check to relocate slot content again
        checkSlotRelocate = true;
      }
    }
  }
  plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
};
const putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
  const oldSlotChildNodes = parentElm.childNodes;
  for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
    const childNode = oldSlotChildNodes[i];
    if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
      // and relocate it back to it's original location
      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
      // remove the old original location comment entirely
      // later on the patch function will know what to do
      // and move this to the correct spot if need be
      childNode['s-ol'].remove();
      childNode['s-ol'] = undefined;
      // Reset so we can correctly move the node around again.
      childNode['s-sh'] = undefined;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
};
/**
 * Create DOM nodes corresponding to a list of {@link d.Vnode} objects and
 * add them to the DOM in the appropriate place.
 *
 * @param parentElm the DOM node which should be used as a parent for the new
 * DOM nodes
 * @param before a child of the `parentElm` which the new children should be
 * inserted before (optional)
 * @param parentVNode the parent virtual DOM node
 * @param vnodes the new child virtual DOM nodes to produce DOM nodes for
 * @param startIdx the index in the child virtual DOM nodes at which to start
 * creating DOM nodes (inclusive)
 * @param endIdx the index in the child virtual DOM nodes at which to stop
 * creating DOM nodes (inclusive)
 */
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode || parentElm;
  let childNode;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation ? referenceNode(before) : before);
      }
    }
  }
};
/**
 * Remove the DOM elements corresponding to a list of {@link d.VNode} objects.
 * This can be used to, for instance, clean up after a list of children which
 * should no longer be shown.
 *
 * This function also handles some of Stencil's slot relocation logic.
 *
 * @param vnodes a list of virtual DOM nodes to remove
 * @param startIdx the index at which to start removing nodes (inclusive)
 * @param endIdx the index at which to stop removing nodes (inclusive)
 */
const removeVnodes = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
          // we're removing this element
          // so it's possible we need to show slot fallback content now
          checkSlotFallbackVisibility = true;
          if (elm['s-ol']) {
            // remove the original location comment
            elm['s-ol'].remove();
          } else {
            // it's possible that child nodes of the node
            // that's being removed are slot nodes
            putBackInOriginalLocation(elm, true);
          }
        }
        // remove the vnode's element from the dom
        elm.remove();
      }
    }
  }
};
/**
 * Reconcile the children of a new VNode with the children of an old VNode by
 * traversing the two collections of children, identifying nodes that are
 * conserved or changed, calling out to `patch` to make any necessary
 * updates to the DOM, and rearranging DOM nodes as needed.
 *
 * The algorithm for reconciling children works by analyzing two 'windows' onto
 * the two arrays of children (`oldCh` and `newCh`). We keep track of the
 * 'windows' by storing start and end indices and references to the
 * corresponding array entries. Initially the two 'windows' are basically equal
 * to the entire array, but we progressively narrow the windows until there are
 * no children left to update by doing the following:
 *
 * 1. Skip any `null` entries at the beginning or end of the two arrays, so
 *    that if we have an initial array like the following we'll end up dealing
 *    only with a window bounded by the highlighted elements:
 *
 *    [null, null, VNode1 , ... , VNode2, null, null]
 *                 ^^^^^^         ^^^^^^
 *
 * 2. Check to see if the elements at the head and tail positions are equal
 *    across the windows. This will basically detect elements which haven't
 *    been added, removed, or changed position, i.e. if you had the following
 *    VNode elements (represented as HTML):
 *
 *    oldVNode: `<div><p><span>HEY</span></p></div>`
 *    newVNode: `<div><p><span>THERE</span></p></div>`
 *
 *    Then when comparing the children of the `<div>` tag we check the equality
 *    of the VNodes corresponding to the `<p>` tags and, since they are the
 *    same tag in the same position, we'd be able to avoid completely
 *    re-rendering the subtree under them with a new DOM element and would just
 *    call out to `patch` to handle reconciling their children and so on.
 *
 * 3. Check, for both windows, to see if the element at the beginning of the
 *    window corresponds to the element at the end of the other window. This is
 *    a heuristic which will let us identify _some_ situations in which
 *    elements have changed position, for instance it _should_ detect that the
 *    children nodes themselves have not changed but merely moved in the
 *    following example:
 *
 *    oldVNode: `<div><element-one /><element-two /></div>`
 *    newVNode: `<div><element-two /><element-one /></div>`
 *
 *    If we find cases like this then we also need to move the concrete DOM
 *    elements corresponding to the moved children to write the re-order to the
 *    DOM.
 *
 * 4. Finally, if VNodes have the `key` attribute set on them we check for any
 *    nodes in the old children which have the same key as the first element in
 *    our window on the new children. If we find such a node we handle calling
 *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
 *    what we find.
 *
 * Finally, once we've narrowed our 'windows' to the point that either of them
 * collapse (i.e. they have length 0) we then handle any remaining VNode
 * insertion or deletion that needs to happen to get a DOM state that correctly
 * reflects the new child VNodes. If, for instance, after our window on the old
 * children has collapsed we still have more nodes on the new children that
 * we haven't dealt with yet then we need to add them, or if the new children
 * collapse but we still have unhandled _old_ children then we need to make
 * sure the corresponding DOM nodes are removed.
 *
 * @param parentElm the node into which the parent VNode is rendered
 * @param oldCh the old children of the parent node
 * @param newVNode the new VNode which will replace the parent
 * @param newCh the new children of the parent node
 * @param isInitialRender whether or not this is the first render of the vdom
 */
const updateChildren = (parentElm, oldCh, newVNode, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      // VNode might have been moved left
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
      // if the start nodes are the same then we should patch the new VNode
      // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
      // indices to reflect that. We don't need to move any DOM Nodes around
      // since things are matched up in order.
      patch(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
      // likewise, if the end nodes are the same we patch new onto old and
      // decrement our end indices, and also likewise in this case we don't
      // need to move any DOM Nodes.
      patch(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
      // case: "Vnode moved right"
      //
      // We've found that the last node in our window on the new children is
      // the same VNode as the _first_ node in our window on the old children
      // we're dealing with now. Visually, this is the layout of these two
      // nodes:
      //
      // newCh: [..., newStartVnode , ... , newEndVnode , ...]
      //                                    ^^^^^^^^^^^
      // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
      //              ^^^^^^^^^^^^^
      //
      // In this situation we need to patch `newEndVnode` onto `oldStartVnode`
      // and move the DOM element for `oldStartVnode`.
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode, isInitialRender);
      // We need to move the element for `oldStartVnode` into a position which
      // will be appropriate for `newEndVnode`. For this we can use
      // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
      // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
      // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
      //
      // <old-start-node />
      // <some-intervening-node />
      // <old-end-node />
      // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
      // <next-sibling />
      //
      // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
      // the node for `oldStartVnode` at the end of the children of
      // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
      // aren't any siblings, and passing `null` to `Node.insertBefore` will
      // append it to the children of the parent element.
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
      // case: "Vnode moved left"
      //
      // We've found that the first node in our window on the new children is
      // the same VNode as the _last_ node in our window on the old children.
      // Visually, this is the layout of these two nodes:
      //
      // newCh: [..., newStartVnode , ... , newEndVnode , ...]
      //              ^^^^^^^^^^^^^
      // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
      //                                    ^^^^^^^^^^^
      //
      // In this situation we need to patch `newStartVnode` onto `oldEndVnode`
      // (which will handle updating any changed attributes, reconciling their
      // children etc) but we also need to move the DOM node to which
      // `oldEndVnode` corresponds.
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode, isInitialRender);
      // We've already checked above if `oldStartVnode` and `newStartVnode` are
      // the same node, so since we're here we know that they are not. Thus we
      // can move the element for `oldEndVnode` _before_ the element for
      // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
      // future.
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      // Here we do some checks to match up old and new nodes based on the
      // `$key$` attribute, which is set by putting a `key="my-key"` attribute
      // in the JSX for a DOM element in the implementation of a Stencil
      // component.
      //
      // First we check to see if there are any nodes in the array of old
      // children which have the same key as the first node in the new
      // children.
      idxInOld = -1;
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomKey) {
        for (i = oldStartIdx; i <= oldEndIdx; ++i) {
          if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
            idxInOld = i;
            break;
          }
        }
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomKey && idxInOld >= 0) {
        // We found a node in the old children which matches up with the first
        // node in the new children! So let's deal with that
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          // the tag doesn't match so we'll need a new DOM element
          node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
        } else {
          patch(elmToMove, newStartVnode, isInitialRender);
          // invalidate the matching old node so that we won't try to update it
          // again later on
          oldCh[idxInOld] = undefined;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        // We either didn't find an element in the old children that matches
        // the key of the first new child OR the build is not using `key`
        // attributes at all. In either case we need to create a new element
        // for the new node.
        node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        // if we created a new node then handle inserting it to the DOM
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
        } else {
          oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    // we have some more new nodes to add which don't match up with old nodes
    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable && newStartIdx > newEndIdx) {
    // there are nodes in the `oldCh` array which no longer correspond to nodes
    // in the new array, so lets remove them (which entails cleaning up the
    // relevant DOM nodes)
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
/**
 * Compare two VNodes to determine if they are the same
 *
 * **NB**: This function is an equality _heuristic_ based on the available
 * information set on the two VNodes and can be misleading under certain
 * circumstances. In particular, if the two nodes do not have `key` attrs
 * (available under `$key$` on VNodes) then the function falls back on merely
 * checking that they have the same tag.
 *
 * So, in other words, if `key` attrs are not set on VNodes which may be
 * changing order within a `children` array or something along those lines then
 * we could obtain a false negative and then have to do needless re-rendering
 * (i.e. we'd say two VNodes aren't equal when in fact they should be).
 *
 * @param leftVNode the first VNode to check
 * @param rightVNode the second VNode to check
 * @param isInitialRender whether or not this is the first render of the vdom
 * @returns whether they're equal or not
 */
const isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
  // compare if two vnode to see if they're "technically" the same
  // need to have the same element tag, and same key to be the same
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && leftVNode.$tag$ === 'slot') {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    // this will be set if JSX tags in the build have `key` attrs set on them
    // we only want to check this if we're not on the first render since on
    // first render `leftVNode.$key$` will always be `null`, so we can be led
    // astray and, for instance, accidentally delete a DOM node that we want to
    // keep around.
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomKey && !isInitialRender) {
      return leftVNode.$key$ === rightVNode.$key$;
    }
    return true;
  }
  return false;
};
const referenceNode = node => {
  // this node was relocated to a new location in the dom
  // because of some other component's slot
  // but we still have an html comment in place of where
  // it's original location was according to it's original vdom
  return node && node['s-ol'] || node;
};
const parentReferenceNode = node => (node['s-ol'] ? node['s-ol'] : node).parentNode;
/**
 * Handle reconciling an outdated VNode with a new one which corresponds to
 * it. This function handles flushing updates to the DOM and reconciling the
 * children of the two nodes (if any).
 *
 * @param oldVNode an old VNode whose DOM element and children we want to update
 * @param newVNode a new VNode representing an updated version of the old one
 * @param isInitialRender whether or not this is the first render of the vdom
 */
const patch = (oldVNode, newVNode, isInitialRender = false) => {
  const elm = newVNode.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode.$children$;
  const tag = newVNode.$tag$;
  const text = newVNode.$text$;
  let defaultHolder;
  if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomText || text === null) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.svg) {
      // test if we're rendering an svg element, or still rendering nodes inside of one
      // only add this to the when the compiler sees we're using an svg somewhere
      isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomAttribute || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.reflect) {
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slot && tag === 'slot' && !useNativeShadowDom) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalSlotFixes && oldVNode.$name$ !== newVNode.$name$) {
          newVNode.$elm$['s-sn'] = newVNode.$name$ || '';
          relocateToHostRoot(newVNode.$elm$.parentElement);
        }
      } else {
        // either this is the first render of an element OR it's an update
        // AND we already know it's possible it could have changed
        // this updates the element's css classes, attrs, props, listeners, etc.
        updateElement(oldVNode, newVNode, isSvgMode);
      }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable && oldChildren !== null && newChildren !== null) {
      // looks like there's child vnodes for both the old and new vnodes
      // so we need to call `updateChildren` to reconcile them
      updateChildren(elm, oldChildren, newVNode, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      // no old child vnodes, but there are new child vnodes to add
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomText && oldVNode.$text$ !== null) {
        // the old vnode was text, so be sure to clear it out
        elm.textContent = '';
      }
      // add the new vnode children
      addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
    } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable && oldChildren !== null) {
      // no new child vnodes, but there are old child vnodes to remove
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.svg && isSvgMode && tag === 'svg') {
      isSvgMode = false;
    }
  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomText && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {
    // this element has slotted content
    defaultHolder.parentNode.textContent = text;
  } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomText && oldVNode.$text$ !== text) {
    // update the text content for the text only vnode
    // and also only if the text is different than before
    elm.data = text;
  }
};
/**
 * Adjust the `.hidden` property as-needed on any nodes in a DOM subtree which
 * are slot fallbacks nodes.
 *
 * A slot fallback node should be visible by default. Then, it should be
 * conditionally hidden if:
 *
 * - it has a sibling with a `slot` property set to its slot name or if
 * - it is a default fallback slot node, in which case we hide if it has any
 *   content
 *
 * @param elm the element of interest
 */
const updateFallbackSlotVisibility = elm => {
  const childNodes = elm.childNodes;
  for (const childNode of childNodes) {
    if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
      if (childNode['s-sr']) {
        // this is a slot fallback node
        // get the slot name for this slot reference node
        const slotName = childNode['s-sn'];
        // by default always show a fallback slot node
        // then hide it if there are other slots in the light dom
        childNode.hidden = false;
        // we need to check all of its sibling nodes in order to see if
        // `childNode` should be hidden
        for (const siblingNode of childNodes) {
          // Don't check the node against itself
          if (siblingNode !== childNode) {
            if (siblingNode['s-hn'] !== childNode['s-hn'] || slotName !== '') {
              // this sibling node is from a different component OR is a named
              // fallback slot node
              if (siblingNode.nodeType === 1 /* NODE_TYPE.ElementNode */ && (slotName === siblingNode.getAttribute('slot') || slotName === siblingNode['s-sn'])) {
                childNode.hidden = true;
                break;
              }
            } else {
              // this is a default fallback slot node
              // any element or text node (with content)
              // should hide the default fallback slot node
              if (siblingNode.nodeType === 1 /* NODE_TYPE.ElementNode */ || siblingNode.nodeType === 3 /* NODE_TYPE.TextNode */ && siblingNode.textContent.trim() !== '') {
                childNode.hidden = true;
                break;
              }
            }
          }
        }
      }
      // keep drilling down
      updateFallbackSlotVisibility(childNode);
    }
  }
};
/**
 * Component-global information about nodes which are either currently being
 * relocated or will be shortly.
 */
const relocateNodes = [];
/**
 * Mark the contents of a slot for relocation via adding references to them to
 * the {@link relocateNodes} data structure. The actual work of relocating them
 * will then be handled in {@link renderVdom}.
 *
 * @param elm a render node whose child nodes need to be relocated
 */
const markSlotContentForRelocation = elm => {
  // tslint:disable-next-line: prefer-const
  let node;
  let hostContentNodes;
  let j;
  for (const childNode of elm.childNodes) {
    // we need to find child nodes which are slot references so we can then try
    // to match them up with nodes that need to be relocated
    if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {
      // first get the content reference comment node ('s-cr'), then we get
      // its parent, which is where all the host content is now
      hostContentNodes = node.parentNode.childNodes;
      const slotName = childNode['s-sn'];
      // iterate through all the nodes under the location where the host was
      // originally rendered
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        // check that the node is not a content reference node or a node
        // reference and then check that the host name does not match that of
        // childNode.
        // In addition, check that the slot either has not already been relocated, or
        // that its current location's host is not childNode's host. This is essentially
        // a check so that we don't try to relocate (and then hide) a node that is already
        // where it should be.
        if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn'] && (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalSlotFixes || !node['s-sh'] || node['s-sh'] !== childNode['s-hn'])) {
          // if `node` is located in the slot that `childNode` refers to (via the
          // `'s-sn'` property) then we need to relocate it from it's current spot
          // (under the host element parent) to the right slot location
          if (isNodeLocatedInSlot(node, slotName)) {
            // it's possible we've already decided to relocate this node
            let relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);
            // made some changes to slots
            // let's make sure we also double check
            // fallbacks are correctly hidden or shown
            checkSlotFallbackVisibility = true;
            // ensure that the slot-name attr is correct
            node['s-sn'] = node['s-sn'] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$['s-sh'] = childNode['s-hn'];
              // we marked this node for relocation previously but didn't find
              // out the slot reference node to which it needs to be relocated
              // so write it down now!
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node['s-sh'] = childNode['s-hn'];
              // add to our list of nodes to relocate
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node['s-sr']) {
              relocateNodes.map(relocateNode => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {
                  relocateNodeData = relocateNodes.find(r => r.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some(r => r.$nodeToRelocate$ === node)) {
            // the node is not found within the slot (`childNode`) that we're
            // currently looking at, so we stick it into `relocateNodes` to
            // handle later. If we never find a home for this element then
            // we'll need to hide it
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    // if we're dealing with any type of element (capable of itself being a
    // slot reference or containing one) then we recur
    if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
      markSlotContentForRelocation(childNode);
    }
  }
};
/**
 * Check whether a node is located in a given named slot.
 *
 * @param nodeToRelocate the node of interest
 * @param slotName the slot name to check
 * @returns whether the node is located in the slot or not
 */
const isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
    if (nodeToRelocate.getAttribute('slot') === null && slotName === '') {
      // if the node doesn't have a slot attribute, and the slot we're checking
      // is not a named slot, then we assume the node should be within the slot
      return true;
    }
    if (nodeToRelocate.getAttribute('slot') === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate['s-sn'] === slotName) {
    return true;
  }
  return slotName === '';
};
/**
 * 'Nullify' any VDom `ref` callbacks on a VDom node or its children by calling
 * them with `null`. This signals that the DOM element corresponding to the VDom
 * node has been removed from the DOM.
 *
 * @param vNode a virtual DOM node
 */
const nullifyVNodeRefs = vNode => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomRef) {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
/**
 * The main entry point for Stencil's virtual DOM-based rendering engine
 *
 * Given a {@link d.HostRef} container and some virtual DOM nodes, this
 * function will handle creating a virtual DOM tree with a single root, patching
 * the current virtual DOM tree onto an old one (if any), dealing with slot
 * relocation, and reflecting attributes.
 *
 * @param hostRef data needed to root and render the virtual DOM tree, such as
 * the DOM node into which it should be rendered.
 * @param renderFnResults the virtual DOM nodes to be rendered
 * @param isInitialLoad whether or not this is the first call after page load
 */
const renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d, _e;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  // if `renderFnResults` is a Host node then we can use it directly. If not,
  // we need to call `h` again to wrap the children of our component in a
  // 'dummy' Host node (well, an empty vnode) since `renderVdom` assumes
  // implicitly that the top-level vdom node is 1) an only child and 2)
  // contains attrs that need to be set on the host element.
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  // <Host> runtime check
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {
    throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.reflect && cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
  }
  // On the first render and *only* on the first render we want to check for
  // any attributes set on the host element which are also set on the vdom
  // node. If we find them, we override the value on the VDom node attrs with
  // the value from the host element, which allows developers building apps
  // with Stencil components to override e.g. the `role` attribute on a
  // component even if it's already set on the `Host`.
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      // We have a special implementation in `setAccessor` for `style` and
      // `class` which reconciles values coming from the VDom with values
      // already present on the DOM element, so we don't want to override those
      // attributes on the VDom tree with values from the host element if they
      // are present.
      //
      // Likewise, `ref` and `key` are special internal values for the Stencil
      // runtime and we don't want to override those either.
      if (hostElm.hasAttribute(key) && !['key', 'ref', 'style', 'class'].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scoped || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom) {
    scopeId = hostElm['s-sc'];
  }
  useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
    contentRef = hostElm['s-cr'];
    // always reset
    checkSlotFallbackVisibility = false;
  }
  // synchronous patch
  patch(oldVNode, rootVnode, isInitialLoad);
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation) {
    // while we're moving nodes around existing nodes, temporarily disable
    // the disconnectCallback from working
    plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
    if (checkSlotRelocate) {
      markSlotContentForRelocation(rootVnode.$elm$);
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate['s-ol']) {
          // add a reference node marking this node's original location
          // keep a reference to this node for later lookups
          const orgLocationNode = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDebug || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode('');
          orgLocationNode['s-nr'] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate['s-ol'] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          // When determining where to insert content, the most simple case would be
          // to relocate the node immediately following the slot reference node. We do this
          // by getting a reference to the node immediately following the slot reference node
          // since we will use `insertBefore` to manipulate the DOM.
          //
          // If there is no node immediately following the slot reference node, then we will just
          // end up appending the node as the last child of the parent.
          let insertBeforeNode = slotRefNode.nextSibling;
          // If the node we're currently planning on inserting the new node before is an element,
          // we need to do some additional checks to make sure we're inserting the node in the correct order.
          // The use case here would be that we have multiple nodes being relocated to the same slot. So, we want
          // to make sure they get inserted into their new how in the same order they were declared in their original location.
          //
          // TODO(STENCIL-914): Remove `experimentalSlotFixes` check
          if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalSlotFixes || insertBeforeNode && insertBeforeNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            let orgLocationNode = (_a = nodeToRelocate['s-ol']) === null || _a === void 0 ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode['s-nr']) !== null && _b !== void 0 ? _b : null;
              if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;
                if (!refNode || !refNode['s-nr']) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            // we've checked that it's worth while to relocate
            // since that the node to relocate
            // has a different next sibling or parent relocated
            if (nodeToRelocate !== insertBeforeNode) {
              if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalSlotFixes && !nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {
                // probably a component in the index.html that doesn't have its hostname set
                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;
              }
              // Add it back to the dom but in its new home
              // If we get to this point and `insertBeforeNode` is `null`, that means
              // we're just going to append the node as the last child of the parent. Passing
              // `null` as the second arg here will trigger that behavior.
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
              // Reset the `hidden` value back to what it was defined as originally
              // This solves a problem where a `slot` is dynamically rendered and `hidden` may have
              // been set on content originally, but now it has a slot to go to so it should have
              // the value it was defined as having in the DOM, not what we overrode it to.
              if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
                nodeToRelocate.hidden = (_c = nodeToRelocate['s-ih']) !== null && _c !== void 0 ? _c : false;
              }
            }
          }
        } else {
          // this node doesn't have a slot home to go to, so let's hide it
          if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            // Store the initial value of `hidden` so we can reset it later when
            // moving nodes around.
            if (isInitialLoad) {
              nodeToRelocate['s-ih'] = (_d = nodeToRelocate.hidden) !== null && _d !== void 0 ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    // done moving nodes around
    // allow the disconnect callback to work again
    plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;
    // always reset
    relocateNodes.length = 0;
  }
  // Hide any elements that were projected through, but don't have a slot to go to.
  // Only an issue if there were no "slots" rendered. Otherwise, nodes are hidden correctly.
  // This _only_ happens for `scoped` components!
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalScopedSlotChanges && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
    for (const childNode of rootVnode.$elm$.childNodes) {
      if (childNode['s-hn'] !== hostTagName && !childNode['s-sh']) {
        // Store the initial value of `hidden` so we can reset it later when
        // moving nodes around.
        if (isInitialLoad && childNode['s-ih'] == null) {
          childNode['s-ih'] = (_e = childNode.hidden) !== null && _e !== void 0 ? _e : false;
        }
        childNode.hidden = true;
      }
    }
  }
  // Clear the content ref so we don't create a memory leak
  contentRef = undefined;
};
// slot comment debug nodes only created with the `--debug` flag
// otherwise these nodes are text nodes w/out content
const slotReferenceDebugNode = slotVNode => doc.createComment(`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ''}> (host=${hostTagName.toLowerCase()})`);
const originalLocationDebugNode = nodeToRelocate => doc.createComment(`org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})` : `[${nodeToRelocate.textContent}]`));
const attachToAncestor = (hostRef, ancestorComponent) => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
    ancestorComponent['s-p'].push(new Promise(r => hostRef.$onRenderResolve$ = r));
  }
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.taskQueue && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable) {
    hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading && hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
    hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;
    return;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  // there is no ancestor component or the ancestor component
  // has already fired off its lifecycle update then
  // fire off the initial update
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
/**
 * Dispatch initial-render and update lifecycle hooks, enqueuing calls to
 * component lifecycle methods like `componentWillLoad` as well as
 * {@link updateComponent}, which will kick off the virtual DOM re-render.
 *
 * @param hostRef a reference to a host DOM node
 * @param isInitialLoad whether we're on the initial load or not
 * @returns an empty Promise which is used to enqueue a series of operations for
 * the component
 */
const dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
  const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
  // We're going to use this variable together with `enqueue` to implement a
  // little promise-based queue. We start out with it `undefined`. When we add
  // the first function to the queue we'll set this variable to be that
  // function's return value. When we attempt to add subsequent values to the
  // queue we'll check that value and, if it was a `Promise`, we'll then chain
  // the new function off of that `Promise` using `.then()`. This will give our
  // queue two nice properties:
  //
  // 1. If all functions added to the queue are synchronous they'll be called
  //    synchronously right away.
  // 2. If all functions added to the queue are asynchronous they'll all be
  //    called in order after `dispatchHooks` exits.
  let maybePromise;
  if (isInitialLoad) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListener) {
      hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;
      if (hostRef.$queuedListeners$) {
        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
        hostRef.$queuedListeners$ = undefined;
      }
    }
    emitLifecycleEvent(elm, 'componentWillLoad');
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpWillLoad) {
      // If `componentWillLoad` returns a `Promise` then we want to wait on
      // whatever's going on in that `Promise` before we launch into
      // rendering the component, doing other lifecycle stuff, etc. So
      // in that case we assign the returned promise to the variable we
      // declared above to hold a possible 'queueing' Promise
      maybePromise = safeCall(instance, 'componentWillLoad');
    }
  } else {
    emitLifecycleEvent(elm, 'componentWillUpdate');
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpWillUpdate) {
      // Like `componentWillLoad` above, we allow Stencil component
      // authors to return a `Promise` from this lifecycle callback, and
      // we specify that our runtime will wait for that `Promise` to
      // resolve before the component re-renders. So if the method
      // returns a `Promise` we need to keep it around!
      maybePromise = safeCall(instance, 'componentWillUpdate');
    }
  }
  emitLifecycleEvent(elm, 'componentWillRender');
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpWillRender) {
    maybePromise = enqueue(maybePromise, () => safeCall(instance, 'componentWillRender'));
  }
  endSchedule();
  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
};
/**
 * This function uses a Promise to implement a simple first-in, first-out queue
 * of functions to be called.
 *
 * The queue is ordered on the basis of the first argument. If it's
 * `undefined`, then nothing is on the queue yet, so the provided function can
 * be called synchronously (although note that this function may return a
 * `Promise`). The idea is that then the return value of that enqueueing
 * operation is kept around, so that if it was a `Promise` then subsequent
 * functions can be enqueued by calling this function again with that `Promise`
 * as the first argument.
 *
 * @param maybePromise either a `Promise` which should resolve before the next function is called or an 'empty' sentinel
 * @param fn a function to enqueue
 * @returns either a `Promise` or the return value of the provided function
 */
const enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();
/**
 * Check that a value is a `Promise`. To check, we first see if the value is an
 * instance of the `Promise` global. In a few circumstances, in particular if
 * the global has been overwritten, this is could be misleading, so we also do
 * a little 'duck typing' check to see if the `.then` property of the value is
 * defined and a function.
 *
 * @param maybePromise it might be a promise!
 * @returns whether it is or not
 */
const isPromisey = maybePromise => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === 'function';
/**
 * Update a component given reference to its host elements and so on.
 *
 * @param hostRef an object containing references to the element's host node,
 * VDom nodes, and other metadata
 * @param instance a reference to the underlying host element where it will be
 * rendered
 * @param isInitialLoad whether or not this function is being called as part of
 * the first render cycle
 */
const updateComponent = /*#__PURE__*/function () {
  var _ref = (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (hostRef, instance, isInitialLoad) {
    var _a;
    const elm = hostRef.$hostElement$;
    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    const rc = elm['s-rc'];
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.style && isInitialLoad) {
      // DOM WRITE!
      attachStyles(hostRef);
    }
    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
      hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide) {
      yield callRender(hostRef, instance, elm, isInitialLoad);
    } else {
      callRender(hostRef, instance, elm, isInitialLoad);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
      hostRef.$renderCount$ = hostRef.$renderCount$ === undefined ? 1 : hostRef.$renderCount$ + 1;
      hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide) {
      try {
        // manually connected child components during server-side hydrate
        serverSideConnected(elm);
        if (isInitialLoad) {
          // using only during server-side hydrate
          if (hostRef.$cmpMeta$.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
            elm['s-en'] = '';
          } else if (hostRef.$cmpMeta$.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
            elm['s-en'] = 'c';
          }
        }
      } catch (e) {
        consoleError(e, elm);
      }
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading && rc) {
      // ok, so turns out there are some child host elements
      // waiting on this parent element to load
      // let's fire off all update callbacks waiting
      rc.map(cb => cb());
      elm['s-rc'] = undefined;
    }
    endRender();
    endUpdate();
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading) {
      const childrenPromises = (_a = elm['s-p']) !== null && _a !== void 0 ? _a : [];
      const postUpdate = () => postUpdateComponent(hostRef);
      if (childrenPromises.length === 0) {
        postUpdate();
      } else {
        Promise.all(childrenPromises).then(postUpdate);
        hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
        childrenPromises.length = 0;
      }
    } else {
      postUpdateComponent(hostRef);
    }
  });
  return function updateComponent(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Handle making the call to the VDom renderer with the proper context given
 * various build variables
 *
 * @param hostRef an object containing references to the element's host node,
 * VDom nodes, and other metadata
 * @param instance a reference to the underlying host element where it will be
 * rendered
 * @param elm the Host element for the component
 * @param isInitialLoad whether or not this function is being called as part of
 * @returns an empty promise
 */
const callRender = (hostRef, instance, elm, isInitialLoad) => {
  // in order for bundlers to correctly tree-shake the BUILD object
  // we need to ensure BUILD is not deoptimized within a try/catch
  // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization
  const allRenderFn = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.allRenderFn ? true : false;
  const lazyLoad = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? true : false;
  const taskQueue = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.taskQueue ? true : false;
  const updatable = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable ? true : false;
  try {
    renderingRef = instance;
    /**
     * minification optimization: `allRenderFn` is `true` if all components have a `render`
     * method, so we can call the method immediately. If not, check before calling it.
     */
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hasRenderFn || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.reflect) {
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.vdomRender || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.reflect) {
        // looks like we've got child nodes to render into this host element
        // or we need to update the css class/attrs on the host element
        // DOM WRITE!
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide) {
          return Promise.resolve(instance).then(value => renderVdom(hostRef, value, isInitialLoad));
        } else {
          renderVdom(hostRef, instance, isInitialLoad);
        }
      } else {
        const shadowRoot = elm.shadowRoot;
        if (hostRef.$cmpMeta$.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
          shadowRoot.textContent = instance;
        } else {
          elm.textContent = instance;
        }
      }
    }
  } catch (e) {
    consoleError(e, hostRef.$hostElement$);
  }
  renderingRef = null;
  return null;
};
const getRenderingRef = () => renderingRef;
const postUpdateComponent = hostRef => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime('postUpdate', tagName);
  const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
  const ancestorComponent = hostRef.$ancestorComponent$;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpDidRender) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
      hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;
    }
    safeCall(instance, 'componentDidRender');
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
      hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;
    }
  }
  emitLifecycleEvent(elm, 'componentDidRender');
  if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
    hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cssAnnotations) {
      // DOM WRITE!
      addHydratedFlag(elm);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpDidLoad) {
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
        hostRef.$flags$ |= 2048 /* HOST_FLAGS.devOnDidLoad */;
      }
      safeCall(instance, 'componentDidLoad');
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
        hostRef.$flags$ &= ~2048 /* HOST_FLAGS.devOnDidLoad */;
      }
    }
    emitLifecycleEvent(elm, 'componentDidLoad');
    endPostUpdate();
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading) {
      hostRef.$onReadyResolve$(elm);
      if (!ancestorComponent) {
        appDidLoad(tagName);
      }
    }
  } else {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpDidUpdate) {
      // we've already loaded this component
      // fire off the user's componentDidUpdate method (if one was provided)
      // componentDidUpdate runs AFTER render() has been called
      // and all child components have finished updating
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
        hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;
      }
      safeCall(instance, 'componentDidUpdate');
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
        hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;
      }
    }
    emitLifecycleEvent(elm, 'componentDidUpdate');
    endPostUpdate();
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad) {
    hostRef.$onInstanceResolve$(elm);
  }
  // load events fire from bottom to top
  // the deepest elements load first then bubbles up
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading) {
    if (hostRef.$onRenderResolve$) {
      hostRef.$onRenderResolve$();
      hostRef.$onRenderResolve$ = undefined;
    }
    if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {
      nextTick(() => scheduleUpdate(hostRef, false));
    }
    hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);
  }
  // ( •_•)
  // ( •_•)>⌐■-■
  // (⌐■_■)
};
const forceUpdate = ref => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable && (Build.isBrowser || Build.isTesting)) {
    const hostRef = getHostRef(ref);
    const isConnected = hostRef.$hostElement$.isConnected;
    if (isConnected && (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
      scheduleUpdate(hostRef, false);
    }
    // Returns "true" when the forced update was successfully scheduled
    return isConnected;
  }
  return false;
};
const appDidLoad = who => {
  // on appload
  // we have finish the first big initial render
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cssAnnotations) {
    addHydratedFlag(doc.documentElement);
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncQueue) {
    plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;
  }
  nextTick(() => emitEvent(win, 'appload', {
    detail: {
      namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.NAMESPACE
    }
  }));
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.profile && performance.measure) {
    performance.measure(`[Stencil] ${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.NAMESPACE} initial load (by ${who})`, 'st:app:start');
  }
};
/**
 * Allows to safely call a method, e.g. `componentDidLoad`, on an instance,
 * e.g. custom element node. If a build figures out that e.g. no component
 * has a `componentDidLoad` method, the instance method gets removed from the
 * output bundle and this function returns `undefined`.
 * @param instance any object that may or may not contain methods
 * @param method method name
 * @param arg single arbitrary argument
 * @returns result of method call if it exists, otherwise `undefined`
 */
const safeCall = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e) {
      consoleError(e);
    }
  }
  return undefined;
};
/**
 * For debugging purposes as `BUILD.lifecycleDOMEvents` is `false` by default and will
 * get removed by the compiler. Used for timing events to see how long they take.
 * @param elm the target of the Event
 * @param lifecycleName name of the event
 */
const emitLifecycleEvent = (elm, lifecycleName) => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lifecycleDOMEvents) {
    emitEvent(elm, 'stencil_' + lifecycleName, {
      bubbles: true,
      composed: true,
      detail: {
        namespace: _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.NAMESPACE
      }
    });
  }
};
const addHydratedFlag = elm => _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydratedClass ? elm.classList.add('hydrated') : _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydratedAttribute ? elm.setAttribute('hydrated', '') : undefined;
const serverSideConnected = elm => {
  const children = elm.children;
  if (children != null) {
    for (let i = 0, ii = children.length; i < ii; i++) {
      const childElm = children[i];
      if (typeof childElm.connectedCallback === 'function') {
        childElm.connectedCallback();
      }
      serverSideConnected(childElm);
    }
  }
};
const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
  // check our new property value against our internal value
  const hostRef = getHostRef(ref);
  const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$hostElement$ : ref;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  // explicitly check for NaN on both sides, as `NaN === NaN` is always false
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if ((!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad || !(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {
    // gadzooks! the property's value has changed!!
    // set our new value!
    hostRef.$instanceValues$.set(propName, newVal);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
      if (hostRef.$flags$ & 1024 /* HOST_FLAGS.devOnRender */) {
        consoleDevWarn(`The state/prop "${propName}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\nElement', elm, '\nNew value', newVal, '\nOld value', oldVal);
      } else if (hostRef.$flags$ & 2048 /* HOST_FLAGS.devOnDidLoad */) {
        consoleDevWarn(`The state/prop "${propName}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, '\nElement', elm, '\nNew value', newVal, '\nOld value', oldVal);
      }
    }
    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad || instance) {
      // get an array of method names of watch functions to call
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          // this instance is watching for when this property changed
          watchMethods.map(watchMethodName => {
            try {
              // fire off each of the watch methods that are watching this property
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e) {
              consoleError(e, elm);
            }
          });
        }
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.updatable && (flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        // looks like this value actually changed, so we've got work to do!
        // but only if we've already rendered, otherwise just chill out
        // queue that we need to do an update, but don't worry about queuing
        // up millions cuz this function ensures it only runs once
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
/**
 * Attach a series of runtime constructs to a compiled Stencil component
 * constructor, including getters and setters for the `@Prop` and `@State`
 * decorators, callbacks for when attributes change, and so on.
 *
 * @param Cstr the constructor for a component that we need to process
 * @param cmpMeta metadata collected previously about the component
 * @param flags a number used to store a series of bit flags
 * @returns a reference to the same constructor passed in (but now mutated)
 */
const proxyComponent = (Cstr, cmpMeta, flags) => {
  var _a;
  const prototype = Cstr.prototype;
  /**
   * proxy form associated custom element lifecycle callbacks
   * @ref https://web.dev/articles/more-capable-form-controls#lifecycle_callbacks
   */
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.formAssociated && cmpMeta.$flags$ & 64 /* CMP_FLAGS.formAssociated */ && flags & 1 /* PROXY_FLAGS.isElementConstructor */) {
    FORM_ASSOCIATED_CUSTOM_ELEMENT_CALLBACKS.forEach(cbName => Object.defineProperty(prototype, cbName, {
      value(...args) {
        const hostRef = getHostRef(this);
        const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$hostElement$ : this;
        const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
        if (!instance) {
          hostRef.$onReadyPromise$.then(instance => {
            const cb = instance[cbName];
            typeof cb === 'function' && cb.call(instance, ...args);
          });
        } else {
          const cb = instance[cbName];
          typeof cb === 'function' && cb.call(instance, ...args);
        }
      }
    }));
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.member && cmpMeta.$members$) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.watchCallback && Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    // It's better to have a const than two Object.entries()
    const members = Object.entries(cmpMeta.$members$);
    members.map(([memberName, [memberFlags]]) => {
      if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.prop || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.state) && (memberFlags & 31 /* MEMBER_FLAGS.Prop */ || (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad || flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */)) {
        // proxyComponent - prop
        Object.defineProperty(prototype, memberName, {
          get() {
            // proxyComponent, get value
            return getValue(this, memberName);
          },
          set(newValue) {
            // only during dev time
            if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
              const ref = getHostRef(this);
              if (
              // we are proxying the instance (not element)
              (flags & 1 /* PROXY_FLAGS.isElementConstructor */) === 0 &&
              // the element is not constructing
              (ref && ref.$flags$ & 8 /* HOST_FLAGS.isConstructingInstance */) === 0 &&
              // the member is a prop
              (memberFlags & 31 /* MEMBER_FLAGS.Prop */) !== 0 &&
              // the member is not mutable
              (memberFlags & 1024 /* MEMBER_FLAGS.Mutable */) === 0) {
                consoleDevWarn(`@Prop() "${memberName}" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);
              }
            }
            // proxyComponent, set value
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      } else if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.method && flags & 1 /* PROXY_FLAGS.isElementConstructor */ && memberFlags & 64 /* MEMBER_FLAGS.Method */) {
        // proxyComponent - method
        Object.defineProperty(prototype, memberName, {
          value(...args) {
            var _a;
            const ref = getHostRef(this);
            return (_a = ref === null || ref === void 0 ? void 0 : ref.$onInstancePromise$) === null || _a === void 0 ? void 0 : _a.then(() => {
              var _a;
              return (_a = ref.$lazyInstance$) === null || _a === void 0 ? void 0 : _a[memberName](...args);
            });
          }
        });
      }
    });
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.observeAttribute && (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad || flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {
      const attrNameToPropName = new Map();
      prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {
        plt.jmp(() => {
          var _a;
          const propName = attrNameToPropName.get(attrName);
          //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
          //  in the case where an attribute was set inline.
          //  ```html
          //    <my-component some-attribute="some-value"></my-component>
          //  ```
          //
          //  There is an edge case where a developer sets the attribute inline on a custom element and then
          //  programmatically changes it before it has been upgraded as shown below:
          //
          //  ```html
          //    <!-- this component has _not_ been upgraded yet -->
          //    <my-component id="test" some-attribute="some-value"></my-component>
          //    <script>
          //      // grab non-upgraded component
          //      el = document.querySelector("#test");
          //      el.someAttribute = "another-value";
          //      // upgrade component
          //      customElements.define('my-component', MyComponent);
          //    </script>
          //  ```
          //  In this case if we do not un-shadow here and use the value of the shadowing property, attributeChangedCallback
          //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
          //  to the value that was set inline i.e. "some-value" from above example. When
          //  the connectedCallback attempts to un-shadow it will use "some-value" as the initial value rather than "another-value"
          //
          //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/un-shadowed
          //  by connectedCallback as this attributeChangedCallback will not fire.
          //
          //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
          //
          //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
          //  properties here given that this goes against best practices outlined here
          //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === 'number' && this[propName] == newValue) {
            // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
            // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
            // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
            return;
          } else if (propName == null) {
            // At this point we should know this is not a "member", so we can treat it like watching an attribute
            // on a vanilla web component
            const hostRef = getHostRef(this);
            const flags = hostRef === null || hostRef === void 0 ? void 0 : hostRef.$flags$;
            // We only want to trigger the callback(s) if:
            // 1. The instance is ready
            // 2. The watchers are ready
            // 3. The value has changed
            if (flags && !(flags & 8 /* HOST_FLAGS.isConstructingInstance */) && flags & 128 /* HOST_FLAGS.isWatchReady */ && newValue !== oldValue) {
              const elm = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$hostElement$ : this;
              const instance = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
              const entry = (_a = cmpMeta.$watchers$) === null || _a === void 0 ? void 0 : _a[attrName];
              entry === null || entry === void 0 ? void 0 : entry.forEach(callbackName => {
                if (instance[callbackName] != null) {
                  instance[callbackName].call(instance, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
        });
      };
      // Create an array of attributes to observe
      // This list in comprised of all strings used within a `@Watch()` decorator
      // on a component as well as any Stencil-specific "members" (`@Prop()`s and `@State()`s).
      // As such, there is no way to guarantee type-safety here that a user hasn't entered
      // an invalid attribute.
      Cstr.observedAttributes = Array.from(new Set([...Object.keys((_a = cmpMeta.$watchers$) !== null && _a !== void 0 ? _a : {}), ...members.filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */).map(([propName, m]) => {
        var _a;
        const attrName = m[1] || propName;
        attrNameToPropName.set(attrName, propName);
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.reflect && m[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {
          (_a = cmpMeta.$attrsToReflect$) === null || _a === void 0 ? void 0 : _a.push([propName, attrName]);
        }
        return attrName;
      })]));
    }
  }
  return Cstr;
};
/**
 * Initialize a Stencil component given a reference to its host element, its
 * runtime bookkeeping data structure, runtime metadata about the component,
 * and (optionally) an HMR version ID.
 *
 * @param elm a host element
 * @param hostRef the element's runtime bookkeeping object
 * @param cmpMeta runtime metadata for the Stencil component
 * @param hmrVersionId an (optional) HMR version ID
 */
const initializeComponent = /*#__PURE__*/function () {
  var _ref2 = (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (elm, hostRef, cmpMeta, hmrVersionId) {
    let Cstr;
    // initializeComponent
    if ((hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
      // Let the runtime know that the component has been initialized
      hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateClientSide) {
        // lazy loaded components
        // request the component's implementation to be
        // wired up with the host element
        Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);
        if (Cstr.then) {
          // Await creates a micro-task avoid if possible
          const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);
          Cstr = yield Cstr;
          endLoad();
        }
        if ((_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDebug) && !Cstr) {
          throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.member && !Cstr.isProxied) {
          // we've never proxied this Constructor before
          // let's add the getters/setters to its prototype before
          // the first time we create an instance of the implementation
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.watchCallback) {
            cmpMeta.$watchers$ = Cstr.watchers;
          }
          proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);
          Cstr.isProxied = true;
        }
        const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
        // ok, time to construct the instance
        // but let's keep track of when we start and stop
        // so that the getters/setters don't incorrectly step on data
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.member) {
          hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;
        }
        // construct the lazy-loaded component implementation
        // passing the hostRef is very important during
        // construction in order to directly wire together the
        // host element and the lazy-loaded instance
        try {
          new Cstr(hostRef);
        } catch (e) {
          consoleError(e);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.member) {
          hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.watchCallback) {
          hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;
        }
        endNewInstance();
        fireConnectedCallback(hostRef.$lazyInstance$);
      } else {
        // sync constructor component
        Cstr = elm.constructor;
        // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,
        // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_
        // Stencil has completed instantiating the component.
        customElements.whenDefined(cmpMeta.$tagName$).then(() => hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */);
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.style && Cstr.style) {
        // this component has styles but we haven't registered them yet
        let style = Cstr.style;
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.mode && typeof style !== 'string') {
          style = style[hostRef.$modeName$ = computeMode(elm)];
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide && hostRef.$modeName$) {
            elm.setAttribute('s-mode', hostRef.$modeName$);
          }
        }
        const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);
        if (!styles.has(scopeId)) {
          const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
          if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom &&
          // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
          _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDomShim && cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {
            style = yield __webpack_require__.e(/*! import() */ "node_modules_stencil_core_internal_client_shadow-css_js").then(__webpack_require__.bind(__webpack_require__, /*! ./shadow-css.js */ 55686)).then(m => m.scopeCss(style, scopeId, false));
          }
          registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
          endRegisterStyles();
        }
      }
    }
    // we've successfully created a lazy instance
    const ancestorComponent = hostRef.$ancestorComponent$;
    const schedule = () => scheduleUpdate(hostRef, true);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {
      // this is the initial load and this component it has an ancestor component
      // but the ancestor component has NOT fired its will update lifecycle yet
      // so let's just cool our jets and wait for the ancestor to continue first
      // this will get fired off when the ancestor component
      // finally gets around to rendering its lazy self
      // fire off the initial update
      ancestorComponent['s-rc'].push(schedule);
    } else {
      schedule();
    }
  });
  return function initializeComponent(_x4, _x5, _x6, _x7) {
    return _ref2.apply(this, arguments);
  };
}();
const fireConnectedCallback = instance => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.connectedCallback) {
    safeCall(instance, 'connectedCallback');
  }
};
const connectedCallback = elm => {
  if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListenerTargetParent) {
      // only run if we have listeners being attached to a parent
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);
    }
    if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {
      // first time this component has connected
      hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;
      let hostId;
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateClientSide) {
        hostId = elm.getAttribute(HYDRATE_ID);
        if (hostId) {
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
            const scopeId = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode')) : addStyle(elm.shadowRoot, cmpMeta);
            elm.classList.remove(scopeId + '-h', scopeId + '-s');
          }
          initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
        }
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotRelocation && !hostId) {
        // initUpdate
        // if the slot polyfill is required we'll need to put some nodes
        // in here to act as original content anchors as we move nodes around
        // host element has been connected to the DOM
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide || (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slot || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom) &&
        // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
        cmpMeta.$flags$ & (4 /* CMP_FLAGS.hasSlotRelocation */ | 8 /* CMP_FLAGS.needsShadowDomShim */)) {
          setContentReference(elm);
        }
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading) {
        // find the first ancestor component (if there is one) and register
        // this component as one of the actively loading child components for its ancestor
        let ancestorComponent = elm;
        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
          // climb up the ancestors looking for the first
          // component that hasn't finished its lifecycle update yet
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 /* NODE_TYPE.ElementNode */ && ancestorComponent.hasAttribute('s-id') && ancestorComponent['s-p'] || ancestorComponent['s-p']) {
            // we found this components first ancestor component
            // keep a reference to this component's ancestor component
            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
            break;
          }
        }
      }
      // Lazy properties
      // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.prop && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide && cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.initializeNextTick) {
        // connectedCallback, taskQueue, initialLoad
        // angular sets attribute AFTER connectCallback
        // https://github.com/angular/angular/issues/18909
        // https://github.com/angular/angular/issues/19940
        nextTick(() => initializeComponent(elm, hostRef, cmpMeta));
      } else {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      // not the first time this has connected
      // reattach any event listeners to the host
      // since they would have been removed when disconnected
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
      // fire off connectedCallback() on component instance
      if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
        fireConnectedCallback(hostRef.$lazyInstance$);
      } else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
      }
    }
    endConnected();
  }
};
const setContentReference = elm => {
  // only required when we're NOT using native shadow dom (slot)
  // or this browser doesn't support native shadow dom
  // and this host element was NOT created with SSR
  // let's pick out the inner content for slot projection
  // create a node to represent where the original
  // content was first placed, which is useful later on
  const contentRefElm = elm['s-cr'] = doc.createComment(_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDebug ? `content-ref (host=${elm.localName})` : '');
  contentRefElm['s-cn'] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectInstance = instance => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.disconnectedCallback) {
    safeCall(instance, 'disconnectedCallback');
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cmpDidUnload) {
    safeCall(instance, 'componentDidUnload');
  }
};
const disconnectedCallback = /*#__PURE__*/function () {
  var _ref3 = (0,_Users_lotte_Documents_Telenet_customer_web_monorepo_node_modules_babel_runtime_helpers_esm_asyncToGenerator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function* (elm) {
    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
      const hostRef = getHostRef(elm);
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListener) {
        if (hostRef.$rmListeners$) {
          hostRef.$rmListeners$.map(rmListener => rmListener());
          hostRef.$rmListeners$ = undefined;
        }
      }
      if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad) {
        disconnectInstance(elm);
      } else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
        disconnectInstance(hostRef.$lazyInstance$);
      } else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$));
      }
    }
  });
  return function disconnectedCallback(_x8) {
    return _ref3.apply(this, arguments);
  };
}();
const patchPseudoShadowDom = (hostElementPrototype, descriptorPrototype) => {
  patchCloneNode(hostElementPrototype);
  patchSlotAppendChild(hostElementPrototype);
  patchSlotAppend(hostElementPrototype);
  patchSlotPrepend(hostElementPrototype);
  patchSlotInsertAdjacentElement(hostElementPrototype);
  patchSlotInsertAdjacentHTML(hostElementPrototype);
  patchSlotInsertAdjacentText(hostElementPrototype);
  patchTextContent(hostElementPrototype);
  patchChildSlotNodes(hostElementPrototype, descriptorPrototype);
  patchSlotRemoveChild(hostElementPrototype);
};
const patchCloneNode = HostElementPrototype => {
  const orgCloneNode = HostElementPrototype.cloneNode;
  HostElementPrototype.cloneNode = function (deep) {
    const srcNode = this;
    const isShadowDom = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;
    const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slot && !isShadowDom && deep) {
      let i = 0;
      let slotted, nonStencilNode;
      const stencilPrivates = ['s-id', 's-cr', 's-lr', 's-rc', 's-sc', 's-p', 's-cn', 's-sr', 's-sn', 's-hn', 's-ol', 's-nr', 's-si'];
      for (; i < srcNode.childNodes.length; i++) {
        slotted = srcNode.childNodes[i]['s-nr'];
        nonStencilNode = stencilPrivates.every(privateField => !srcNode.childNodes[i][privateField]);
        if (slotted) {
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.appendChildSlotFix && clonedNode.__appendChild) {
            clonedNode.__appendChild(slotted.cloneNode(true));
          } else {
            clonedNode.appendChild(slotted.cloneNode(true));
          }
        }
        if (nonStencilNode) {
          clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));
        }
      }
    }
    return clonedNode;
  };
};
/**
 * Patches the `appendChild` method on a `scoped` Stencil component.
 * The patch will attempt to find a slot with the same name as the node being appended
 * and insert it into the slot reference if found. Otherwise, it falls-back to the original
 * `appendChild` method.
 *
 * @param HostElementPrototype The Stencil component to be patched
 */
const patchSlotAppendChild = HostElementPrototype => {
  HostElementPrototype.__appendChild = HostElementPrototype.appendChild;
  HostElementPrototype.appendChild = function (newChild) {
    const slotName = newChild['s-sn'] = getSlotName(newChild);
    const slotNode = getHostSlotNode(this.childNodes, slotName);
    if (slotNode) {
      const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);
      const appendAfter = slotChildNodes[slotChildNodes.length - 1];
      const insertedNode = appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);
      // Check if there is fallback content that should be hidden
      updateFallbackSlotVisibility(this);
      // Force a re-render of the host element
      forceUpdate(this);
      return insertedNode;
    }
    return this.__appendChild(newChild);
  };
};
/**
 * Patches the `removeChild` method on a `scoped` Stencil component.
 * This patch attempts to remove the specified node from a slot reference
 * if the slot exists. Otherwise, it falls-back to the original `removeChild` method.
 *
 * @param ElementPrototype The Stencil component to be patched
 */
const patchSlotRemoveChild = ElementPrototype => {
  ElementPrototype.__removeChild = ElementPrototype.removeChild;
  ElementPrototype.removeChild = function (toRemove) {
    if (toRemove && typeof toRemove['s-sn'] !== 'undefined') {
      const slotNode = getHostSlotNode(this.childNodes, toRemove['s-sn']);
      if (slotNode) {
        // Get all slot content
        const slotChildNodes = getHostSlotChildNodes(slotNode, toRemove['s-sn']);
        // See if any of the slotted content matches the node to remove
        const existingNode = slotChildNodes.find(n => n === toRemove);
        if (existingNode) {
          existingNode.remove();
          // Check if there is fallback content that should be displayed if that
          // was the last node in the slot
          updateFallbackSlotVisibility(this);
          return;
        }
      }
    }
    return this.__removeChild(toRemove);
  };
};
/**
 * Patches the `prepend` method for a slotted node inside a scoped component.
 *
 * @param HostElementPrototype the `Element` to be patched
 */
const patchSlotPrepend = HostElementPrototype => {
  const originalPrepend = HostElementPrototype.prepend;
  HostElementPrototype.prepend = function (...newChildren) {
    newChildren.forEach(newChild => {
      if (typeof newChild === 'string') {
        newChild = this.ownerDocument.createTextNode(newChild);
      }
      const slotName = newChild['s-sn'] = getSlotName(newChild);
      const slotNode = getHostSlotNode(this.childNodes, slotName);
      if (slotNode) {
        const slotPlaceholder = document.createTextNode('');
        slotPlaceholder['s-nr'] = newChild;
        slotNode['s-cr'].parentNode.__appendChild(slotPlaceholder);
        newChild['s-ol'] = slotPlaceholder;
        const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);
        const appendAfter = slotChildNodes[0];
        return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);
      }
      if (newChild.nodeType === 1 && !!newChild.getAttribute('slot')) {
        newChild.hidden = true;
      }
      return originalPrepend.call(this, newChild);
    });
  };
};
/**
 * Patches the `append` method for a slotted node inside a scoped component. The patched method uses
 * `appendChild` under-the-hood while creating text nodes for any new children that passed as bare strings.
 *
 * @param HostElementPrototype the `Element` to be patched
 */
const patchSlotAppend = HostElementPrototype => {
  HostElementPrototype.append = function (...newChildren) {
    newChildren.forEach(newChild => {
      if (typeof newChild === 'string') {
        newChild = this.ownerDocument.createTextNode(newChild);
      }
      this.appendChild(newChild);
    });
  };
};
/**
 * Patches the `insertAdjacentHTML` method for a slotted node inside a scoped component. Specifically,
 * we only need to patch the behavior for the specific `beforeend` and `afterbegin` positions so the element
 * gets inserted into the DOM in the correct location.
 *
 * @param HostElementPrototype the `Element` to be patched
 */
const patchSlotInsertAdjacentHTML = HostElementPrototype => {
  const originalInsertAdjacentHtml = HostElementPrototype.insertAdjacentHTML;
  HostElementPrototype.insertAdjacentHTML = function (position, text) {
    if (position !== 'afterbegin' && position !== 'beforeend') {
      return originalInsertAdjacentHtml.call(this, position, text);
    }
    const container = this.ownerDocument.createElement('_');
    let node;
    container.innerHTML = text;
    if (position === 'afterbegin') {
      while (node = container.firstChild) {
        this.prepend(node);
      }
    } else if (position === 'beforeend') {
      while (node = container.firstChild) {
        this.append(node);
      }
    }
  };
};
/**
 * Patches the `insertAdjacentText` method for a slotted node inside a scoped component. Specifically,
 * we only need to patch the behavior for the specific `beforeend` and `afterbegin` positions so the text node
 * gets inserted into the DOM in the correct location.
 *
 * @param HostElementPrototype the `Element` to be patched
 */
const patchSlotInsertAdjacentText = HostElementPrototype => {
  HostElementPrototype.insertAdjacentText = function (position, text) {
    this.insertAdjacentHTML(position, text);
  };
};
/**
 * Patches the `insertAdjacentElement` method for a slotted node inside a scoped component. Specifically,
 * we only need to patch the behavior for the specific `beforeend` and `afterbegin` positions so the element
 * gets inserted into the DOM in the correct location.
 *
 * @param HostElementPrototype the `Element` to be patched
 */
const patchSlotInsertAdjacentElement = HostElementPrototype => {
  const originalInsertAdjacentElement = HostElementPrototype.insertAdjacentElement;
  HostElementPrototype.insertAdjacentElement = function (position, element) {
    if (position !== 'afterbegin' && position !== 'beforeend') {
      return originalInsertAdjacentElement.call(this, position, element);
    }
    if (position === 'afterbegin') {
      this.prepend(element);
      return element;
    } else if (position === 'beforeend') {
      this.append(element);
      return element;
    }
    return element;
  };
};
/**
 * Patches the text content of an unnamed slotted node inside a scoped component
 * @param hostElementPrototype the `Element` to be patched
 */
const patchTextContent = hostElementPrototype => {
  const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');
  Object.defineProperty(hostElementPrototype, '__textContent', descriptor);
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalScopedSlotChanges) {
    // Patch `textContent` to mimic shadow root behavior
    Object.defineProperty(hostElementPrototype, 'textContent', {
      // To mimic shadow root behavior, we need to return the text content of all
      // nodes in a slot reference node
      get() {
        const slotRefNodes = getAllChildSlotNodes(this.childNodes);
        const textContent = slotRefNodes.map(node => {
          var _a, _b;
          const text = [];
          // Need to get the text content of all nodes in the slot reference node
          let slotContent = node.nextSibling;
          while (slotContent && slotContent['s-sn'] === node['s-sn']) {
            if (slotContent.nodeType === 3 /* NODE_TYPES.TEXT_NODE */ || slotContent.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
              text.push((_b = (_a = slotContent.textContent) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : '');
            }
            slotContent = slotContent.nextSibling;
          }
          return text.filter(ref => ref !== '').join(' ');
        }).filter(text => text !== '').join(' ');
        // Pad the string to return
        return ' ' + textContent + ' ';
      },
      // To mimic shadow root behavior, we need to overwrite all nodes in a slot
      // reference node. If a default slot reference node exists, the text content will be
      // placed there. Otherwise, the new text node will be hidden
      set(value) {
        const slotRefNodes = getAllChildSlotNodes(this.childNodes);
        slotRefNodes.forEach(node => {
          // Remove the existing content of the slot
          let slotContent = node.nextSibling;
          while (slotContent && slotContent['s-sn'] === node['s-sn']) {
            const tmp = slotContent;
            slotContent = slotContent.nextSibling;
            tmp.remove();
          }
          // If this is a default slot, add the text node in the slot location.
          // Otherwise, destroy the slot reference node
          if (node['s-sn'] === '') {
            const textNode = this.ownerDocument.createTextNode(value);
            textNode['s-sn'] = '';
            node.parentElement.insertBefore(textNode, node.nextSibling);
          } else {
            node.remove();
          }
        });
      }
    });
  } else {
    Object.defineProperty(hostElementPrototype, 'textContent', {
      get() {
        var _a;
        // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is
        // the empty string
        const slotNode = getHostSlotNode(this.childNodes, '');
        // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how
        // nodes were reordered during the vdom render. first try to get the text content from the sibling.
        if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {
          return slotNode.nextSibling.textContent;
        } else if (slotNode) {
          return slotNode.textContent;
        } else {
          // fallback to the original implementation
          return this.__textContent;
        }
      },
      set(value) {
        var _a;
        // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is
        // the empty string
        const slotNode = getHostSlotNode(this.childNodes, '');
        // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,
        // depending on how nodes were reordered during the vdom render. first try to set the text content on the
        // sibling.
        if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {
          slotNode.nextSibling.textContent = value;
        } else if (slotNode) {
          slotNode.textContent = value;
        } else {
          // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM
          // loaded, we could have missed it. check for a content reference element on the scoped component and insert
          // it there
          this.__textContent = value;
          const contentRefElm = this['s-cr'];
          if (contentRefElm) {
            this.insertBefore(contentRefElm, this.firstChild);
          }
        }
      }
    });
  }
};
const patchChildSlotNodes = (elm, cmpMeta) => {
  class FakeNodeList extends Array {
    item(n) {
      return this[n];
    }
  }
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  if (cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {
    const childNodesFn = elm.__lookupGetter__('childNodes');
    Object.defineProperty(elm, 'children', {
      get() {
        return this.childNodes.map(n => n.nodeType === 1);
      }
    });
    Object.defineProperty(elm, 'childElementCount', {
      get() {
        return elm.children.length;
      }
    });
    Object.defineProperty(elm, 'childNodes', {
      get() {
        const childNodes = childNodesFn.call(this);
        if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0 && getHostRef(this).$flags$ & 2 /* HOST_FLAGS.hasRendered */) {
          const result = new FakeNodeList();
          for (let i = 0; i < childNodes.length; i++) {
            const slot = childNodes[i]['s-nr'];
            if (slot) {
              result.push(slot);
            }
          }
          return result;
        }
        return FakeNodeList.from(childNodes);
      }
    });
  }
};
/**
 * Recursively finds all slot reference nodes ('s-sr') in a series of child nodes.
 *
 * @param childNodes The set of child nodes to search for slot reference nodes.
 * @returns An array of slot reference nodes.
 */
const getAllChildSlotNodes = childNodes => {
  const slotRefNodes = [];
  for (const childNode of Array.from(childNodes)) {
    if (childNode['s-sr']) {
      slotRefNodes.push(childNode);
    }
    slotRefNodes.push(...getAllChildSlotNodes(childNode.childNodes));
  }
  return slotRefNodes;
};
const getSlotName = node => node['s-sn'] || node.nodeType === 1 && node.getAttribute('slot') || '';
/**
 * Recursively searches a series of child nodes for a slot with the provided name.
 * @param childNodes the nodes to search for a slot with a specific name.
 * @param slotName the name of the slot to match on.
 * @returns a reference to the slot node that matches the provided name, `null` otherwise
 */
const getHostSlotNode = (childNodes, slotName) => {
  let i = 0;
  let childNode;
  for (; i < childNodes.length; i++) {
    childNode = childNodes[i];
    if (childNode['s-sr'] && childNode['s-sn'] === slotName) {
      return childNode;
    }
    childNode = getHostSlotNode(childNode.childNodes, slotName);
    if (childNode) {
      return childNode;
    }
  }
  return null;
};
const getHostSlotChildNodes = (n, slotName) => {
  const childNodes = [n];
  while ((n = n.nextSibling) && n['s-sn'] === slotName) {
    childNodes.push(n);
  }
  return childNodes;
};
const defineCustomElement = (Cstr, compactMeta) => {
  customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));
};
const proxyCustomElement = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.member) {
    cmpMeta.$members$ = compactMeta[2];
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListener) {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.watchCallback) {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.reflect) {
    cmpMeta.$attrsToReflect$ = [];
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
    // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;
  }
  // TODO(STENCIL-914): this check and `else` block can go away and be replaced by just the `scoped` check
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalSlotFixes) {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scoped && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
      // This check is intentionally not combined with the surrounding `experimentalSlotFixes` check
      // since, moving forward, we only want to patch the pseudo shadow DOM when the component is scoped
      patchPseudoShadowDom(Cstr.prototype, cmpMeta);
    }
  } else {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotChildNodesFix) {
      patchChildSlotNodes(Cstr.prototype, cmpMeta);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cloneNodeFix) {
      patchCloneNode(Cstr.prototype);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.appendChildSlotFix) {
      patchSlotAppendChild(Cstr.prototype);
    }
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scopedSlotTextContentFix && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
      patchTextContent(Cstr.prototype);
    }
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost(this, cmpMeta);
    },
    connectedCallback() {
      connectedCallback(this);
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.connectedCallback && originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback(this);
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.disconnectedCallback && originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      if (supportsShadow) {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDelegatesFocus) {
          this.attachShadow({
            mode: 'open',
            delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */)
          });
        } else {
          this.attachShadow({
            mode: 'open'
          });
        }
      } else {
        this.shadowRoot = this;
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent(Cstr, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */ | 2 /* PROXY_FLAGS.proxyState */);
};
const forceModeUpdate = elm => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.style && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.mode && !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad) {
    const mode = computeMode(elm);
    const hostRef = getHostRef(elm);
    if (hostRef.$modeName$ !== mode) {
      const cmpMeta = hostRef.$cmpMeta$;
      const oldScopeId = elm['s-sc'];
      const scopeId = getScopeId(cmpMeta, mode);
      const style = elm.constructor.style[mode];
      const flags = cmpMeta.$flags$;
      if (style) {
        if (!styles.has(scopeId)) {
          registerStyle(scopeId, style, !!(flags & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
        }
        hostRef.$modeName$ = mode;
        elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');
        attachStyles(hostRef);
        forceUpdate(elm);
      }
    }
  }
};
/**
 * Kick off hot-module-replacement for a component. In order to replace the
 * component in-place we:
 *
 * 1. get a reference to the {@link d.HostRef} for the element
 * 2. reset the element's runtime flags
 * 3. re-run the initialization logic for the element (via
 *    {@link initializeComponent})
 *
 * @param hostElement the host element for the component which we want to start
 * doing HMR
 * @param cmpMeta runtime metadata for the component
 * @param hmrVersionId the current HMR version ID
 */
const hmrStart = (hostElement, cmpMeta, hmrVersionId) => {
  // ¯\_(ツ)_/¯
  const hostRef = getHostRef(hostElement);
  // reset state flags to only have been connected
  hostRef.$flags$ = 1 /* HOST_FLAGS.hasConnected */;
  // TODO
  // detach any event listeners that may have been added
  // because we're not passing an exact event name it'll
  // remove all of this element's event, which is good
  // re-initialize the component
  initializeComponent(hostElement, hostRef, cmpMeta, hmrVersionId);
};
const bootstrapLazy = (lazyBundles, options = {}) => {
  var _a;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.profile && performance.mark) {
    performance.mark('st:app:start');
  }
  installDevTools();
  const endBootstrap = createTime('bootstrapLazy');
  const cmpTags = [];
  const exclude = options.exclude || [];
  const customElements = win.customElements;
  const head = doc.head;
  const metaCharset = /*@__PURE__*/head.querySelector('meta[charset]');
  const dataStyles = /*@__PURE__*/doc.createElement('style');
  const deferredConnectedCallbacks = [];
  const styles = /*@__PURE__*/doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);
  let appLoadFallback;
  let isBootstrapping = true;
  let i = 0;
  Object.assign(plt, options);
  plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncQueue) {
    if (options.syncQueue) {
      plt.$flags$ |= 4 /* PLATFORM_FLAGS.queueSync */;
    }
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateClientSide) {
    // If the app is already hydrated there is not point to disable the
    // async queue. This will improve the first input delay
    plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateClientSide && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom) {
    for (; i < styles.length; i++) {
      registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);
    }
  }
  let hasSlotRelocation = false;
  lazyBundles.map(lazyBundle => {
    lazyBundle[1].map(compactMeta => {
      var _a;
      const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1],
        $members$: compactMeta[2],
        $listeners$: compactMeta[3]
      };
      // Check if we are using slots outside the shadow DOM in this component.
      // We'll use this information later to add styles for `slot-fb` elements
      if (cmpMeta.$flags$ & 4 /* CMP_FLAGS.hasSlotRelocation */) {
        hasSlotRelocation = true;
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.member) {
        cmpMeta.$members$ = compactMeta[2];
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListener) {
        cmpMeta.$listeners$ = compactMeta[3];
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.reflect) {
        cmpMeta.$attrsToReflect$ = [];
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.watchCallback) {
        cmpMeta.$watchers$ = (_a = compactMeta[4]) !== null && _a !== void 0 ? _a : {};
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
        // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
        cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;
      }
      const tagName = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.transformTagName && options.transformTagName ? options.transformTagName(cmpMeta.$tagName$) : cmpMeta.$tagName$;
      const HostElement = class extends HTMLElement {
        // StencilLazyHost
        constructor(self) {
          // @ts-ignore
          super(self);
          self = this;
          registerHost(self, cmpMeta);
          if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
            // this component is using shadow dom
            // and this browser supports shadow dom
            // add the read-only property "shadowRoot" to the host element
            // adding the shadow root build conditionals to minimize runtime
            if (supportsShadow) {
              if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDelegatesFocus) {
                self.attachShadow({
                  mode: 'open',
                  delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */)
                });
              } else {
                self.attachShadow({
                  mode: 'open'
                });
              }
            } else if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydrateServerSide && !('shadowRoot' in self)) {
              self.shadowRoot = self;
            }
          }
        }
        connectedCallback() {
          if (appLoadFallback) {
            clearTimeout(appLoadFallback);
            appLoadFallback = null;
          }
          if (isBootstrapping) {
            // connectedCallback will be processed once all components have been registered
            deferredConnectedCallbacks.push(this);
          } else {
            plt.jmp(() => connectedCallback(this));
          }
        }
        disconnectedCallback() {
          plt.jmp(() => disconnectedCallback(this));
        }
        componentOnReady() {
          return getHostRef(this).$onReadyPromise$;
        }
      };
      // TODO(STENCIL-914): this check and `else` block can go away and be replaced by just the `scoped` check
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.experimentalSlotFixes) {
        // This check is intentionally not combined with the surrounding `experimentalSlotFixes` check
        // since, moving forward, we only want to patch the pseudo shadow DOM when the component is scoped
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scoped && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
          patchPseudoShadowDom(HostElement.prototype, cmpMeta);
        }
      } else {
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.slotChildNodesFix) {
          patchChildSlotNodes(HostElement.prototype, cmpMeta);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.cloneNodeFix) {
          patchCloneNode(HostElement.prototype);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.appendChildSlotFix) {
          patchSlotAppendChild(HostElement.prototype);
        }
        if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.scopedSlotTextContentFix && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {
          patchTextContent(HostElement.prototype);
        }
      }
      // if the component is formAssociated we need to set that on the host
      // element so that it will be ready for `attachInternals` to be called on
      // it later on
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.formAssociated && cmpMeta.$flags$ & 64 /* CMP_FLAGS.formAssociated */) {
        HostElement.formAssociated = true;
      }
      if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hotModuleReplacement) {
        // if we're in an HMR dev build then we need to set up the callback
        // which will carry out the work of actually replacing the module for
        // this particular component
        HostElement.prototype['s-hmr'] = function (hmrVersionId) {
          hmrStart(this, cmpMeta, hmrVersionId);
        };
      }
      cmpMeta.$lazyBundleId$ = lazyBundle[0];
      if (!exclude.includes(tagName) && !customElements.get(tagName)) {
        cmpTags.push(tagName);
        customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));
      }
    });
  });
  // Only bother generating CSS if we have components
  // TODO(STENCIL-1118): Add test cases for CSS content based on conditionals
  if (cmpTags.length > 0) {
    // Add styles for `slot-fb` elements if any of our components are using slots outside the Shadow DOM
    if (hasSlotRelocation) {
      dataStyles.innerHTML += SLOT_FB_CSS;
    }
    // Add hydration styles
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.invisiblePrehydration && (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydratedClass || _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hydratedAttribute)) {
      dataStyles.innerHTML += cmpTags + HYDRATED_CSS;
    }
    // If we have styles, add them to the DOM
    if (dataStyles.innerHTML.length) {
      dataStyles.setAttribute('data-styles', '');
      // Apply CSP nonce to the style tag if it exists
      const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
      if (nonce != null) {
        dataStyles.setAttribute('nonce', nonce);
      }
      // Insert the styles into the document head
      // NOTE: this _needs_ to happen last so we can ensure the nonce (and other attributes) are applied
      head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);
    }
  }
  // Process deferred connectedCallbacks now all components have been registered
  isBootstrapping = false;
  if (deferredConnectedCallbacks.length) {
    deferredConnectedCallbacks.map(host => host.connectedCallback());
  } else {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.profile) {
      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30, 'timeout'));
    } else {
      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));
    }
  }
  // Fallback appLoad event
  endBootstrap();
};
const Fragment = (_, children) => children;
const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListener && listeners) {
    // this is called immediately within the element's constructor
    // initialize our event listeners on the host element
    // we do this now so that we can listen to events that may
    // have fired even before the instance is ready
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListenerTargetParent) {
      // this component may have event listeners that should be attached to the parent
      if (attachParentListeners) {
        // this is being ran from within the connectedCallback
        // which is important so that we know the host element actually has a parent element
        // filter out the listeners to only have the ones that ARE being attached to the parent
        listeners = listeners.filter(([flags]) => flags & 32 /* LISTENER_FLAGS.TargetParent */);
      } else {
        // this is being ran from within the component constructor
        // everything BUT the parent element listeners should be attached at this time
        // filter out the listeners that are NOT being attached to the parent
        listeners = listeners.filter(([flags]) => !(flags & 32 /* LISTENER_FLAGS.TargetParent */));
      }
    }
    listeners.map(([flags, name, method]) => {
      const target = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
const hostListenerProxy = (hostRef, methodName) => ev => {
  try {
    if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad) {
      if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {
        // instance is ready, let's call it's member method for this event
        hostRef.$lazyInstance$[methodName](ev);
      } else {
        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
      }
    } else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e) {
    consoleError(e);
  }
};
const getHostListenerTarget = (elm, flags) => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListenerTargetDocument && flags & 4 /* LISTENER_FLAGS.TargetDocument */) return doc;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListenerTargetWindow && flags & 8 /* LISTENER_FLAGS.TargetWindow */) return win;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListenerTargetBody && flags & 16 /* LISTENER_FLAGS.TargetBody */) return doc.body;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hostListenerTargetParent && flags & 32 /* LISTENER_FLAGS.TargetParent */) return elm.parentElement;
  return elm;
};
// prettier-ignore
const hostListenerOpts = flags => supportsListenerOptions ? {
  passive: (flags & 1 /* LISTENER_FLAGS.Passive */) !== 0,
  capture: (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0
} : (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;
/**
 * Assigns the given value to the nonce property on the runtime platform object.
 * During runtime, this value is used to set the nonce attribute on all dynamically created script and style tags.
 * @param nonce The value to be assigned to the platform nonce property.
 * @returns void
 */
const setNonce = nonce => plt.$nonce$ = nonce;
const setPlatformOptions = opts => Object.assign(plt, opts);
/**
 * Updates the DOM generated on the server with annotations such as node attributes and
 * comment nodes to facilitate future client-side hydration. These annotations are used for things
 * like moving elements back to their original hosts if using Shadow DOM on the client, and for quickly
 * reconstructing the vNode representations of the DOM.
 *
 * @param doc The DOM generated by the server.
 * @param staticComponents Any components that should be considered static and do not need client-side hydration.
 */
const insertVdomAnnotations = (doc, staticComponents) => {
  if (doc != null) {
    const docData = {
      hostIds: 0,
      rootLevelIds: 0,
      staticComponents: new Set(staticComponents)
    };
    const orgLocationNodes = [];
    parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);
    orgLocationNodes.forEach(orgLocationNode => {
      var _a, _b;
      if (orgLocationNode != null && orgLocationNode['s-nr']) {
        const nodeRef = orgLocationNode['s-nr'];
        let hostId = nodeRef['s-host-id'];
        let nodeId = nodeRef['s-node-id'];
        let childId = `${hostId}.${nodeId}`;
        if (hostId == null) {
          hostId = 0;
          docData.rootLevelIds++;
          nodeId = docData.rootLevelIds;
          childId = `${hostId}.${nodeId}`;
          if (nodeRef.nodeType === 1 /* NODE_TYPE.ElementNode */) {
            nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);
          } else if (nodeRef.nodeType === 3 /* NODE_TYPE.TextNode */) {
            if (hostId === 0) {
              const textContent = (_a = nodeRef.nodeValue) === null || _a === void 0 ? void 0 : _a.trim();
              if (textContent === '') {
                // useless whitespace node at the document root
                orgLocationNode.remove();
                return;
              }
            }
            const commentBeforeTextNode = doc.createComment(childId);
            commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;
            (_b = nodeRef.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(commentBeforeTextNode, nodeRef);
          }
        }
        let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;
        const orgLocationParentNode = orgLocationNode.parentElement;
        if (orgLocationParentNode) {
          if (orgLocationParentNode['s-en'] === '') {
            // ending with a "." means that the parent element
            // of this node's original location is a SHADOW dom element
            // and this node is apart of the root level light dom
            orgLocationNodeId += `.`;
          } else if (orgLocationParentNode['s-en'] === 'c') {
            // ending with a ".c" means that the parent element
            // of this node's original location is a SCOPED element
            // and this node is apart of the root level light dom
            orgLocationNodeId += `.c`;
          }
        }
        orgLocationNode.nodeValue = orgLocationNodeId;
      }
    });
  }
};
/**
 * Recursively parses a node generated by the server and its children to set host and child id
 * attributes read during client-side hydration. This function also tracks whether each node is
 * an original location reference node meaning that a node has been moved via slot relocation.
 *
 * @param doc The DOM generated by the server.
 * @param node The node to parse.
 * @param docData An object containing metadata about the document.
 * @param orgLocationNodes An array of nodes that have been moved via slot relocation.
 */
const parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {
  if (node == null) {
    return;
  }
  if (node['s-nr'] != null) {
    orgLocationNodes.push(node);
  }
  if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {
    node.childNodes.forEach(childNode => {
      const hostRef = getHostRef(childNode);
      if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {
        const cmpData = {
          nodeIds: 0
        };
        insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);
      }
      parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);
    });
  }
};
/**
 * Insert attribute annotations on an element for its host ID and, potentially, its child ID.
 * Also makes calls to insert annotations on the element's children, keeping track of the depth of
 * the component tree.
 *
 * @param doc The DOM generated by the server.
 * @param hostElm The element to insert annotations for.
 * @param vnode The vNode representation of the element.
 * @param docData An object containing metadata about the document.
 * @param cmpData An object containing metadata about the component.
 */
const insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {
  if (vnode != null) {
    const hostId = ++docData.hostIds;
    hostElm.setAttribute(HYDRATE_ID, hostId);
    if (hostElm['s-cr'] != null) {
      hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;
    }
    if (vnode.$children$ != null) {
      const depth = 0;
      vnode.$children$.forEach((vnodeChild, index) => {
        insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);
      });
    }
    // If this element does not already have a child ID and has a sibling comment node
    // representing a slot, we use the content of the comment to set the child ID attribute
    // on the host element.
    if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute(HYDRATE_CHILD_ID)) {
      const parent = hostElm.parentElement;
      if (parent && parent.childNodes) {
        const parentChildNodes = Array.from(parent.childNodes);
        const comment = parentChildNodes.find(node => node.nodeType === 8 /* NODE_TYPE.CommentNode */ && node['s-sr']);
        if (comment) {
          const index = parentChildNodes.indexOf(hostElm) - 1;
          vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);
        }
      }
    }
  }
};
/**
 * Recursively analyzes the type of a child vNode and inserts annotations on the vNodes's element based on its type.
 * Element nodes receive a child ID attribute, text nodes have a comment with the child ID inserted before them,
 * and comment nodes representing a slot have their node value set to a slot node ID containing the child ID.
 *
 * @param doc The DOM generated by the server.
 * @param vnodeChild The vNode to insert annotations for.
 * @param cmpData An object containing metadata about the component.
 * @param hostId The host ID of this element's parent.
 * @param depth How deep this element sits in the component tree relative to its parent.
 * @param index The index of this element in its parent's children array.
 */
const insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {
  const childElm = vnodeChild.$elm$;
  if (childElm == null) {
    return;
  }
  const nodeId = cmpData.nodeIds++;
  const childId = `${hostId}.${nodeId}.${depth}.${index}`;
  childElm['s-host-id'] = hostId;
  childElm['s-node-id'] = nodeId;
  if (childElm.nodeType === 1 /* NODE_TYPE.ElementNode */) {
    childElm.setAttribute(HYDRATE_CHILD_ID, childId);
  } else if (childElm.nodeType === 3 /* NODE_TYPE.TextNode */) {
    const parentNode = childElm.parentNode;
    const nodeName = parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeName;
    if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {
      const textNodeId = `${TEXT_NODE_ID}.${childId}`;
      const commentBeforeTextNode = doc.createComment(textNodeId);
      parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(commentBeforeTextNode, childElm);
    }
  } else if (childElm.nodeType === 8 /* NODE_TYPE.CommentNode */) {
    if (childElm['s-sr']) {
      const slotName = childElm['s-sn'] || '';
      const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;
      childElm.nodeValue = slotNodeId;
    }
  }
  if (vnodeChild.$children$ != null) {
    // Increment depth each time we recur deeper into the tree
    const childDepth = depth + 1;
    vnodeChild.$children$.forEach((vnode, index) => {
      insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);
    });
  }
};
var _a;
/**
 * A WeakMap mapping runtime component references to their corresponding host reference
 * instances.
 *
 * **Note**: If we're in an HMR context we need to store a reference to this
 * value on `window` in order to maintain the mapping of {@link d.RuntimeRef}
 * to {@link d.HostRef} across HMR updates.
 *
 * This is necessary because when HMR updates for a component are processed by
 * the browser-side dev server client the JS bundle for that component is
 * re-fetched. Since the module containing {@link hostRefs} is included in
 * that bundle, if we do not store a reference to it the new iteration of the
 * component will not have access to the previous hostRef map, leading to a
 * bug where the new version of the component cannot properly initialize.
 */
const hostRefs = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hotModuleReplacement ? (_a = window).__STENCIL_HOSTREFS__ || (_a.__STENCIL_HOSTREFS__ = new WeakMap()) : new WeakMap();
/**
 * Given a {@link d.RuntimeRef} retrieve the corresponding {@link d.HostRef}
 *
 * @param ref the runtime ref of interest
 * @returns the Host reference (if found) or undefined
 */
const getHostRef = ref => hostRefs.get(ref);
/**
 * Register a lazy instance with the {@link hostRefs} object so it's
 * corresponding {@link d.HostRef} can be retrieved later.
 *
 * @param lazyInstance the lazy instance of interest
 * @param hostRef that instances `HostRef` object
 * @returns a reference to the host ref WeakMap
 */
const registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
/**
 * Register a host element for a Stencil component, setting up various metadata
 * and callbacks based on {@link BUILD} flags as well as the component's runtime
 * metadata.
 *
 * @param hostElement the host element to register
 * @param cmpMeta runtime metadata for that component
 * @returns a reference to the host ref WeakMap
 */
const registerHost = (hostElement, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: hostElement,
    $cmpMeta$: cmpMeta,
    $instanceValues$: new Map()
  };
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev) {
    hostRef.$renderCount$ = 0;
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.method && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.lazyLoad) {
    hostRef.$onInstancePromise$ = new Promise(r => hostRef.$onInstanceResolve$ = r);
  }
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncLoading) {
    hostRef.$onReadyPromise$ = new Promise(r => hostRef.$onReadyResolve$ = r);
    hostElement['s-p'] = [];
    hostElement['s-rc'] = [];
  }
  addHostEventListeners(hostElement, hostRef, cmpMeta.$listeners$, false);
  return hostRefs.set(hostElement, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e, el) => (customError || console.error)(e, el);
const STENCIL_DEV_MODE = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isTesting ? ['STENCIL:'] // E2E testing
: ['%cstencil', 'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px'];
const consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);
const consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);
const consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);
const setErrorHandler = handler => customError = handler;
const cmpModules = /*@__PURE__*/new Map();
const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
  // loadModuleImport
  const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
  const bundleId = cmpMeta.$lazyBundleId$;
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.isDev && typeof bundleId !== 'string') {
    consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode "${hostRef.$modeName$}", but it does not exist.`);
    return undefined;
  }
  const module = !_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;
  if (module) {
    return module[exportName];
  }
  /*!__STENCIL_STATIC_IMPORT_SWITCH__*/
  return __webpack_require__(41993)(`./${bundleId}.entry.js${_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then(importedModule => {
    if (!_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.hotModuleReplacement) {
      cmpModules.set(bundleId, importedModule);
    }
    return importedModule[exportName];
  }, consoleError);
};
const styles = /*@__PURE__*/new Map();
const modeResolutionChain = [];
const win = typeof window !== 'undefined' ? window : {};
const doc = win.document || {
  head: {}
};
const H = win.HTMLElement || class {};
const plt = {
  $flags$: 0,
  $resourcesUrl$: '',
  jmp: h => h(),
  raf: h => requestAnimationFrame(h),
  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
const setPlatformHelpers = helpers => {
  Object.assign(plt, helpers);
};
const supportsShadow =
// TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDomShim && _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.shadowDom ? /*@__PURE__*/(() => (doc.head.attachShadow + '').indexOf('[native') > -1)() : true;
const supportsListenerOptions = /*@__PURE__*/(() => {
  let supportsListenerOptions = false;
  try {
    doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {
      get() {
        supportsListenerOptions = true;
      }
    }));
  } catch (e) {}
  return supportsListenerOptions;
})();
const promiseResolve = v => Promise.resolve(v);
const supportsConstructableStylesheets = _stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.constructableCSS ? /*@__PURE__*/(() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === 'function';
  } catch (e) {}
  return false;
})() : false;
const queueDomReads = [];
const queueDomWrites = [];
const queueDomWritesLow = [];
const queueTask = (queue, write) => cb => {
  queue.push(cb);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {
      nextTick(flush);
    } else {
      plt.raf(flush);
    }
  }
};
const consume = queue => {
  for (let i = 0; i < queue.length; i++) {
    try {
      queue[i](performance.now());
    } catch (e) {
      consoleError(e);
    }
  }
  queue.length = 0;
};
const consumeTimeout = (queue, timeout) => {
  let i = 0;
  let ts = 0;
  while (i < queue.length && (ts = performance.now()) < timeout) {
    try {
      queue[i++](ts);
    } catch (e) {
      consoleError(e);
    }
  }
  if (i === queue.length) {
    queue.length = 0;
  } else if (i !== 0) {
    queue.splice(0, i);
  }
};
const flush = () => {
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncQueue) {
    queueCongestion++;
  }
  // always force a bunch of medium callbacks to run, but still have
  // a throttle on how many can run in a certain time
  // DOM READS!!!
  consume(queueDomReads);
  // DOM WRITES!!!
  if (_stencil_core_internal_app_data__WEBPACK_IMPORTED_MODULE_1__.BUILD.asyncQueue) {
    const timeout = (plt.$flags$ & 6 /* PLATFORM_FLAGS.queueMask */) === 2 /* PLATFORM_FLAGS.appLoaded */ ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0)) : Infinity;
    consumeTimeout(queueDomWrites, timeout);
    consumeTimeout(queueDomWritesLow, timeout);
    if (queueDomWrites.length > 0) {
      queueDomWritesLow.push(...queueDomWrites);
      queueDomWrites.length = 0;
    }
    if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
      // still more to do yet, but we've run out of time
      // let's let this thing cool off and try again in the next tick
      plt.raf(flush);
    } else {
      queueCongestion = 0;
    }
  } else {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      // still more to do yet, but we've run out of time
      // let's let this thing cool off and try again in the next tick
      plt.raf(flush);
    }
  }
};
const nextTick = cb => promiseResolve().then(cb);
const readTask = /*@__PURE__*/queueTask(queueDomReads, false);
const writeTask = /*@__PURE__*/queueTask(queueDomWrites, true);



/***/ }),

/***/ 41993:
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/client/ lazy ^\.\/.*\.entry\.js.*$ include: \.entry\.js$ exclude: \.system\.entry\.js$ namespace object ***!
  \*****************************************************************************************************************************************************/
/***/ ((module) => {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(() => {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = () => ([]);
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 41993;
module.exports = webpackEmptyAsyncContext;

/***/ }),

/***/ 18769:
/*!***************************************************************!*\
  !*** ./node_modules/@stencil/core/internal/app-data/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BUILD: () => (/* binding */ BUILD),
/* harmony export */   Env: () => (/* binding */ Env),
/* harmony export */   NAMESPACE: () => (/* binding */ NAMESPACE)
/* harmony export */ });
/**
 * A collection of default build flags for a Stencil project.
 *
 * This collection can be found throughout the Stencil codebase, often imported from the `@app-data` module like so:
 * ```ts
 * import { BUILD } from '@app-data';
 * ```
 * and is used to determine if a portion of the output of a Stencil _project_'s compilation step can be eliminated.
 *
 * e.g. When `BUILD.allRenderFn` evaluates to `false`, the compiler will eliminate conditional statements like:
 * ```ts
 * if (BUILD.allRenderFn) {
 *   // some code that will be eliminated if BUILD.allRenderFn is false
 * }
 * ```
 *
 * `@app-data`, the module that `BUILD` is imported from, is an alias for the `@stencil/core/internal/app-data`, and is
 * partially referenced by {@link STENCIL_APP_DATA_ID}. The `src/compiler/bundle/app-data-plugin.ts` references
 * `STENCIL_APP_DATA_ID` uses it to replace these defaults with {@link BuildConditionals} that are derived from a
 * Stencil project's contents (i.e. metadata from the components). This replacement happens at a Stencil project's
 * compile time. Such code can be found at `src/compiler/app-core/app-data.ts`.
 */
const BUILD = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  formAssociated: false,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  scriptDataOpts: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: false,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: false,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: false,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: false
};
const Env = {};
const NAMESPACE = /* default */'app';


/***/ }),

/***/ 71670:
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _asyncToGenerator)
/* harmony export */ });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

/***/ })

}])
//# sourceMappingURL=libs_foundation_wink_ng_src_index_ts-_bd041.js.map
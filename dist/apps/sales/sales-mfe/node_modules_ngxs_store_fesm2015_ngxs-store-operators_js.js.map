{"version":3,"file":"node_modules_ngxs_store_fesm2015_ngxs-store-operators_js.js","mappings":"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","sources":["./node_modules/@ngxs/store/fesm2015/ngxs-store-operators.js"],"sourcesContent":["/**\n * @param items - Specific items to append to the end of an array\n */\nfunction append(items) {\n    return function appendOperator(existing) {\n        // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n        // just return `existing`\n        const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n        if (itemsNotProvidedButExistingIs) {\n            return existing;\n        }\n        if (Array.isArray(existing)) {\n            return existing.concat(items);\n        }\n        // For example if some property is added dynamically\n        // and didn't exist before thus it's not `ArrayLike`\n        return items;\n    };\n}\n\nfunction compose(...operators) {\n    return function composeOperator(existing) {\n        return operators.reduce((accumulator, operator) => operator(accumulator), existing);\n    };\n}\n\nfunction isStateOperator(value) {\n    return typeof value === 'function';\n}\nfunction isUndefined(value) {\n    return typeof value === 'undefined';\n}\nfunction isPredicate(value) {\n    return typeof value === 'function';\n}\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\nfunction invalidIndex(index) {\n    return Number.isNaN(index) || index === -1;\n}\nfunction isNil(value) {\n    return value === null || isUndefined(value);\n}\n\nfunction retrieveValue(operatorOrValue, existing) {\n    // If state operator is a function\n    // then call it with an original value\n    if (isStateOperator(operatorOrValue)) {\n        const value = operatorOrValue(existing);\n        return value;\n    }\n    // If operator or value was not provided\n    // e.g. `elseOperatorOrValue` is `undefined`\n    // then we just return an original value\n    if (isUndefined(operatorOrValue)) {\n        return existing;\n    }\n    return operatorOrValue;\n}\n/**\n * @param condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param trueOperatorOrValue - Any value or a state operator\n * @param elseOperatorOrValue - Any value or a state operator\n */\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\n    return function iifOperator(existing) {\n        // Convert the value to a boolean\n        let result = !!condition;\n        // but if it is a function then run it to get the result\n        if (isPredicate(condition)) {\n            result = condition(existing);\n        }\n        if (result) {\n            return retrieveValue(trueOperatorOrValue, existing);\n        }\n        return retrieveValue(elseOperatorOrValue, existing);\n    };\n}\n\n/**\n * @param value - Value to insert\n * @param [beforePosition] -  Specified index to insert value before, optional\n */\nfunction insertItem(value, beforePosition) {\n    return function insertItemOperator(existing) {\n        // Have to check explicitly for `null` and `undefined`\n        // because `value` can be `0`, thus `!value` will return `true`\n        if (isNil(value) && existing) {\n            return existing;\n        }\n        // Property may be dynamic and might not existed before\n        if (!Array.isArray(existing)) {\n            return [value];\n        }\n        const clone = existing.slice();\n        let index = 0;\n        // No need to call `isNumber`\n        // as we are checking `> 0` not `>= 0`\n        // everything except number will return false here\n        if (beforePosition > 0) {\n            index = beforePosition;\n        }\n        clone.splice(index, 0, value);\n        return clone;\n    };\n}\n\nfunction patch(patchObject) {\n    return function patchStateOperator(existing) {\n        let clone = null;\n        for (const k in patchObject) {\n            const newValue = patchObject[k];\n            const existingPropValue = existing === null || existing === void 0 ? void 0 : existing[k];\n            const newPropValue = isStateOperator(newValue)\n                ? newValue(existingPropValue)\n                : newValue;\n            if (newPropValue !== existingPropValue) {\n                if (!clone) {\n                    clone = Object.assign({}, existing);\n                }\n                clone[k] = newPropValue;\n            }\n        }\n        return clone || existing;\n    };\n}\n\n/**\n * @param selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n */\nfunction updateItem(selector, operatorOrValue) {\n    return function updateItemOperator(existing) {\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return existing;\n        }\n        let value = null;\n        // Need to check if the new item value will change the existing item value\n        // then, only if it will change it then clone the array and set the item\n        const theOperatorOrValue = operatorOrValue;\n        if (isStateOperator(theOperatorOrValue)) {\n            value = theOperatorOrValue(existing[index]);\n        }\n        else {\n            value = theOperatorOrValue;\n        }\n        // If the value hasn't been mutated\n        // then we just return `existing` array\n        if (value === existing[index]) {\n            return existing;\n        }\n        const clone = existing.slice();\n        clone[index] = value;\n        return clone;\n    };\n}\n\n/**\n * @param selector - index or predicate to remove an item from an array by\n */\nfunction removeItem(selector) {\n    return function removeItemOperator(existing) {\n        let index = -1;\n        if (isPredicate(selector)) {\n            index = existing.findIndex(selector);\n        }\n        else if (isNumber(selector)) {\n            index = selector;\n        }\n        if (invalidIndex(index)) {\n            return existing;\n        }\n        const clone = existing.slice();\n        clone.splice(index, 1);\n        return clone;\n    };\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { append, compose, iif, insertItem, isPredicate, isStateOperator, patch, removeItem, updateItem };\n"],"names":["append","items","appendOperator","existing","itemsNotProvidedButExistingIs","length","Array","isArray","concat","compose","operators","composeOperator","reduce","accumulator","operator","isStateOperator","value","isUndefined","isPredicate","isNumber","invalidIndex","index","Number","isNaN","isNil","retrieveValue","operatorOrValue","iif","condition","trueOperatorOrValue","elseOperatorOrValue","iifOperator","result","insertItem","beforePosition","insertItemOperator","clone","slice","splice","patch","patchObject","patchStateOperator","k","newValue","existingPropValue","newPropValue","Object","assign","updateItem","selector","updateItemOperator","findIndex","theOperatorOrValue","removeItem","removeItemOperator"],"sourceRoot":"webpack:///","x_google_ignoreList":[0]}
{"version":3,"file":"node_modules_angular_core_fesm2022_rxjs-interop_mjs-_b06f1.js","mappings":"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","sources":["./node_modules/rxjs/dist/esm/internal/ReplaySubject.js","./node_modules/rxjs/dist/esm/internal/operators/takeUntil.js","./node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["import { Subject } from './Subject';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\nexport class ReplaySubject extends Subject {\n    constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {\n        super();\n        this._bufferSize = _bufferSize;\n        this._windowTime = _windowTime;\n        this._timestampProvider = _timestampProvider;\n        this._buffer = [];\n        this._infiniteTimeWindow = true;\n        this._infiniteTimeWindow = _windowTime === Infinity;\n        this._bufferSize = Math.max(1, _bufferSize);\n        this._windowTime = Math.max(1, _windowTime);\n    }\n    next(value) {\n        const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n        if (!isStopped) {\n            _buffer.push(value);\n            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n        }\n        this._trimBuffer();\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        this._throwIfClosed();\n        this._trimBuffer();\n        const subscription = this._innerSubscribe(subscriber);\n        const { _infiniteTimeWindow, _buffer } = this;\n        const copy = _buffer.slice();\n        for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n            subscriber.next(copy[i]);\n        }\n        this._checkFinalizedStatuses(subscriber);\n        return subscription;\n    }\n    _trimBuffer() {\n        const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n        const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n        if (!_infiniteTimeWindow) {\n            const now = _timestampProvider.now();\n            let last = 0;\n            for (let i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {\n                last = i;\n            }\n            last && _buffer.splice(0, last + 1);\n        }\n    }\n}\n","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\nexport function takeUntil(notifier) {\n    return operate((source, subscriber) => {\n        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\n","/**\n * @license Angular v17.1.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, ɵRuntimeError, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toObservable` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => {\n            if (options?.rejectErrors) {\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n                // the error to end up as an uncaught exception.\n                throw error;\n            }\n            state.set({ kind: 2 /* StateKind.Error */, error });\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { takeUntilDestroyed, toObservable, toSignal };\n"],"names":["Subject","dateTimestampProvider","ReplaySubject","constructor","_bufferSize","Infinity","_windowTime","_timestampProvider","_buffer","_infiniteTimeWindow","Math","max","next","value","isStopped","push","now","_trimBuffer","_subscribe","subscriber","_throwIfClosed","subscription","_innerSubscribe","copy","slice","i","length","closed","_checkFinalizedStatuses","adjustedBufferSize","splice","last","operate","createOperatorSubscriber","innerFrom","noop","takeUntil","notifier","source","subscribe","complete","assertInInjectionContext","inject","DestroyRef","Injector","effect","untracked","assertNotInReactiveContext","signal","ɵRuntimeError","computed","Observable","takeUntilDestroyed","destroyRef","destroyed$","observer","unregisterFn","onDestroy","bind","pipe","toObservable","options","injector","subject","watcher","err","error","manualCleanup","get","destroy","asObservable","toSignal","ngDevMode","requiresCleanup","cleanupRef","state","requireSync","kind","initialValue","sub","set","rejectErrors","unsubscribe","current"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2]}
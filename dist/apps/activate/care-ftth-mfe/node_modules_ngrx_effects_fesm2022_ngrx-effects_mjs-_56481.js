(self["webpackChunkcare_ftth_mfe"] = self["webpackChunkcare_ftth_mfe"] || []).push([["node_modules_ngrx_effects_fesm2022_ngrx-effects_mjs-_56481"],{

/***/ 1575:
/*!**************************************************************!*\
  !*** ./node_modules/@ngrx/effects/fesm2022/ngrx-effects.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Actions: () => (/* binding */ Actions),
/* harmony export */   EFFECTS_ERROR_HANDLER: () => (/* binding */ EFFECTS_ERROR_HANDLER),
/* harmony export */   EffectSources: () => (/* binding */ EffectSources),
/* harmony export */   EffectsFeatureModule: () => (/* binding */ EffectsFeatureModule),
/* harmony export */   EffectsModule: () => (/* binding */ EffectsModule),
/* harmony export */   EffectsRootModule: () => (/* binding */ EffectsRootModule),
/* harmony export */   EffectsRunner: () => (/* binding */ EffectsRunner),
/* harmony export */   ROOT_EFFECTS_INIT: () => (/* binding */ ROOT_EFFECTS_INIT),
/* harmony export */   USER_PROVIDED_EFFECTS: () => (/* binding */ USER_PROVIDED_EFFECTS),
/* harmony export */   act: () => (/* binding */ act),
/* harmony export */   concatLatestFrom: () => (/* reexport safe */ _ngrx_operators__WEBPACK_IMPORTED_MODULE_4__.concatLatestFrom),
/* harmony export */   createEffect: () => (/* binding */ createEffect),
/* harmony export */   defaultEffectsErrorHandler: () => (/* binding */ defaultEffectsErrorHandler),
/* harmony export */   getEffectsMetadata: () => (/* binding */ getEffectsMetadata),
/* harmony export */   mergeEffects: () => (/* binding */ mergeEffects),
/* harmony export */   ofType: () => (/* binding */ ofType),
/* harmony export */   provideEffects: () => (/* binding */ provideEffects),
/* harmony export */   rootEffectsInit: () => (/* binding */ rootEffectsInit)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 44946);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/operators */ 37934);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ 33829);
/* harmony import */ var _ngrx_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ngrx/store */ 25288);
/* harmony import */ var _ngrx_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ngrx/operators */ 92666);








const DEFAULT_EFFECT_CONFIG = {
  dispatch: true,
  functional: false,
  useEffectsErrorHandler: true
};
const CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';

/**
 * @description
 *
 * Creates an effect from a source and an `EffectConfig`.
 *
 * @param source A function which returns an observable or observable factory.
 * @param config A `EffectConfig` to configure the effect. By default,
 * `dispatch` is true, `functional` is false, and `useEffectsErrorHandler` is
 * true.
 * @returns If `EffectConfig`#`functional` is true, returns the source function.
 * Else, returns the source function result. When `EffectConfig`#`dispatch` is
 * true, the source function result needs to be `Observable<Action>`.
 *
 * @usageNotes
 *
 * ### Class Effects
 *
 * ```ts
 * @Injectable()
 * export class FeatureEffects {
 *   // mapping to a different action
 *   readonly effect1$ = createEffect(
 *     () => this.actions$.pipe(
 *       ofType(FeatureActions.actionOne),
 *       map(() => FeatureActions.actionTwo())
 *     )
 *   );
 *
 *   // non-dispatching effect
 *   readonly effect2$ = createEffect(
 *     () => this.actions$.pipe(
 *       ofType(FeatureActions.actionTwo),
 *       tap(() => console.log('Action Two Dispatched'))
 *     ),
 *     { dispatch: false } // FeatureActions.actionTwo is not dispatched
 *   );
 *
 *   constructor(private readonly actions$: Actions) {}
 * }
 * ```
 *
 * ### Functional Effects
 *
 * ```ts
 * // mapping to a different action
 * export const loadUsers = createEffect(
 *   (actions$ = inject(Actions), usersService = inject(UsersService)) => {
 *     return actions$.pipe(
 *       ofType(UsersPageActions.opened),
 *       exhaustMap(() => {
 *         return usersService.getAll().pipe(
 *           map((users) => UsersApiActions.usersLoadedSuccess({ users })),
 *           catchError((error) =>
 *             of(UsersApiActions.usersLoadedFailure({ error }))
 *           )
 *         );
 *       })
 *     );
 *   },
 *   { functional: true }
 * );
 *
 * // non-dispatching functional effect
 * export const logDispatchedActions = createEffect(
 *   () => inject(Actions).pipe(tap(console.log)),
 *   { functional: true, dispatch: false }
 * );
 * ```
 */
function createEffect(source, config = {}) {
  const effect = config.functional ? source : source();
  const value = {
    ...DEFAULT_EFFECT_CONFIG,
    ...config // Overrides any defaults if values are provided
  };
  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {
    value
  });
  return effect;
}
function getCreateEffectMetadata(instance) {
  const propertyNames = Object.getOwnPropertyNames(instance);
  const metadata = propertyNames.filter(propertyName => {
    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {
      // If the property type has overridden `hasOwnProperty` we need to ensure
      // that the metadata is valid (containing a `dispatch` property)
      // https://github.com/ngrx/platform/issues/2975
      const property = instance[propertyName];
      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty('dispatch');
    }
    return false;
  }).map(propertyName => {
    const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];
    return {
      propertyName,
      ...metaData
    };
  });
  return metadata;
}
function getEffectsMetadata(instance) {
  return getSourceMetadata(instance).reduce((acc, {
    propertyName,
    dispatch,
    useEffectsErrorHandler
  }) => {
    acc[propertyName] = {
      dispatch,
      useEffectsErrorHandler
    };
    return acc;
  }, {});
}
function getSourceMetadata(instance) {
  return getCreateEffectMetadata(instance);
}
function getSourceForInstance(instance) {
  return Object.getPrototypeOf(instance);
}
function isClassInstance(obj) {
  return !!obj.constructor && obj.constructor.name !== 'Object' && obj.constructor.name !== 'Function';
}
function isClass(classOrRecord) {
  return typeof classOrRecord === 'function';
}
function getClasses(classesAndRecords) {
  return classesAndRecords.filter(isClass);
}
function isToken(tokenOrRecord) {
  return tokenOrRecord instanceof _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken || isClass(tokenOrRecord);
}
function mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {
  const source = getSourceForInstance(sourceInstance);
  const isClassBasedEffect = !!source && source.constructor.name !== 'Object';
  const sourceName = isClassBasedEffect ? source.constructor.name : null;
  const observables$ = getSourceMetadata(sourceInstance).map(({
    propertyName,
    dispatch,
    useEffectsErrorHandler
  }) => {
    const observable$ = typeof sourceInstance[propertyName] === 'function' ? sourceInstance[propertyName]() : sourceInstance[propertyName];
    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;
    if (dispatch === false) {
      return effectAction$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.ignoreElements)());
    }
    const materialized$ = effectAction$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.materialize)());
    return materialized$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.map)(notification => ({
      effect: sourceInstance[propertyName],
      notification,
      propertyName,
      sourceName,
      sourceInstance
    })));
  });
  return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.merge)(...observables$);
}
const MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;
function defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {
  return observable$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.catchError)(error => {
    if (errorHandler) errorHandler.handleError(error);
    if (retryAttemptLeft <= 1) {
      return observable$; // last attempt
    }
    // Return observable that produces this particular effect
    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);
  }));
}
class Actions extends rxjs__WEBPACK_IMPORTED_MODULE_0__.Observable {
  constructor(source) {
    super();
    if (source) {
      this.source = source;
    }
  }
  lift(operator) {
    const observable = new Actions();
    observable.source = this;
    observable.operator = operator;
    return observable;
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function Actions_Factory(t) {
    return new (t || Actions)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.ScannedActionsSubject));
  };
  /** @nocollapse */
  static #_2 = this.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
    token: Actions,
    factory: Actions.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](Actions, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: rxjs__WEBPACK_IMPORTED_MODULE_0__.Observable,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.ScannedActionsSubject]
    }]
  }], null);
})();
/**
 * `ofType` filters an Observable of `Actions` into an Observable of the actions
 * whose type strings are passed to it.
 *
 * For example, if `actions` has type `Actions<AdditionAction|SubstractionAction>`, and
 * the type of the `Addition` action is `add`, then
 * `actions.pipe(ofType('add'))` returns an `Observable<AdditionAction>`.
 *
 * Properly typing this function is hard and requires some advanced TS tricks
 * below.
 *
 * Type narrowing automatically works, as long as your `actions` object
 * starts with a `Actions<SomeUnionOfActions>` instead of generic `Actions`.
 *
 * For backwards compatibility, when one passes a single type argument
 * `ofType<T>('something')` the result is an `Observable<T>`. Note, that `T`
 * completely overrides any possible inference from 'something'.
 *
 * Unfortunately, for unknown 'actions: Actions' these types will produce
 * 'Observable<never>'. In such cases one has to manually set the generic type
 * like `actions.ofType<AdditionAction>('add')`.
 *
 * @usageNotes
 *
 * Filter the Actions stream on the "customers page loaded" action
 *
 * ```ts
 * import { ofType } from '@ngrx/effects';
 * import * fromCustomers from '../customers';
 *
 * this.actions$.pipe(
 *  ofType(fromCustomers.pageLoaded)
 * )
 * ```
 */
function ofType(...allowedTypes) {
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(action => allowedTypes.some(typeOrActionCreator => {
    if (typeof typeOrActionCreator === 'string') {
      // Comparing the string to type
      return typeOrActionCreator === action.type;
    }
    // We are filtering by ActionCreator
    return typeOrActionCreator.type === action.type;
  }));
}
const _ROOT_EFFECTS_GUARD = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('@ngrx/effects Internal Root Guard');
const USER_PROVIDED_EFFECTS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('@ngrx/effects User Provided Effects');
const _ROOT_EFFECTS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('@ngrx/effects Internal Root Effects');
const _ROOT_EFFECTS_INSTANCES = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('@ngrx/effects Internal Root Effects Instances');
const _FEATURE_EFFECTS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('@ngrx/effects Internal Feature Effects');
const _FEATURE_EFFECTS_INSTANCE_GROUPS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('@ngrx/effects Internal Feature Effects Instance Groups');
const EFFECTS_ERROR_HANDLER = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('@ngrx/effects Effects Error Handler', {
  providedIn: 'root',
  factory: () => defaultEffectsErrorHandler
});
const ROOT_EFFECTS_INIT = '@ngrx/effects/init';
const rootEffectsInit = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.createAction)(ROOT_EFFECTS_INIT);
function reportInvalidActions(output, reporter) {
  if (output.notification.kind === 'N') {
    const action = output.notification.value;
    const isInvalidAction = !isAction(action);
    if (isInvalidAction) {
      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));
    }
  }
}
function isAction(action) {
  return typeof action !== 'function' && action && action.type && typeof action.type === 'string';
}
function getEffectName({
  propertyName,
  sourceInstance,
  sourceName
}) {
  const isMethod = typeof sourceInstance[propertyName] === 'function';
  const isClassBasedEffect = !!sourceName;
  return isClassBasedEffect ? `"${sourceName}.${String(propertyName)}${isMethod ? '()' : ''}"` : `"${String(propertyName)}()"`;
}
function stringify(action) {
  try {
    return JSON.stringify(action);
  } catch {
    return action;
  }
}
const onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';
function isOnIdentifyEffects(instance) {
  return isFunction(instance, onIdentifyEffectsKey);
}
const onRunEffectsKey = 'ngrxOnRunEffects';
function isOnRunEffects(instance) {
  return isFunction(instance, onRunEffectsKey);
}
const onInitEffects = 'ngrxOnInitEffects';
function isOnInitEffects(instance) {
  return isFunction(instance, onInitEffects);
}
function isFunction(instance, functionName) {
  return instance && functionName in instance && typeof instance[functionName] === 'function';
}
class EffectSources extends rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject {
  constructor(errorHandler, effectsErrorHandler) {
    super();
    this.errorHandler = errorHandler;
    this.effectsErrorHandler = effectsErrorHandler;
  }
  addEffects(effectSourceInstance) {
    this.next(effectSourceInstance);
  }
  /**
   * @internal
   */
  toActions() {
    return this.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.groupBy)(effectsInstance => isClassInstance(effectsInstance) ? getSourceForInstance(effectsInstance) : effectsInstance), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.mergeMap)(source$ => {
      return source$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.groupBy)(effectsInstance));
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.mergeMap)(source$ => {
      const effect$ = source$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.exhaustMap)(sourceInstance => {
        return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.map)(output => {
        reportInvalidActions(output, this.errorHandler);
        return output.notification;
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(notification => notification.kind === 'N' && notification.value != null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.dematerialize)());
      // start the stream with an INIT action
      // do this only for the first Effect instance
      const init$ = source$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.take)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(isOnInitEffects), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.map)(instance => instance.ngrxOnInitEffects()));
      return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.merge)(effect$, init$);
    }));
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function EffectSources_Factory(t) {
    return new (t || EffectSources)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ErrorHandler), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](EFFECTS_ERROR_HANDLER));
  };
  /** @nocollapse */
  static #_2 = this.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
    token: EffectSources,
    factory: EffectSources.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](EffectSources, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ErrorHandler
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [EFFECTS_ERROR_HANDLER]
    }]
  }], null);
})();
function effectsInstance(sourceInstance) {
  if (isOnIdentifyEffects(sourceInstance)) {
    return sourceInstance.ngrxOnIdentifyEffects();
  }
  return '';
}
function resolveEffectSource(errorHandler, effectsErrorHandler) {
  return sourceInstance => {
    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);
    if (isOnRunEffects(sourceInstance)) {
      return sourceInstance.ngrxOnRunEffects(mergedEffects$);
    }
    return mergedEffects$;
  };
}
class EffectsRunner {
  get isStarted() {
    return !!this.effectsSubscription;
  }
  constructor(effectSources, store) {
    this.effectSources = effectSources;
    this.store = store;
    this.effectsSubscription = null;
  }
  start() {
    if (!this.effectsSubscription) {
      this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);
    }
  }
  ngOnDestroy() {
    if (this.effectsSubscription) {
      this.effectsSubscription.unsubscribe();
      this.effectsSubscription = null;
    }
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function EffectsRunner_Factory(t) {
    return new (t || EffectsRunner)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](EffectSources), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.Store));
  };
  /** @nocollapse */
  static #_2 = this.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjectable"]({
    token: EffectsRunner,
    factory: EffectsRunner.ɵfac,
    providedIn: 'root'
  });
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](EffectsRunner, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable,
    args: [{
      providedIn: 'root'
    }]
  }], () => [{
    type: EffectSources
  }, {
    type: _ngrx_store__WEBPACK_IMPORTED_MODULE_3__.Store
  }], null);
})();
class EffectsRootModule {
  constructor(sources, runner, store, rootEffectsInstances, storeRootModule, storeFeatureModule, guard) {
    this.sources = sources;
    runner.start();
    for (const effectsInstance of rootEffectsInstances) {
      sources.addEffects(effectsInstance);
    }
    store.dispatch({
      type: ROOT_EFFECTS_INIT
    });
  }
  addEffects(effectsInstance) {
    this.sources.addEffects(effectsInstance);
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function EffectsRootModule_Factory(t) {
    return new (t || EffectsRootModule)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](EffectSources), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](EffectsRunner), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.Store), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ROOT_EFFECTS_INSTANCES), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreRootModule, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreFeatureModule, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ROOT_EFFECTS_GUARD, 8));
  };
  /** @nocollapse */
  static #_2 = this.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
    type: EffectsRootModule
  });
  /** @nocollapse */
  static #_3 = this.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({});
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](EffectsRootModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{}]
  }], () => [{
    type: EffectSources
  }, {
    type: EffectsRunner
  }, {
    type: _ngrx_store__WEBPACK_IMPORTED_MODULE_3__.Store
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_ROOT_EFFECTS_INSTANCES]
    }]
  }, {
    type: _ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreRootModule,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
    }]
  }, {
    type: _ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreFeatureModule,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
    }]
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_ROOT_EFFECTS_GUARD]
    }]
  }], null);
})();
class EffectsFeatureModule {
  constructor(effectsRootModule, effectsInstanceGroups, storeRootModule, storeFeatureModule) {
    const effectsInstances = effectsInstanceGroups.flat();
    for (const effectsInstance of effectsInstances) {
      effectsRootModule.addEffects(effectsInstance);
    }
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function EffectsFeatureModule_Factory(t) {
    return new (t || EffectsFeatureModule)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](EffectsRootModule), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_FEATURE_EFFECTS_INSTANCE_GROUPS), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreRootModule, 8), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreFeatureModule, 8));
  };
  /** @nocollapse */
  static #_2 = this.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
    type: EffectsFeatureModule
  });
  /** @nocollapse */
  static #_3 = this.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({});
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](EffectsFeatureModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{}]
  }], () => [{
    type: EffectsRootModule
  }, {
    type: undefined,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
      args: [_FEATURE_EFFECTS_INSTANCE_GROUPS]
    }]
  }, {
    type: _ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreRootModule,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
    }]
  }, {
    type: _ngrx_store__WEBPACK_IMPORTED_MODULE_3__.StoreFeatureModule,
    decorators: [{
      type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional
    }]
  }], null);
})();
class EffectsModule {
  static forFeature(...featureEffects) {
    const effects = featureEffects.flat();
    const effectsClasses = getClasses(effects);
    return {
      ngModule: EffectsFeatureModule,
      providers: [effectsClasses, {
        provide: _FEATURE_EFFECTS,
        multi: true,
        useValue: effects
      }, {
        provide: USER_PROVIDED_EFFECTS,
        multi: true,
        useValue: []
      }, {
        provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,
        multi: true,
        useFactory: createEffectsInstances,
        deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]
      }]
    };
  }
  static forRoot(...rootEffects) {
    const effects = rootEffects.flat();
    const effectsClasses = getClasses(effects);
    return {
      ngModule: EffectsRootModule,
      providers: [effectsClasses, {
        provide: _ROOT_EFFECTS,
        useValue: [effects]
      }, {
        provide: _ROOT_EFFECTS_GUARD,
        useFactory: _provideForRootGuard
      }, {
        provide: USER_PROVIDED_EFFECTS,
        multi: true,
        useValue: []
      }, {
        provide: _ROOT_EFFECTS_INSTANCES,
        useFactory: createEffectsInstances,
        deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS]
      }]
    };
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function EffectsModule_Factory(t) {
    return new (t || EffectsModule)();
  };
  /** @nocollapse */
  static #_2 = this.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
    type: EffectsModule
  });
  /** @nocollapse */
  static #_3 = this.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({});
}
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](EffectsModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,
    args: [{}]
  }], null, null);
})();
function createEffectsInstances(effectsGroups, userProvidedEffectsGroups) {
  const effects = [];
  for (const effectsGroup of effectsGroups) {
    effects.push(...effectsGroup);
  }
  for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {
    effects.push(...userProvidedEffectsGroup);
  }
  return effects.map(effectsTokenOrRecord => isToken(effectsTokenOrRecord) ? (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(effectsTokenOrRecord) : effectsTokenOrRecord);
}
function _provideForRootGuard() {
  const runner = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(EffectsRunner, {
    optional: true,
    skipSelf: true
  });
  const rootEffects = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_ROOT_EFFECTS, {
    self: true
  });
  // check whether any effects are actually passed
  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);
  if (hasEffects && runner) {
    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);
  }
  return 'guarded';
}

/**
 * Wraps project fn with error handling making it safe to use in Effects.
 * Takes either a config with named properties that represent different possible
 * callbacks or project/error callbacks that are required.
 */
function act( /** Allow to take either config object or project/error functions */
configOrProject, errorFn) {
  const {
    project,
    error,
    complete,
    operator,
    unsubscribe
  } = typeof configOrProject === 'function' ? {
    project: configOrProject,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    error: errorFn,
    operator: rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.concatMap,
    complete: undefined,
    unsubscribe: undefined
  } : {
    ...configOrProject,
    operator: configOrProject.operator || rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.concatMap
  };
  return source => (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.defer)(() => {
    const subject = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.merge)(source.pipe(operator((input, index) => (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.defer)(() => {
      let completed = false;
      let errored = false;
      let projectedCount = 0;
      return project(input, index).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.materialize)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.map)(notification => {
        switch (notification.kind) {
          case 'E':
            errored = true;
            return {
              kind: 'N',
              value: error(notification.error, input)
            };
          case 'C':
            completed = true;
            return complete ? {
              kind: 'N',
              value: complete(projectedCount, input)
            } : undefined;
          default:
            ++projectedCount;
            return notification;
        }
      }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.filter)(n => n != null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.dematerialize)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.finalize)(() => {
        if (!completed && !errored && unsubscribe) {
          subject.next(unsubscribe(projectedCount, input));
        }
      }));
    }))), subject);
  });
}

/**
 * @usageNotes
 *
 * ### Providing effects at the root level
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [provideEffects(RouterEffects)],
 * });
 * ```
 *
 * ### Providing effects at the feature level
 *
 * ```ts
 * const booksRoutes: Route[] = [
 *   {
 *     path: '',
 *     providers: [provideEffects(BooksApiEffects)],
 *     children: [
 *       { path: '', component: BookListComponent },
 *       { path: ':id', component: BookDetailsComponent },
 *     ],
 *   },
 * ];
 * ```
 */
function provideEffects(...effects) {
  const effectsClassesAndRecords = effects.flat();
  const effectsClasses = getClasses(effectsClassesAndRecords);
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.makeEnvironmentProviders)([effectsClasses, {
    provide: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ENVIRONMENT_INITIALIZER,
    multi: true,
    useValue: () => {
      (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.ROOT_STORE_PROVIDER);
      (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.FEATURE_STATE_PROVIDER, {
        optional: true
      });
      const effectsRunner = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(EffectsRunner);
      const effectSources = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(EffectSources);
      const shouldInitEffects = !effectsRunner.isStarted;
      if (shouldInitEffects) {
        effectsRunner.start();
      }
      for (const effectsClassOrRecord of effectsClassesAndRecords) {
        const effectsInstance = isClass(effectsClassOrRecord) ? (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(effectsClassOrRecord) : effectsClassOrRecord;
        effectSources.addEffects(effectsInstance);
      }
      if (shouldInitEffects) {
        const store = (0,_angular_core__WEBPACK_IMPORTED_MODULE_2__.inject)(_ngrx_store__WEBPACK_IMPORTED_MODULE_3__.Store);
        store.dispatch(rootEffectsInit());
      }
    }
  }]);
}

/**
 * DO NOT EDIT
 *
 * This file is automatically generated at build
 */

/**
 * Generated bundle index. Do not edit.
 */



/***/ }),

/***/ 92666:
/*!******************************************************************!*\
  !*** ./node_modules/@ngrx/operators/fesm2022/ngrx-operators.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   concatLatestFrom: () => (/* binding */ concatLatestFrom),
/* harmony export */   tapResponse: () => (/* binding */ tapResponse)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ 44946);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/operators */ 37934);



/**
 * `concatLatestFrom` combines the source value
 * and the last available value from a lazily evaluated Observable
 * in a new array
 *
 * @usageNotes
 *
 * Select the active customer from the NgRx Store
 *
 * ```ts
 * import { concatLatestFrom } from '@ngrx/effects';
 * import * as fromCustomers from '../customers';
 *
 * this.actions$.pipe(
 *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))
 * )
 * ```
 *
 * Select a customer from the NgRx Store by its id that is available on the action
 *
 * ```ts
 * import { concatLatestFrom } from '@ngrx/effects';
 * import * fromCustomers from '../customers';
 *
 * this.actions$.pipe(
 *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))
 * )
 * ```
 */
function concatLatestFrom(observablesFactory) {
  return (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.concatMap)(value => {
    const observables = observablesFactory(value);
    const observablesAsArray = Array.isArray(observables) ? observables : [observables];
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(value).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.withLatestFrom)(...observablesAsArray));
  });
}

/**
 * Handles the response in ComponentStore effects in a safe way, without
 * additional boilerplate. It enforces that the error case is handled and
 * that the effect would still be running should an error occur.
 *
 * Takes optional callbacks for `complete` and `finalize`.
 *
 * @usageNotes
 *
 * ```ts
 * readonly dismissAlert = this.effect<Alert>((alert$) => {
 *   return alert$.pipe(
 *     concatMap(
 *       (alert) => this.alertsService.dismissAlert(alert).pipe(
 *         tapResponse(
 *           (dismissedAlert) => this.alertDismissed(dismissedAlert),
 *           (error: { message: string }) => this.logError(error.message)
 *         )
 *       )
 *     )
 *   );
 * });
 *
 * readonly loadUsers = this.effect<void>((trigger$) => {
 *   return trigger$.pipe(
 *     tap(() => this.patchState({ loading: true })),
 *     exhaustMap(() =>
 *       this.usersService.getAll().pipe(
 *         tapResponse({
 *           next: (users) => this.patchState({ users }),
 *           error: (error: HttpErrorResponse) => this.logError(error.message),
 *           finalize: () => this.patchState({ loading: false }),
 *         })
 *       )
 *     )
 *   );
 * });
 * ```
 */
function tapResponse(observerOrNext, error, complete) {
  const observer = typeof observerOrNext === 'function' ? {
    next: observerOrNext,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    error: error,
    complete
  } : observerOrNext;
  return source => source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.tap)({
    next: observer.next,
    complete: observer.complete
  }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.catchError)(error => {
    observer.error(error);
    return rxjs__WEBPACK_IMPORTED_MODULE_0__.EMPTY;
  }), observer.finalize ? (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.finalize)(observer.finalize) : source$ => source$);
}

/**
 * DO NOT EDIT
 *
 * This file is automatically generated at build
 */

/**
 * Generated bundle index. Do not edit.
 */



/***/ })

}])
//# sourceMappingURL=node_modules_ngrx_effects_fesm2022_ngrx-effects_mjs-_56481.js.map
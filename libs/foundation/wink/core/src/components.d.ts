/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AvatarSize } from "./components/avatar/models/avatar.types";
import { BadgeColor, BadgeSize } from "./components/badge/models/badge.types";
import { ButtonAppearance, ButtonElement, ButtonIconPosition, ButtonSize, ButtonState, ButtonType, ButtonWidth } from "./components/button/models/button.types";
import { Target } from "./models/targets.types";
import { Directions } from "./models/positions.types";
import { FormLabelRendition } from "./components/_form-components/form-label/models/form-label.types";
import { IconSize, IconType, IconTypeBasis } from "./components/icon/models/icon.types";
import { LoadingType } from "./components/image/models/image.types";
import { IndicatorDirection } from "./models/directions.types";
import { InputAppearance, InputAutocomplete, InputEnterkeyhint, InputMode, InputSize, InputType } from "./components/_form-components/input/models/input.types";
import { LinkAppearance, LinkPositions, LinkSize, LinkSizeSnowflake } from "./components/link/models/link.types";
import { logoVariant } from "./components/logo/models/logo.types";
import { NotificationType } from "./components/notification/models/notification.types";
import { ParagraphAppearance, ParagraphSize } from "./components/paragraph/models/paragraph.types";
import { Language, PricingAlign, PricingType } from "./components/pricing/models/pricing.types";
import { SliderType } from "./components/_form-components/range-slider/models/range-slider.types";
import { Size } from "./models/sizes.types";
import { Size as Size1 } from "./components/stack/models/stack.types";
import { TabTypes } from "./components/tabs/models/tabs.types";
import { AutocompleteOptions } from "./components/_form-components/textarea/models/textarea.types";
import { TitleSize, TitleSpacingY } from "./components/title/models/title.types";
import { ToastType } from "./components/toaster/_sub-comps/toast/models/toast.types";
import { ToastElement } from "./components/toaster/models/toaster.types";
import { toggleAlignment } from "./components/_form-components/toggle-switch/models/toggle-switch.types";
import { ValidationTypes } from "./components/_form-components/validation-message/models/validation-message.types";
export { AvatarSize } from "./components/avatar/models/avatar.types";
export { BadgeColor, BadgeSize } from "./components/badge/models/badge.types";
export { ButtonAppearance, ButtonElement, ButtonIconPosition, ButtonSize, ButtonState, ButtonType, ButtonWidth } from "./components/button/models/button.types";
export { Target } from "./models/targets.types";
export { Directions } from "./models/positions.types";
export { FormLabelRendition } from "./components/_form-components/form-label/models/form-label.types";
export { IconSize, IconType, IconTypeBasis } from "./components/icon/models/icon.types";
export { LoadingType } from "./components/image/models/image.types";
export { IndicatorDirection } from "./models/directions.types";
export { InputAppearance, InputAutocomplete, InputEnterkeyhint, InputMode, InputSize, InputType } from "./components/_form-components/input/models/input.types";
export { LinkAppearance, LinkPositions, LinkSize, LinkSizeSnowflake } from "./components/link/models/link.types";
export { logoVariant } from "./components/logo/models/logo.types";
export { NotificationType } from "./components/notification/models/notification.types";
export { ParagraphAppearance, ParagraphSize } from "./components/paragraph/models/paragraph.types";
export { Language, PricingAlign, PricingType } from "./components/pricing/models/pricing.types";
export { SliderType } from "./components/_form-components/range-slider/models/range-slider.types";
export { Size } from "./models/sizes.types";
export { Size as Size1 } from "./components/stack/models/stack.types";
export { TabTypes } from "./components/tabs/models/tabs.types";
export { AutocompleteOptions } from "./components/_form-components/textarea/models/textarea.types";
export { TitleSize, TitleSpacingY } from "./components/title/models/title.types";
export { ToastType } from "./components/toaster/_sub-comps/toast/models/toast.types";
export { ToastElement } from "./components/toaster/models/toaster.types";
export { toggleAlignment } from "./components/_form-components/toggle-switch/models/toggle-switch.types";
export { ValidationTypes } from "./components/_form-components/validation-message/models/validation-message.types";
export namespace Components {
    interface WinkAccordion {
        "heading": string;
        "icon": string;
        "isExpanded": boolean;
    }
    interface WinkAnimation {
        "autoplay": boolean;
        "clickToPlay": boolean;
        "controls": boolean;
        "count": number;
        "src": string;
        "toggleAnimation": () => Promise<void>;
    }
    interface WinkAvatar {
        "size": AvatarSize;
        "src": string;
    }
    interface WinkBadge {
        "background": BadgeColor;
        "size": BadgeSize;
        "text": string;
    }
    interface WinkButton {
        "appearance": ButtonAppearance;
        "element": ButtonElement;
        "href"?: string;
        "icon"?: string;
        "iconButtonAriaLabel"?: string;
        "iconPosition"?: ButtonIconPosition;
        "loadingText"?: string;
        "size": ButtonSize;
        "status": ButtonState;
        "target": Target;
        "text"?: string;
        "type": ButtonType;
        "width": ButtonWidth;
    }
    interface WinkCheckBox {
        "checkboxId": string;
        "checked": boolean;
        "disabled": boolean;
        "error": boolean;
        "helper": string;
        "label": string;
        "name": string;
    }
    interface WinkCheckBoxGroup {
        "direction": Directions;
        "error"?: string;
        "helper": string;
        "isRequired": boolean;
        "label": string;
        "optionalText": string;
        "setValidation": (errorMsg?: string) => Promise<void>;
    }
    interface WinkColumnCount {
        "colsCount": number;
    }
    interface WinkCustomerOrientation {
    }
    interface WinkDropdownMenu {
        "dropdownTabIndex"?: number;
        "heading"?: string;
        "isExpanded"?: boolean;
        "itemSelected"?: string;
    }
    interface WinkFlyout {
        "flyoutId": number | undefined;
    }
    interface WinkFormLabel {
        "helper"?: string;
        "helperId"?: string;
        "isDisabled": boolean;
        "label": string;
        "labelId"?: string;
        "optionalText": string;
        "rendition": FormLabelRendition;
        "showOptional": boolean;
    }
    interface WinkGlobalHeader {
    }
    interface WinkIcon {
        "appearance": IconType;
        "icon": string;
        "size": IconSize;
    }
    interface WinkImg {
        "alt"?: string;
        "loading": LoadingType;
        "srcDesktop": string;
        "srcMobile"?: string;
        "srcTablet"?: string;
    }
    interface WinkIndicator {
        "direction": IndicatorDirection;
        "size": ButtonSize;
    }
    interface WinkInput {
        "appearance": InputAppearance;
        "autocomplete": InputAutocomplete;
        "enterkeyhintOption": InputEnterkeyhint;
        "error"?: string;
        "helper": string;
        "iconLeft": string;
        "iconRight": string;
        "inputId": string;
        "inputModeOption": InputMode;
        "isAutofocused": boolean;
        "isDisabled": boolean;
        "isReadonly": boolean;
        "isRequired": boolean;
        "label": string;
        "maxValue"?: number | string;
        "minValue"?: number | string;
        "name": string;
        "optionalText": string;
        "placeholder": string;
        "postfixValue": string;
        "prefixValue": string;
        "setValidation": (errorMsg?: string) => Promise<void>;
        "size": InputSize;
        "step"?: number;
        "type": InputType;
        "value": string;
    }
    interface WinkIntentBar {
    }
    interface WinkLink {
        "appearance": LinkAppearance;
        "href": string;
        "icon"?: string;
        "iconAppearance": IconTypeBasis;
        "iconPosition": LinkPositions;
        "isDisabled": boolean;
        "size": LinkSize | LinkSizeSnowflake;
        "target": Target;
    }
    interface WinkLogo {
        "alt": string;
        "appearance"?: logoVariant;
        "href": string;
        "target": Target;
    }
    interface WinkMainNavigation {
        "menuItems": string;
    }
    interface WinkNavigationList {
        "hasBoldLinks": boolean;
        "listTitle": string;
    }
    interface WinkNavigationListItem {
        "href": string;
        "target": Target;
    }
    interface WinkNotification {
        "appearance": NotificationType;
        "hasCloseIcon": boolean;
    }
    interface WinkParagraph {
        "appearance": ParagraphAppearance;
        "size": ParagraphSize;
    }
    interface WinkPricing {
        "alignment": PricingAlign;
        "annotation": Language;
        "appearance": PricingType;
        "duration"?: string;
        "frequency"?: string;
        "price": string;
        "priceStrikethrough"?: string;
        "startingFrom"?: string;
    }
    interface WinkRadioButton {
        "checked": boolean;
        "disabled": boolean;
        "error": boolean;
        "helper": string;
        "label": string;
        "name": string;
        "radioButtonId": string;
    }
    interface WinkRadioGroup {
        "direction": Directions;
        "error"?: string;
        "helper": string;
        "isRequired": boolean;
        "label": string;
        "optionalText": string;
        "setValidation": (errorMsg?: string) => Promise<void>;
    }
    interface WinkRangeSlider {
        "bottomValue": number;
        "errorMessage": string;
        "getDragValue": () => Promise<number>;
        "helper": string;
        "label": string;
        "maxValue": number;
        "minValue": number;
        "showFromValue": () => Promise<number>;
        "showInput": boolean;
        "showToValue": () => Promise<number>;
        "showValues": boolean;
        "sliderId": string;
        "sliderType": SliderType;
        "step": number;
        "value": number;
    }
    interface WinkSelect {
        "error"?: string;
        "helper"?: string;
        "isDisabled": boolean;
        "isRequired": boolean;
        "label"?: string;
        "placeholder"?: string;
        "selectId": string;
        "selectName"?: string;
        "value"?: string;
    }
    interface WinkSheet {
        "close": () => Promise<void>;
        "dashboard": boolean;
        "isVisible": boolean;
        "multipage": boolean;
        "nextPage": () => Promise<void>;
        "open": () => Promise<void>;
    }
    interface WinkSpacer {
        "size": Size;
    }
    interface WinkStack {
        "alignItems"?: Size1;
        "col": Size1;
        "direction"?: Size1;
        "gap": Size1;
        "justifyContent"?: Size1;
        "wrap"?: Size1;
    }
    interface WinkTabs {
        "appearance": TabTypes;
    }
    interface WinkTextarea {
        "autocomplete": AutocompleteOptions;
        "enterkeyhintOption": InputEnterkeyhint;
        "error"?: string;
        "helper"?: string;
        "isDisabled": boolean;
        "isRequired": boolean;
        "label"?: string;
        "maxlength"?: number;
        "minlength"?: number;
        "name"?: string;
        "placeholder"?: string;
        "rows"?: number;
        "textareaId": string;
    }
    interface WinkTitle {
        "htmlTag": TitleSize;
        "noSeo": boolean;
        "spacingY": TitleSpacingY;
        "text": string;
    }
    interface WinkToast {
        "appearance": ToastType;
        "currentTheme": string;
        "duration"?: number | undefined;
        "href"?: string;
        "isOpen": boolean;
        "linkText"?: string;
        "target"?: Target;
        "text": string;
        "theme": string;
    }
    interface WinkToaster {
        "winkCreateToast": (toast: ToastElement) => Promise<void>;
    }
    interface WinkToggleSwitch {
        "alignment": toggleAlignment;
        "checked": boolean;
        "disabled": boolean;
        "label": string;
        "toggleSwitchId": string;
        "toggleSwitchName": string;
    }
    interface WinkValidationMessage {
        "message"?: string;
        "type": ValidationTypes;
    }
}
export interface WinkFlyoutCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWinkFlyoutElement;
}
export interface WinkInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWinkInputElement;
}
export interface WinkMainNavigationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLWinkMainNavigationElement;
}
declare global {
    interface HTMLWinkAccordionElement extends Components.WinkAccordion, HTMLStencilElement {
    }
    var HTMLWinkAccordionElement: {
        prototype: HTMLWinkAccordionElement;
        new (): HTMLWinkAccordionElement;
    };
    interface HTMLWinkAnimationElement extends Components.WinkAnimation, HTMLStencilElement {
    }
    var HTMLWinkAnimationElement: {
        prototype: HTMLWinkAnimationElement;
        new (): HTMLWinkAnimationElement;
    };
    interface HTMLWinkAvatarElement extends Components.WinkAvatar, HTMLStencilElement {
    }
    var HTMLWinkAvatarElement: {
        prototype: HTMLWinkAvatarElement;
        new (): HTMLWinkAvatarElement;
    };
    interface HTMLWinkBadgeElement extends Components.WinkBadge, HTMLStencilElement {
    }
    var HTMLWinkBadgeElement: {
        prototype: HTMLWinkBadgeElement;
        new (): HTMLWinkBadgeElement;
    };
    interface HTMLWinkButtonElement extends Components.WinkButton, HTMLStencilElement {
    }
    var HTMLWinkButtonElement: {
        prototype: HTMLWinkButtonElement;
        new (): HTMLWinkButtonElement;
    };
    interface HTMLWinkCheckBoxElement extends Components.WinkCheckBox, HTMLStencilElement {
    }
    var HTMLWinkCheckBoxElement: {
        prototype: HTMLWinkCheckBoxElement;
        new (): HTMLWinkCheckBoxElement;
    };
    interface HTMLWinkCheckBoxGroupElement extends Components.WinkCheckBoxGroup, HTMLStencilElement {
    }
    var HTMLWinkCheckBoxGroupElement: {
        prototype: HTMLWinkCheckBoxGroupElement;
        new (): HTMLWinkCheckBoxGroupElement;
    };
    interface HTMLWinkColumnCountElement extends Components.WinkColumnCount, HTMLStencilElement {
    }
    var HTMLWinkColumnCountElement: {
        prototype: HTMLWinkColumnCountElement;
        new (): HTMLWinkColumnCountElement;
    };
    interface HTMLWinkCustomerOrientationElement extends Components.WinkCustomerOrientation, HTMLStencilElement {
    }
    var HTMLWinkCustomerOrientationElement: {
        prototype: HTMLWinkCustomerOrientationElement;
        new (): HTMLWinkCustomerOrientationElement;
    };
    interface HTMLWinkDropdownMenuElement extends Components.WinkDropdownMenu, HTMLStencilElement {
    }
    var HTMLWinkDropdownMenuElement: {
        prototype: HTMLWinkDropdownMenuElement;
        new (): HTMLWinkDropdownMenuElement;
    };
    interface HTMLWinkFlyoutElementEventMap {
        "flyoutBackLinkClicked": any;
    }
    interface HTMLWinkFlyoutElement extends Components.WinkFlyout, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWinkFlyoutElementEventMap>(type: K, listener: (this: HTMLWinkFlyoutElement, ev: WinkFlyoutCustomEvent<HTMLWinkFlyoutElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWinkFlyoutElementEventMap>(type: K, listener: (this: HTMLWinkFlyoutElement, ev: WinkFlyoutCustomEvent<HTMLWinkFlyoutElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWinkFlyoutElement: {
        prototype: HTMLWinkFlyoutElement;
        new (): HTMLWinkFlyoutElement;
    };
    interface HTMLWinkFormLabelElement extends Components.WinkFormLabel, HTMLStencilElement {
    }
    var HTMLWinkFormLabelElement: {
        prototype: HTMLWinkFormLabelElement;
        new (): HTMLWinkFormLabelElement;
    };
    interface HTMLWinkGlobalHeaderElement extends Components.WinkGlobalHeader, HTMLStencilElement {
    }
    var HTMLWinkGlobalHeaderElement: {
        prototype: HTMLWinkGlobalHeaderElement;
        new (): HTMLWinkGlobalHeaderElement;
    };
    interface HTMLWinkIconElement extends Components.WinkIcon, HTMLStencilElement {
    }
    var HTMLWinkIconElement: {
        prototype: HTMLWinkIconElement;
        new (): HTMLWinkIconElement;
    };
    interface HTMLWinkImgElement extends Components.WinkImg, HTMLStencilElement {
    }
    var HTMLWinkImgElement: {
        prototype: HTMLWinkImgElement;
        new (): HTMLWinkImgElement;
    };
    interface HTMLWinkIndicatorElement extends Components.WinkIndicator, HTMLStencilElement {
    }
    var HTMLWinkIndicatorElement: {
        prototype: HTMLWinkIndicatorElement;
        new (): HTMLWinkIndicatorElement;
    };
    interface HTMLWinkInputElementEventMap {
        "valueChanged": any;
    }
    interface HTMLWinkInputElement extends Components.WinkInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWinkInputElementEventMap>(type: K, listener: (this: HTMLWinkInputElement, ev: WinkInputCustomEvent<HTMLWinkInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWinkInputElementEventMap>(type: K, listener: (this: HTMLWinkInputElement, ev: WinkInputCustomEvent<HTMLWinkInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWinkInputElement: {
        prototype: HTMLWinkInputElement;
        new (): HTMLWinkInputElement;
    };
    interface HTMLWinkIntentBarElement extends Components.WinkIntentBar, HTMLStencilElement {
    }
    var HTMLWinkIntentBarElement: {
        prototype: HTMLWinkIntentBarElement;
        new (): HTMLWinkIntentBarElement;
    };
    interface HTMLWinkLinkElement extends Components.WinkLink, HTMLStencilElement {
    }
    var HTMLWinkLinkElement: {
        prototype: HTMLWinkLinkElement;
        new (): HTMLWinkLinkElement;
    };
    interface HTMLWinkLogoElement extends Components.WinkLogo, HTMLStencilElement {
    }
    var HTMLWinkLogoElement: {
        prototype: HTMLWinkLogoElement;
        new (): HTMLWinkLogoElement;
    };
    interface HTMLWinkMainNavigationElementEventMap {
        "mainNavigationItemClicked": any;
    }
    interface HTMLWinkMainNavigationElement extends Components.WinkMainNavigation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLWinkMainNavigationElementEventMap>(type: K, listener: (this: HTMLWinkMainNavigationElement, ev: WinkMainNavigationCustomEvent<HTMLWinkMainNavigationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLWinkMainNavigationElementEventMap>(type: K, listener: (this: HTMLWinkMainNavigationElement, ev: WinkMainNavigationCustomEvent<HTMLWinkMainNavigationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLWinkMainNavigationElement: {
        prototype: HTMLWinkMainNavigationElement;
        new (): HTMLWinkMainNavigationElement;
    };
    interface HTMLWinkNavigationListElement extends Components.WinkNavigationList, HTMLStencilElement {
    }
    var HTMLWinkNavigationListElement: {
        prototype: HTMLWinkNavigationListElement;
        new (): HTMLWinkNavigationListElement;
    };
    interface HTMLWinkNavigationListItemElement extends Components.WinkNavigationListItem, HTMLStencilElement {
    }
    var HTMLWinkNavigationListItemElement: {
        prototype: HTMLWinkNavigationListItemElement;
        new (): HTMLWinkNavigationListItemElement;
    };
    interface HTMLWinkNotificationElement extends Components.WinkNotification, HTMLStencilElement {
    }
    var HTMLWinkNotificationElement: {
        prototype: HTMLWinkNotificationElement;
        new (): HTMLWinkNotificationElement;
    };
    interface HTMLWinkParagraphElement extends Components.WinkParagraph, HTMLStencilElement {
    }
    var HTMLWinkParagraphElement: {
        prototype: HTMLWinkParagraphElement;
        new (): HTMLWinkParagraphElement;
    };
    interface HTMLWinkPricingElement extends Components.WinkPricing, HTMLStencilElement {
    }
    var HTMLWinkPricingElement: {
        prototype: HTMLWinkPricingElement;
        new (): HTMLWinkPricingElement;
    };
    interface HTMLWinkRadioButtonElement extends Components.WinkRadioButton, HTMLStencilElement {
    }
    var HTMLWinkRadioButtonElement: {
        prototype: HTMLWinkRadioButtonElement;
        new (): HTMLWinkRadioButtonElement;
    };
    interface HTMLWinkRadioGroupElement extends Components.WinkRadioGroup, HTMLStencilElement {
    }
    var HTMLWinkRadioGroupElement: {
        prototype: HTMLWinkRadioGroupElement;
        new (): HTMLWinkRadioGroupElement;
    };
    interface HTMLWinkRangeSliderElement extends Components.WinkRangeSlider, HTMLStencilElement {
    }
    var HTMLWinkRangeSliderElement: {
        prototype: HTMLWinkRangeSliderElement;
        new (): HTMLWinkRangeSliderElement;
    };
    interface HTMLWinkSelectElement extends Components.WinkSelect, HTMLStencilElement {
    }
    var HTMLWinkSelectElement: {
        prototype: HTMLWinkSelectElement;
        new (): HTMLWinkSelectElement;
    };
    interface HTMLWinkSheetElement extends Components.WinkSheet, HTMLStencilElement {
    }
    var HTMLWinkSheetElement: {
        prototype: HTMLWinkSheetElement;
        new (): HTMLWinkSheetElement;
    };
    interface HTMLWinkSpacerElement extends Components.WinkSpacer, HTMLStencilElement {
    }
    var HTMLWinkSpacerElement: {
        prototype: HTMLWinkSpacerElement;
        new (): HTMLWinkSpacerElement;
    };
    interface HTMLWinkStackElement extends Components.WinkStack, HTMLStencilElement {
    }
    var HTMLWinkStackElement: {
        prototype: HTMLWinkStackElement;
        new (): HTMLWinkStackElement;
    };
    interface HTMLWinkTabsElement extends Components.WinkTabs, HTMLStencilElement {
    }
    var HTMLWinkTabsElement: {
        prototype: HTMLWinkTabsElement;
        new (): HTMLWinkTabsElement;
    };
    interface HTMLWinkTextareaElement extends Components.WinkTextarea, HTMLStencilElement {
    }
    var HTMLWinkTextareaElement: {
        prototype: HTMLWinkTextareaElement;
        new (): HTMLWinkTextareaElement;
    };
    interface HTMLWinkTitleElement extends Components.WinkTitle, HTMLStencilElement {
    }
    var HTMLWinkTitleElement: {
        prototype: HTMLWinkTitleElement;
        new (): HTMLWinkTitleElement;
    };
    interface HTMLWinkToastElement extends Components.WinkToast, HTMLStencilElement {
    }
    var HTMLWinkToastElement: {
        prototype: HTMLWinkToastElement;
        new (): HTMLWinkToastElement;
    };
    interface HTMLWinkToasterElement extends Components.WinkToaster, HTMLStencilElement {
    }
    var HTMLWinkToasterElement: {
        prototype: HTMLWinkToasterElement;
        new (): HTMLWinkToasterElement;
    };
    interface HTMLWinkToggleSwitchElement extends Components.WinkToggleSwitch, HTMLStencilElement {
    }
    var HTMLWinkToggleSwitchElement: {
        prototype: HTMLWinkToggleSwitchElement;
        new (): HTMLWinkToggleSwitchElement;
    };
    interface HTMLWinkValidationMessageElement extends Components.WinkValidationMessage, HTMLStencilElement {
    }
    var HTMLWinkValidationMessageElement: {
        prototype: HTMLWinkValidationMessageElement;
        new (): HTMLWinkValidationMessageElement;
    };
    interface HTMLElementTagNameMap {
        "wink-accordion": HTMLWinkAccordionElement;
        "wink-animation": HTMLWinkAnimationElement;
        "wink-avatar": HTMLWinkAvatarElement;
        "wink-badge": HTMLWinkBadgeElement;
        "wink-button": HTMLWinkButtonElement;
        "wink-check-box": HTMLWinkCheckBoxElement;
        "wink-check-box-group": HTMLWinkCheckBoxGroupElement;
        "wink-column-count": HTMLWinkColumnCountElement;
        "wink-customer-orientation": HTMLWinkCustomerOrientationElement;
        "wink-dropdown-menu": HTMLWinkDropdownMenuElement;
        "wink-flyout": HTMLWinkFlyoutElement;
        "wink-form-label": HTMLWinkFormLabelElement;
        "wink-global-header": HTMLWinkGlobalHeaderElement;
        "wink-icon": HTMLWinkIconElement;
        "wink-img": HTMLWinkImgElement;
        "wink-indicator": HTMLWinkIndicatorElement;
        "wink-input": HTMLWinkInputElement;
        "wink-intent-bar": HTMLWinkIntentBarElement;
        "wink-link": HTMLWinkLinkElement;
        "wink-logo": HTMLWinkLogoElement;
        "wink-main-navigation": HTMLWinkMainNavigationElement;
        "wink-navigation-list": HTMLWinkNavigationListElement;
        "wink-navigation-list-item": HTMLWinkNavigationListItemElement;
        "wink-notification": HTMLWinkNotificationElement;
        "wink-paragraph": HTMLWinkParagraphElement;
        "wink-pricing": HTMLWinkPricingElement;
        "wink-radio-button": HTMLWinkRadioButtonElement;
        "wink-radio-group": HTMLWinkRadioGroupElement;
        "wink-range-slider": HTMLWinkRangeSliderElement;
        "wink-select": HTMLWinkSelectElement;
        "wink-sheet": HTMLWinkSheetElement;
        "wink-spacer": HTMLWinkSpacerElement;
        "wink-stack": HTMLWinkStackElement;
        "wink-tabs": HTMLWinkTabsElement;
        "wink-textarea": HTMLWinkTextareaElement;
        "wink-title": HTMLWinkTitleElement;
        "wink-toast": HTMLWinkToastElement;
        "wink-toaster": HTMLWinkToasterElement;
        "wink-toggle-switch": HTMLWinkToggleSwitchElement;
        "wink-validation-message": HTMLWinkValidationMessageElement;
    }
}
declare namespace LocalJSX {
    interface WinkAccordion {
        "heading"?: string;
        "icon"?: string;
        "isExpanded"?: boolean;
    }
    interface WinkAnimation {
        "autoplay"?: boolean;
        "clickToPlay"?: boolean;
        "controls"?: boolean;
        "count"?: number;
        "src"?: string;
    }
    interface WinkAvatar {
        "size"?: AvatarSize;
        "src": string;
    }
    interface WinkBadge {
        "background"?: BadgeColor;
        "size"?: BadgeSize;
        "text"?: string;
    }
    interface WinkButton {
        "appearance"?: ButtonAppearance;
        "element"?: ButtonElement;
        "href"?: string;
        "icon"?: string;
        "iconButtonAriaLabel"?: string;
        "iconPosition"?: ButtonIconPosition;
        "loadingText"?: string;
        "size"?: ButtonSize;
        "status"?: ButtonState;
        "target"?: Target;
        "text"?: string;
        "type"?: ButtonType;
        "width"?: ButtonWidth;
    }
    interface WinkCheckBox {
        "checkboxId"?: string;
        "checked"?: boolean;
        "disabled"?: boolean;
        "error"?: boolean;
        "helper"?: string;
        "label"?: string;
        "name"?: string;
    }
    interface WinkCheckBoxGroup {
        "direction"?: Directions;
        "error"?: string;
        "helper"?: string;
        "isRequired"?: boolean;
        "label"?: string;
        "optionalText"?: string;
    }
    interface WinkColumnCount {
        "colsCount"?: number;
    }
    interface WinkCustomerOrientation {
    }
    interface WinkDropdownMenu {
        "dropdownTabIndex"?: number;
        "heading"?: string;
        "isExpanded"?: boolean;
        "itemSelected"?: string;
    }
    interface WinkFlyout {
        "flyoutId"?: number | undefined;
        "onFlyoutBackLinkClicked"?: (event: WinkFlyoutCustomEvent<any>) => void;
    }
    interface WinkFormLabel {
        "helper"?: string;
        "helperId"?: string;
        "isDisabled"?: boolean;
        "label"?: string;
        "labelId"?: string;
        "optionalText"?: string;
        "rendition"?: FormLabelRendition;
        "showOptional"?: boolean;
    }
    interface WinkGlobalHeader {
    }
    interface WinkIcon {
        "appearance"?: IconType;
        "icon"?: string;
        "size"?: IconSize;
    }
    interface WinkImg {
        "alt"?: string;
        "loading"?: LoadingType;
        "srcDesktop"?: string;
        "srcMobile"?: string;
        "srcTablet"?: string;
    }
    interface WinkIndicator {
        "direction"?: IndicatorDirection;
        "size"?: ButtonSize;
    }
    interface WinkInput {
        "appearance"?: InputAppearance;
        "autocomplete"?: InputAutocomplete;
        "enterkeyhintOption"?: InputEnterkeyhint;
        "error"?: string;
        "helper"?: string;
        "iconLeft"?: string;
        "iconRight"?: string;
        "inputId": string;
        "inputModeOption"?: InputMode;
        "isAutofocused"?: boolean;
        "isDisabled"?: boolean;
        "isReadonly"?: boolean;
        "isRequired"?: boolean;
        "label"?: string;
        "maxValue"?: number | string;
        "minValue"?: number | string;
        "name": string;
        "onValueChanged"?: (event: WinkInputCustomEvent<any>) => void;
        "optionalText"?: string;
        "placeholder"?: string;
        "postfixValue"?: string;
        "prefixValue"?: string;
        "size"?: InputSize;
        "step"?: number;
        "type"?: InputType;
        "value"?: string;
    }
    interface WinkIntentBar {
    }
    interface WinkLink {
        "appearance"?: LinkAppearance;
        "href"?: string;
        "icon"?: string;
        "iconAppearance"?: IconTypeBasis;
        "iconPosition"?: LinkPositions;
        "isDisabled"?: boolean;
        "size"?: LinkSize | LinkSizeSnowflake;
        "target"?: Target;
    }
    interface WinkLogo {
        "alt"?: string;
        "appearance"?: logoVariant;
        "href"?: string;
        "target"?: Target;
    }
    interface WinkMainNavigation {
        "menuItems"?: string;
        "onMainNavigationItemClicked"?: (event: WinkMainNavigationCustomEvent<any>) => void;
    }
    interface WinkNavigationList {
        "hasBoldLinks"?: boolean;
        "listTitle"?: string;
    }
    interface WinkNavigationListItem {
        "href"?: string;
        "target"?: Target;
    }
    interface WinkNotification {
        "appearance"?: NotificationType;
        "hasCloseIcon"?: boolean;
    }
    interface WinkParagraph {
        "appearance"?: ParagraphAppearance;
        "size"?: ParagraphSize;
    }
    interface WinkPricing {
        "alignment"?: PricingAlign;
        "annotation"?: Language;
        "appearance"?: PricingType;
        "duration"?: string;
        "frequency"?: string;
        "price"?: string;
        "priceStrikethrough"?: string;
        "startingFrom"?: string;
    }
    interface WinkRadioButton {
        "checked"?: boolean;
        "disabled"?: boolean;
        "error"?: boolean;
        "helper"?: string;
        "label"?: string;
        "name"?: string;
        "radioButtonId"?: string;
    }
    interface WinkRadioGroup {
        "direction"?: Directions;
        "error"?: string;
        "helper"?: string;
        "isRequired"?: boolean;
        "label"?: string;
        "optionalText"?: string;
    }
    interface WinkRangeSlider {
        "bottomValue"?: number;
        "errorMessage"?: string;
        "helper"?: string;
        "label"?: string;
        "maxValue"?: number;
        "minValue"?: number;
        "showInput"?: boolean;
        "showValues"?: boolean;
        "sliderId"?: string;
        "sliderType"?: SliderType;
        "step"?: number;
        "value"?: number;
    }
    interface WinkSelect {
        "error"?: string;
        "helper"?: string;
        "isDisabled"?: boolean;
        "isRequired"?: boolean;
        "label"?: string;
        "placeholder"?: string;
        "selectId"?: string;
        "selectName"?: string;
        "value"?: string;
    }
    interface WinkSheet {
        "dashboard"?: boolean;
        "isVisible"?: boolean;
        "multipage"?: boolean;
    }
    interface WinkSpacer {
        "size"?: Size;
    }
    interface WinkStack {
        "alignItems"?: Size1;
        "col"?: Size1;
        "direction"?: Size1;
        "gap"?: Size1;
        "justifyContent"?: Size1;
        "wrap"?: Size1;
    }
    interface WinkTabs {
        "appearance"?: TabTypes;
    }
    interface WinkTextarea {
        "autocomplete"?: AutocompleteOptions;
        "enterkeyhintOption"?: InputEnterkeyhint;
        "error"?: string;
        "helper"?: string;
        "isDisabled"?: boolean;
        "isRequired"?: boolean;
        "label"?: string;
        "maxlength"?: number;
        "minlength"?: number;
        "name"?: string;
        "placeholder"?: string;
        "rows"?: number;
        "textareaId": string;
    }
    interface WinkTitle {
        "htmlTag"?: TitleSize;
        "noSeo"?: boolean;
        "spacingY"?: TitleSpacingY;
        "text"?: string;
    }
    interface WinkToast {
        "appearance"?: ToastType;
        "currentTheme"?: string;
        "duration"?: number | undefined;
        "href"?: string;
        "isOpen"?: boolean;
        "linkText"?: string;
        "target"?: Target;
        "text"?: string;
        "theme"?: string;
    }
    interface WinkToaster {
    }
    interface WinkToggleSwitch {
        "alignment"?: toggleAlignment;
        "checked"?: boolean;
        "disabled"?: boolean;
        "label"?: string;
        "toggleSwitchId"?: string;
        "toggleSwitchName"?: string;
    }
    interface WinkValidationMessage {
        "message"?: string;
        "type"?: ValidationTypes;
    }
    interface IntrinsicElements {
        "wink-accordion": WinkAccordion;
        "wink-animation": WinkAnimation;
        "wink-avatar": WinkAvatar;
        "wink-badge": WinkBadge;
        "wink-button": WinkButton;
        "wink-check-box": WinkCheckBox;
        "wink-check-box-group": WinkCheckBoxGroup;
        "wink-column-count": WinkColumnCount;
        "wink-customer-orientation": WinkCustomerOrientation;
        "wink-dropdown-menu": WinkDropdownMenu;
        "wink-flyout": WinkFlyout;
        "wink-form-label": WinkFormLabel;
        "wink-global-header": WinkGlobalHeader;
        "wink-icon": WinkIcon;
        "wink-img": WinkImg;
        "wink-indicator": WinkIndicator;
        "wink-input": WinkInput;
        "wink-intent-bar": WinkIntentBar;
        "wink-link": WinkLink;
        "wink-logo": WinkLogo;
        "wink-main-navigation": WinkMainNavigation;
        "wink-navigation-list": WinkNavigationList;
        "wink-navigation-list-item": WinkNavigationListItem;
        "wink-notification": WinkNotification;
        "wink-paragraph": WinkParagraph;
        "wink-pricing": WinkPricing;
        "wink-radio-button": WinkRadioButton;
        "wink-radio-group": WinkRadioGroup;
        "wink-range-slider": WinkRangeSlider;
        "wink-select": WinkSelect;
        "wink-sheet": WinkSheet;
        "wink-spacer": WinkSpacer;
        "wink-stack": WinkStack;
        "wink-tabs": WinkTabs;
        "wink-textarea": WinkTextarea;
        "wink-title": WinkTitle;
        "wink-toast": WinkToast;
        "wink-toaster": WinkToaster;
        "wink-toggle-switch": WinkToggleSwitch;
        "wink-validation-message": WinkValidationMessage;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "wink-accordion": LocalJSX.WinkAccordion & JSXBase.HTMLAttributes<HTMLWinkAccordionElement>;
            "wink-animation": LocalJSX.WinkAnimation & JSXBase.HTMLAttributes<HTMLWinkAnimationElement>;
            "wink-avatar": LocalJSX.WinkAvatar & JSXBase.HTMLAttributes<HTMLWinkAvatarElement>;
            "wink-badge": LocalJSX.WinkBadge & JSXBase.HTMLAttributes<HTMLWinkBadgeElement>;
            "wink-button": LocalJSX.WinkButton & JSXBase.HTMLAttributes<HTMLWinkButtonElement>;
            "wink-check-box": LocalJSX.WinkCheckBox & JSXBase.HTMLAttributes<HTMLWinkCheckBoxElement>;
            "wink-check-box-group": LocalJSX.WinkCheckBoxGroup & JSXBase.HTMLAttributes<HTMLWinkCheckBoxGroupElement>;
            "wink-column-count": LocalJSX.WinkColumnCount & JSXBase.HTMLAttributes<HTMLWinkColumnCountElement>;
            "wink-customer-orientation": LocalJSX.WinkCustomerOrientation & JSXBase.HTMLAttributes<HTMLWinkCustomerOrientationElement>;
            "wink-dropdown-menu": LocalJSX.WinkDropdownMenu & JSXBase.HTMLAttributes<HTMLWinkDropdownMenuElement>;
            "wink-flyout": LocalJSX.WinkFlyout & JSXBase.HTMLAttributes<HTMLWinkFlyoutElement>;
            "wink-form-label": LocalJSX.WinkFormLabel & JSXBase.HTMLAttributes<HTMLWinkFormLabelElement>;
            "wink-global-header": LocalJSX.WinkGlobalHeader & JSXBase.HTMLAttributes<HTMLWinkGlobalHeaderElement>;
            "wink-icon": LocalJSX.WinkIcon & JSXBase.HTMLAttributes<HTMLWinkIconElement>;
            "wink-img": LocalJSX.WinkImg & JSXBase.HTMLAttributes<HTMLWinkImgElement>;
            "wink-indicator": LocalJSX.WinkIndicator & JSXBase.HTMLAttributes<HTMLWinkIndicatorElement>;
            "wink-input": LocalJSX.WinkInput & JSXBase.HTMLAttributes<HTMLWinkInputElement>;
            "wink-intent-bar": LocalJSX.WinkIntentBar & JSXBase.HTMLAttributes<HTMLWinkIntentBarElement>;
            "wink-link": LocalJSX.WinkLink & JSXBase.HTMLAttributes<HTMLWinkLinkElement>;
            "wink-logo": LocalJSX.WinkLogo & JSXBase.HTMLAttributes<HTMLWinkLogoElement>;
            "wink-main-navigation": LocalJSX.WinkMainNavigation & JSXBase.HTMLAttributes<HTMLWinkMainNavigationElement>;
            "wink-navigation-list": LocalJSX.WinkNavigationList & JSXBase.HTMLAttributes<HTMLWinkNavigationListElement>;
            "wink-navigation-list-item": LocalJSX.WinkNavigationListItem & JSXBase.HTMLAttributes<HTMLWinkNavigationListItemElement>;
            "wink-notification": LocalJSX.WinkNotification & JSXBase.HTMLAttributes<HTMLWinkNotificationElement>;
            "wink-paragraph": LocalJSX.WinkParagraph & JSXBase.HTMLAttributes<HTMLWinkParagraphElement>;
            "wink-pricing": LocalJSX.WinkPricing & JSXBase.HTMLAttributes<HTMLWinkPricingElement>;
            "wink-radio-button": LocalJSX.WinkRadioButton & JSXBase.HTMLAttributes<HTMLWinkRadioButtonElement>;
            "wink-radio-group": LocalJSX.WinkRadioGroup & JSXBase.HTMLAttributes<HTMLWinkRadioGroupElement>;
            "wink-range-slider": LocalJSX.WinkRangeSlider & JSXBase.HTMLAttributes<HTMLWinkRangeSliderElement>;
            "wink-select": LocalJSX.WinkSelect & JSXBase.HTMLAttributes<HTMLWinkSelectElement>;
            "wink-sheet": LocalJSX.WinkSheet & JSXBase.HTMLAttributes<HTMLWinkSheetElement>;
            "wink-spacer": LocalJSX.WinkSpacer & JSXBase.HTMLAttributes<HTMLWinkSpacerElement>;
            "wink-stack": LocalJSX.WinkStack & JSXBase.HTMLAttributes<HTMLWinkStackElement>;
            "wink-tabs": LocalJSX.WinkTabs & JSXBase.HTMLAttributes<HTMLWinkTabsElement>;
            "wink-textarea": LocalJSX.WinkTextarea & JSXBase.HTMLAttributes<HTMLWinkTextareaElement>;
            "wink-title": LocalJSX.WinkTitle & JSXBase.HTMLAttributes<HTMLWinkTitleElement>;
            "wink-toast": LocalJSX.WinkToast & JSXBase.HTMLAttributes<HTMLWinkToastElement>;
            "wink-toaster": LocalJSX.WinkToaster & JSXBase.HTMLAttributes<HTMLWinkToasterElement>;
            "wink-toggle-switch": LocalJSX.WinkToggleSwitch & JSXBase.HTMLAttributes<HTMLWinkToggleSwitchElement>;
            "wink-validation-message": LocalJSX.WinkValidationMessage & JSXBase.HTMLAttributes<HTMLWinkValidationMessageElement>;
        }
    }
}
